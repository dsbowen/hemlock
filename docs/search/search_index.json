{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hemlock Hemlock aspires to be the most powerful and flexible way to create online studies, with applications in marketing and behavioral science research. If the installation and quickstart instructions don't make sense to you, check out the tutorial . Contact If you're a marketing, political advertising, or other for-profit company, see my contact page for details on hiring me as a consultant and purchasing a commercial license. If you're an academic or non-profit researcher interested in using hemlock, for a limited time I am offering to make studies for you free of charge . See my contact page for contact details and collaboration policy. Why hemlock? If you're an academic researcher interested in using hemlock, but aren't sure if it's worth your time to learn it, read this . Installation $ pip install hemlock-survey Quickstart First, create a file app.py in the root directory of your project: import survey from hemlock import create_app app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) Create another file survey.py in the same directory: from hemlock import Branch , Label , Page , route @route ( '/survey' ) def start (): return Branch ( Page ( Label ( '<p>Hello, World!</p>' ), terminal = True )) Run your app: $ python3 app.py And navigate to http://localhost:5000/ in your browser. Citation @software{bowen2020hemlock, author = {Dillon Bowen}, title = {Hemlock}, url = {https://dsbowen.github.io/hemlock/}, date = {2020-07-10}, } License Users must cite this package in any publications which use it. It is licensed with the Hemlock Research License . The license permits free use for academic research, and requires written permission from hemlock's author, Dillon Bowen, for commercial use.","title":"Home"},{"location":"#hemlock","text":"Hemlock aspires to be the most powerful and flexible way to create online studies, with applications in marketing and behavioral science research. If the installation and quickstart instructions don't make sense to you, check out the tutorial .","title":"Hemlock"},{"location":"#contact","text":"If you're a marketing, political advertising, or other for-profit company, see my contact page for details on hiring me as a consultant and purchasing a commercial license. If you're an academic or non-profit researcher interested in using hemlock, for a limited time I am offering to make studies for you free of charge . See my contact page for contact details and collaboration policy.","title":"Contact"},{"location":"#why-hemlock","text":"If you're an academic researcher interested in using hemlock, but aren't sure if it's worth your time to learn it, read this .","title":"Why hemlock?"},{"location":"#installation","text":"$ pip install hemlock-survey","title":"Installation"},{"location":"#quickstart","text":"First, create a file app.py in the root directory of your project: import survey from hemlock import create_app app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) Create another file survey.py in the same directory: from hemlock import Branch , Label , Page , route @route ( '/survey' ) def start (): return Branch ( Page ( Label ( '<p>Hello, World!</p>' ), terminal = True )) Run your app: $ python3 app.py And navigate to http://localhost:5000/ in your browser.","title":"Quickstart"},{"location":"#citation","text":"@software{bowen2020hemlock, author = {Dillon Bowen}, title = {Hemlock}, url = {https://dsbowen.github.io/hemlock/}, date = {2020-07-10}, }","title":"Citation"},{"location":"#license","text":"Users must cite this package in any publications which use it. It is licensed with the Hemlock Research License . The license permits free use for academic research, and requires written permission from hemlock's author, Dillon Bowen, for commercial use.","title":"License"},{"location":"acknowledgements/","text":"Acknowledgements I would like to thank my friends, family, and mentors for supporting me throughout hemlock's development, with special thanks to the following individuals: Sarah Reed, who has contributed more to hemlock than anyone else. Her contributions include referring me to resources and APIs, discussing countless design decisions, testing the API, and being a constant source of support and encouragement. Luke Sabor, for being the first to complete the hemlock tutorial and giving me invaluable feedback along the way. Raman Thadani, for being the second to complete the hemlock tutorial and giving me invaluable feedback along the way, and for drafting the Mac setup instructions. I created hemlock as a free tool for academic and non-profit researchers. I'm grateful that Sarah, Luke, and Raman share this spirit, assisting in their spare time, compensated only by my gratitude.","title":"Acknowledgements"},{"location":"acknowledgements/#acknowledgements","text":"I would like to thank my friends, family, and mentors for supporting me throughout hemlock's development, with special thanks to the following individuals: Sarah Reed, who has contributed more to hemlock than anyone else. Her contributions include referring me to resources and APIs, discussing countless design decisions, testing the API, and being a constant source of support and encouragement. Luke Sabor, for being the first to complete the hemlock tutorial and giving me invaluable feedback along the way. Raman Thadani, for being the second to complete the hemlock tutorial and giving me invaluable feedback along the way, and for drafting the Mac setup instructions. I created hemlock as a free tool for academic and non-profit researchers. I'm grateful that Sarah, Luke, and Raman share this spirit, assisting in their spare time, compensated only by my gratitude.","title":"Acknowledgements"},{"location":"app/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Application factory and settings hemlock.app. push_app_context def hemlock.app. push_app_context ( ) [source] Push an app context for debugging in shell or notebook. Returns: app : flask.app.Flask Examples from hemlock import push_app_context app = push_app_context () Out: <Flask 'hemlock.app'> hemlock.app. create_app def hemlock.app. create_app ( settings=settings ) [source] Create a Hemlock application. Parameters: settings : dict Default settings for the application, extensions, and models. Returns: app : flask.app.Flask Examples In this example, we add a back button to every page in our survey. from hemlock import Page , create_app , settings settings [ 'Page' ] . update ({ 'back' : True }) app = create_app () app . app_context () . push () Page () . preview () Default application settings Below are the default settings for Hemlock applications and extensions. App settings: clean_data : callable or None, default=None Callable which cleans your data before downloading or creating a data profile. This callable takes and returns pandas.DataFrame . If None , no additional cleaning is performend. collect_IP : bool, default=True Indicates that participants' IP addresses will be associated with their data. duplicate_keys : list, default=[] List of keys (column names) on which to block duplicate participants. If empty, the app will not screen out duplicates. restart_option : bool, default=True Indicates that participants who attempt to re-navigate to the index page will be given the option to restart the survey. If False , participants to attempt to re-navigate to the index page will be redirected to their current survey page. restart_text : str, default='Click << to return...' Text displayed to participants when given the option to restart or continue with the survey. screenout_csv : str, default='screenout.csv' Name of the csv file containing criteria for screening out participants. screenout_keys : list, default=[] List of keys (column names) on which to screen out participants. If empty, participants will be screened out based on all keys in the screenout csv. screenout_text : str, default='...you have already participated...' Text displayed to participants who are ineligible to participate in this survey. socket_js_src : Source of the websocket javascript. static_folder : str, default='static' Path to the static folder. template_folder : str, default='templates' Path to the template folder. time_expired_text : str, default='You have exceeded your time limit...' Text displayed to participants whose time has expired. time_limit : datetime.timedelta or None, default=None Time limit for participants to complete the survey. validate : bool, default=True Indicate that all validation is active. Set to False to turn off all validation for testing. Config: PASSWORD : str Looks for a PASSWORD environment variable. PASSWORD_HASH : str Generated password hash. SECRET_KEY : str Looks for a SECRET_KEY environment variable. SQLALCHEMY_DATABASE_URI : str Looks for DATABASE_URL environment variable. Otherwise, we use a SQLite database data.db in the current working directory. SQLALCHEMY_TRACK_MODIFICATIONS : bool, default=False REDIS_URL : str, default=None Looks for a REDIS_URL environment variable. DownloadBtnManager: Manager: loading_img_blueprint : str or None, default='hemlock' Name of the blueprint to which the loading image belongs. If None , the loading image is assumed to be in the app's static directory. loading_img_filename : str or None, default='img/worker_loading.gif' Name of the loading image file. Talisman: content_security_policy : dict Content security policy for flask-talisman . Default allows for third party content from Bootstrap, Cloudflare, Google API, JQuery, JSDeliver, SocketIO, and YouTube. Notes See https://flask.palletsprojects.com/en/1.1.x/config/ for more detail on Flask application configuration. See https://dsbowen.github.io/flask-download-btn/manager/ for more detail on DownloadBtnManager settings. See https://dsbowen.github.io/flask-worker/manager/ for more detail on Manager settings.","title":"Setting and initialization"},{"location":"app/#application-factory-and-settings","text":"","title":"Application factory and settings"},{"location":"app/#hemlockapppush_app_context","text":"def hemlock.app. push_app_context ( ) [source] Push an app context for debugging in shell or notebook. Returns: app : flask.app.Flask","title":"hemlock.app.push_app_context"},{"location":"app/#examples","text":"from hemlock import push_app_context app = push_app_context () Out: <Flask 'hemlock.app'>","title":"Examples"},{"location":"app/#hemlockappcreate_app","text":"def hemlock.app. create_app ( settings=settings ) [source] Create a Hemlock application. Parameters: settings : dict Default settings for the application, extensions, and models. Returns: app : flask.app.Flask","title":"hemlock.app.create_app"},{"location":"app/#examples_1","text":"In this example, we add a back button to every page in our survey. from hemlock import Page , create_app , settings settings [ 'Page' ] . update ({ 'back' : True }) app = create_app () app . app_context () . push () Page () . preview ()","title":"Examples"},{"location":"app/#default-application-settings","text":"Below are the default settings for Hemlock applications and extensions. App settings: clean_data : callable or None, default=None Callable which cleans your data before downloading or creating a data profile. This callable takes and returns pandas.DataFrame . If None , no additional cleaning is performend. collect_IP : bool, default=True Indicates that participants' IP addresses will be associated with their data. duplicate_keys : list, default=[] List of keys (column names) on which to block duplicate participants. If empty, the app will not screen out duplicates. restart_option : bool, default=True Indicates that participants who attempt to re-navigate to the index page will be given the option to restart the survey. If False , participants to attempt to re-navigate to the index page will be redirected to their current survey page. restart_text : str, default='Click << to return...' Text displayed to participants when given the option to restart or continue with the survey. screenout_csv : str, default='screenout.csv' Name of the csv file containing criteria for screening out participants. screenout_keys : list, default=[] List of keys (column names) on which to screen out participants. If empty, participants will be screened out based on all keys in the screenout csv. screenout_text : str, default='...you have already participated...' Text displayed to participants who are ineligible to participate in this survey. socket_js_src : Source of the websocket javascript. static_folder : str, default='static' Path to the static folder. template_folder : str, default='templates' Path to the template folder. time_expired_text : str, default='You have exceeded your time limit...' Text displayed to participants whose time has expired. time_limit : datetime.timedelta or None, default=None Time limit for participants to complete the survey. validate : bool, default=True Indicate that all validation is active. Set to False to turn off all validation for testing. Config: PASSWORD : str Looks for a PASSWORD environment variable. PASSWORD_HASH : str Generated password hash. SECRET_KEY : str Looks for a SECRET_KEY environment variable. SQLALCHEMY_DATABASE_URI : str Looks for DATABASE_URL environment variable. Otherwise, we use a SQLite database data.db in the current working directory. SQLALCHEMY_TRACK_MODIFICATIONS : bool, default=False REDIS_URL : str, default=None Looks for a REDIS_URL environment variable. DownloadBtnManager: Manager: loading_img_blueprint : str or None, default='hemlock' Name of the blueprint to which the loading image belongs. If None , the loading image is assumed to be in the app's static directory. loading_img_filename : str or None, default='img/worker_loading.gif' Name of the loading image file. Talisman: content_security_policy : dict Content security policy for flask-talisman . Default allows for third party content from Bootstrap, Cloudflare, Google API, JQuery, JSDeliver, SocketIO, and YouTube.","title":"Default application settings"},{"location":"app/#notes","text":"See https://flask.palletsprojects.com/en/1.1.x/config/ for more detail on Flask application configuration. See https://dsbowen.github.io/flask-download-btn/manager/ for more detail on DownloadBtnManager settings. See https://dsbowen.github.io/flask-worker/manager/ for more detail on Manager settings.","title":"Notes"},{"location":"bases/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Common bases and mixins hemlock. Base class hemlock. Base ( **kwargs ) [source] Base for all Hemlock models. Interits from sqlalchemy_function.FunctionRelator , sqlalchemy_orderingitem.Orderingitem and sqlalchemy_modelid.ModelIdBase . Parameters: **kwargs : You can set any attribute by passing it as a keyword argument. Attributes: name : str or None, default=None Used primarily as a filter for database querying. hemlock. Data Polymorphic base for all objects which contribute data to the dataframe. Data elements 'pack' their data and return it to their participant, who in turn sends it to the data store. Attributes: data : sqlalchemy_mutable.MutableType, default=None Data this element contributes to the dataframe. data_rows : int, default=1 Number of rows this data element contributes to the dataframe for its participant. If negative, this data element will 'fill in' any emtpy rows at the end of the dataframe with its most recent value. index : int or None, default=None Order in which this data element appears in its parent; usually a hemlock.Branch , hemlock.Page , or hemlock.Question . var : str or None, default=None Variable name associated with this data element. If None , the data will not be recorded. record_order : bool, default=False Indicates that the order of this data element should be recorded in the datafame. The order is the order in which this element appeared relative to other elements with the same variable name. record_index : bool, default=False Indicates that the index of this data element should be recorded in the dataframe. The index is the order in which this element appeared relative to other elements with the same parent. For example, the index of a question is the order in which the question appeared on its page. record_choice_index : bool, default=False Indicates that the index of this data element's choices should be recorded in the dataframe. For example, a hemlock.Check question has multiple choices that the participant can select. The index of a choice is its index in the question's choice list. hemlock. HTMLMixin class hemlock. HTMLMixin ( template=None, extra_css='', extra_js='', **kwargs ) [source] Mixin for models which contribute html to a page. Parameters: template : str, default depends on object Jinja template which is rendered to produce self.body . extra_css : str or bs4.BeautifulSoup or list, default='' Extra stylesheets to append to the default css. extra_js : str or bs4.BeautifulSoup or list, default='' Extra scripts to append to the default javascript. Attributes: attrs : dict Most objects subclassing the HTMLMixin have a dictionary or html attributes for the main html tag of the body . For example, the Input object's main tag is an <input> tag with attributes such as type , min , and max . body : sqlalchemy_mutablesoup.MutableSoupType The main html of the object. css : sqlalchemy_mutablesoup.MutableSoupType, default='' CSS the object contributes to the page. js : sqlalchemy_mutablesoup.MutableSoupType, default='' Javascript the object contributes to the page. Notes HTMLMixin also allows you to set attributes of the main html tag as if setting an attribute of the HTMLMixin object. For example, you can set the type of the <input> tag of an hemlock.Input question with: from hemlock import Input , push_app_context app = push_app_context () inpt = Input ( type = 'number' ) inpt . body Out: ... <input class=\"form-control\" id=\"input-1\" name=\"input-1\" type=\"number\"/> ... Valid html attributes will vary depending on the object. Methods add_external_css ( self, **attrs ) [source] Parameters: **attrs : Attribute names and values in the <link/> tag. Returns: self : hemlock.HTMLMiixn Notes See (statics.md#hemlocktoolsexternal_css). add_internal_css ( self, style ) [source] Parameters: style : dict Maps css selector to an attributes dictionary. The attributes dictionary maps attribute names to values. Returns: self : hemlock.HTMLMixin Notes See (statics.md#hemlocktoolsinternal_css). add_external_js ( self, **attrs ) [source] Parameters: **attrs : Attribute names and values in the <script> tag. Returns: self : hemlock.HTMLMixin Notes See (statics.md#hemlocktoolsexternal_js). add_internal_js ( self, js ) [source] Parameters: js : str Javascript code. Returns: self : hemlock.HTMLMixin Notes See (statics.md#hemlocktoolsinternal_js). update_attrs ( self, **kwargs ) [source] Update html tag attributes. Parameters: **kwargs : Keyword arguments map attribute names to values. hemlock. InputBase Base for models which contain <input> tags. Attributes: attrs : dict Input tag html attributes. input : bs4.Tag or None Input tag associated with this model. Methods input_from_driver ( self, driver=None ) [source] Parameters: driver : selenium.webdriver.chrome.webdriver.Webdriver Driver which will be used to select the input. Does not need to be Chrome. Returns: input : selenium.webdriver.remote.webelement.WebElement Web element of the <input> tag associated with this model. label_from_driver ( self, driver ) [source] Parameters: driver : selenium.webdriver.chrome.webdriver.Webdriver Driver which will be used to select the label. Does not need to be Chrome. Returns: label : selenium.webdriver.remote.webelement.WebElement Web element of the label tag associated with this model.","title":"Bases"},{"location":"bases/#common-bases-and-mixins","text":"","title":"Common bases and mixins"},{"location":"bases/#hemlockbase","text":"class hemlock. Base ( **kwargs ) [source] Base for all Hemlock models. Interits from sqlalchemy_function.FunctionRelator , sqlalchemy_orderingitem.Orderingitem and sqlalchemy_modelid.ModelIdBase . Parameters: **kwargs : You can set any attribute by passing it as a keyword argument. Attributes: name : str or None, default=None Used primarily as a filter for database querying.","title":"hemlock.Base"},{"location":"bases/#hemlockdata","text":"Polymorphic base for all objects which contribute data to the dataframe. Data elements 'pack' their data and return it to their participant, who in turn sends it to the data store. Attributes: data : sqlalchemy_mutable.MutableType, default=None Data this element contributes to the dataframe. data_rows : int, default=1 Number of rows this data element contributes to the dataframe for its participant. If negative, this data element will 'fill in' any emtpy rows at the end of the dataframe with its most recent value. index : int or None, default=None Order in which this data element appears in its parent; usually a hemlock.Branch , hemlock.Page , or hemlock.Question . var : str or None, default=None Variable name associated with this data element. If None , the data will not be recorded. record_order : bool, default=False Indicates that the order of this data element should be recorded in the datafame. The order is the order in which this element appeared relative to other elements with the same variable name. record_index : bool, default=False Indicates that the index of this data element should be recorded in the dataframe. The index is the order in which this element appeared relative to other elements with the same parent. For example, the index of a question is the order in which the question appeared on its page. record_choice_index : bool, default=False Indicates that the index of this data element's choices should be recorded in the dataframe. For example, a hemlock.Check question has multiple choices that the participant can select. The index of a choice is its index in the question's choice list.","title":"hemlock.Data"},{"location":"bases/#hemlockhtmlmixin","text":"class hemlock. HTMLMixin ( template=None, extra_css='', extra_js='', **kwargs ) [source] Mixin for models which contribute html to a page. Parameters: template : str, default depends on object Jinja template which is rendered to produce self.body . extra_css : str or bs4.BeautifulSoup or list, default='' Extra stylesheets to append to the default css. extra_js : str or bs4.BeautifulSoup or list, default='' Extra scripts to append to the default javascript. Attributes: attrs : dict Most objects subclassing the HTMLMixin have a dictionary or html attributes for the main html tag of the body . For example, the Input object's main tag is an <input> tag with attributes such as type , min , and max . body : sqlalchemy_mutablesoup.MutableSoupType The main html of the object. css : sqlalchemy_mutablesoup.MutableSoupType, default='' CSS the object contributes to the page. js : sqlalchemy_mutablesoup.MutableSoupType, default='' Javascript the object contributes to the page.","title":"hemlock.HTMLMixin"},{"location":"bases/#notes","text":"HTMLMixin also allows you to set attributes of the main html tag as if setting an attribute of the HTMLMixin object. For example, you can set the type of the <input> tag of an hemlock.Input question with: from hemlock import Input , push_app_context app = push_app_context () inpt = Input ( type = 'number' ) inpt . body Out: ... <input class=\"form-control\" id=\"input-1\" name=\"input-1\" type=\"number\"/> ... Valid html attributes will vary depending on the object.","title":"Notes"},{"location":"bases/#methods","text":"add_external_css ( self, **attrs ) [source] Parameters: **attrs : Attribute names and values in the <link/> tag. Returns: self : hemlock.HTMLMiixn","title":"Methods"},{"location":"bases/#notes_1","text":"See (statics.md#hemlocktoolsexternal_css). add_internal_css ( self, style ) [source] Parameters: style : dict Maps css selector to an attributes dictionary. The attributes dictionary maps attribute names to values. Returns: self : hemlock.HTMLMixin","title":"Notes"},{"location":"bases/#notes_2","text":"See (statics.md#hemlocktoolsinternal_css). add_external_js ( self, **attrs ) [source] Parameters: **attrs : Attribute names and values in the <script> tag. Returns: self : hemlock.HTMLMixin","title":"Notes"},{"location":"bases/#notes_3","text":"See (statics.md#hemlocktoolsexternal_js). add_internal_js ( self, js ) [source] Parameters: js : str Javascript code. Returns: self : hemlock.HTMLMixin","title":"Notes"},{"location":"bases/#notes_4","text":"See (statics.md#hemlocktoolsinternal_js). update_attrs ( self, **kwargs ) [source] Update html tag attributes. Parameters: **kwargs : Keyword arguments map attribute names to values.","title":"Notes"},{"location":"bases/#hemlockinputbase","text":"Base for models which contain <input> tags. Attributes: attrs : dict Input tag html attributes. input : bs4.Tag or None Input tag associated with this model.","title":"hemlock.InputBase"},{"location":"bases/#methods_1","text":"input_from_driver ( self, driver=None ) [source] Parameters: driver : selenium.webdriver.chrome.webdriver.Webdriver Driver which will be used to select the input. Does not need to be Chrome. Returns: input : selenium.webdriver.remote.webelement.WebElement Web element of the <input> tag associated with this model. label_from_driver ( self, driver ) [source] Parameters: driver : selenium.webdriver.chrome.webdriver.Webdriver Driver which will be used to select the label. Does not need to be Chrome. Returns: label : selenium.webdriver.remote.webelement.WebElement Web element of the label tag associated with this model.","title":"Methods"},{"location":"branch/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Branch hemlock. Branch class hemlock. Branch ( *pages, **kwargs ) [source] Branches are stacked in a participant's branch stack. A branch contains a queue of pages which it displays to its participant. Inherits from hemlock.models.Base . Parameters: *pages : hemlock.Page Pages which belong to this branch. Attributes: index : int or None, default=None Order in which this branch appears in its participant's branch stack. Relationships: part : hemlock.Participant Participant to whose branch stack this page belongs. origin_branch : hemlock.Branch The branch from which this branch originated. next_branch : hemlock.Branch The branch which originated from this branch. origin_page : hemlock.Page The page from which this branch originated. Note that branches can originate from other branches or pages. pages : list of hemlock.Page The queue of pages belonging to this branch. start_page : hemlock.Page or None The first page in the page queue, if non-empty. current_page : hemlock.Page Current page of this branch (head of the page queue). embedded : list of hemlock.Embedded Embedded data elements. data_elements : list of hemlock.DataElement All data elements belonging to this branch, in order of embedded data then page data. navigate : hemlock.Navigate Navigate function which returns a new branch once the participant has reached the end of this branch (i.e. the end of the page queue associated with this branch). navigate_worker : hemlock.Worker Worker which handles complex navigate functions. Examples from hemlock import Branch , Label , Page , push_app_context app = push_app_context () Branch ( Page ( Label ( '<p>Hello World</p>' )), Page ( Label ( '<p>Hello Moon</p>' )), Page ( Label ( '<p>Hello Star</p>' )) ) . preview () This will open all of the branch's pages in separate tabs. Methods preview ( self, driver=None ) [source] Preview the page queue in the a browser window. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver or None, default=None Driver to preview page debugging. If None , the page will be opened in a web browser. Returns: self : helock.Branch view_nav ( self ) [source] Print this branch's page queue for debugging purposes. Returns: self : hemlock.Branch","title":"Branch"},{"location":"branch/#branch","text":"","title":"Branch"},{"location":"branch/#hemlockbranch","text":"class hemlock. Branch ( *pages, **kwargs ) [source] Branches are stacked in a participant's branch stack. A branch contains a queue of pages which it displays to its participant. Inherits from hemlock.models.Base . Parameters: *pages : hemlock.Page Pages which belong to this branch. Attributes: index : int or None, default=None Order in which this branch appears in its participant's branch stack. Relationships: part : hemlock.Participant Participant to whose branch stack this page belongs. origin_branch : hemlock.Branch The branch from which this branch originated. next_branch : hemlock.Branch The branch which originated from this branch. origin_page : hemlock.Page The page from which this branch originated. Note that branches can originate from other branches or pages. pages : list of hemlock.Page The queue of pages belonging to this branch. start_page : hemlock.Page or None The first page in the page queue, if non-empty. current_page : hemlock.Page Current page of this branch (head of the page queue). embedded : list of hemlock.Embedded Embedded data elements. data_elements : list of hemlock.DataElement All data elements belonging to this branch, in order of embedded data then page data. navigate : hemlock.Navigate Navigate function which returns a new branch once the participant has reached the end of this branch (i.e. the end of the page queue associated with this branch). navigate_worker : hemlock.Worker Worker which handles complex navigate functions.","title":"hemlock.Branch"},{"location":"branch/#examples","text":"from hemlock import Branch , Label , Page , push_app_context app = push_app_context () Branch ( Page ( Label ( '<p>Hello World</p>' )), Page ( Label ( '<p>Hello Moon</p>' )), Page ( Label ( '<p>Hello Star</p>' )) ) . preview () This will open all of the branch's pages in separate tabs.","title":"Examples"},{"location":"branch/#methods","text":"preview ( self, driver=None ) [source] Preview the page queue in the a browser window. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver or None, default=None Driver to preview page debugging. If None , the page will be opened in a web browser. Returns: self : helock.Branch view_nav ( self ) [source] Print this branch's page queue for debugging purposes. Returns: self : hemlock.Branch","title":"Methods"},{"location":"changelog/","text":"Changelog 0.0.22 added support for embedded dash apps CLI 0.0.17 added setup-venv command for easier virtual environment setup on Windows git bash 0.0.20 fixed Submit.match and Validate.match bug: now requires full match instead of partial match improved number inputs and added step attribute","title":"Changelog"},{"location":"changelog/#changelog","text":"","title":"Changelog"},{"location":"changelog/#0022","text":"added support for embedded dash apps","title":"0.0.22"},{"location":"changelog/#cli-0017","text":"added setup-venv command for easier virtual environment setup on Windows git bash","title":"CLI 0.0.17"},{"location":"changelog/#0020","text":"fixed Submit.match and Validate.match bug: now requires full match instead of partial match improved number inputs and added step attribute","title":"0.0.20"},{"location":"check/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Check hemlock.qpolymorphs.check. CheckBase Base for hemlock.Binary and hemlock.Check question types. Inherits from hemlock.ChoiceQuestion . Attributes: align : str, default='left' Alignment of the choice text. Value can be 'left' , 'center' , or 'right' . inline : bool, default=False Indicates that choices should be inline , as opposed to vertical. hemlock. Check class hemlock. Check ( label='', choices=[], template='hemlock/check.html', ** kwargs ) [source] Check questions use radio inputs if only one choice can be selected, or checkbox inputs if multiple choices can be selected. Inherits from hemlock.qpolymorphs.check.CheckBase . Its default debug function is click_choices . Parameters: label : str or bs4.BeautifulSoup, default='' Check question label. choices : list of hemlock.Choice, str, tuple, or dict, default=[] Choices which participants can check. template : str, default='hemlock/check.html' Template for the check body. Attributes: choices : list of hemlock.Choice Set from the choices parameter. inline : default=False multiple : bool, default=False Indicates that the participant may select multiple choices. Examples from hemlock import Check , Page , push_app_context app = push_app_context () Page ( Check ( '<p>Check one.</p>' , [ 'Yes' , 'No' , 'Maybe' ])) . preview () hemlock. Binary class hemlock. Binary ( label='', choices=['Yes', 'No'], template= 'hemlock/check.html', **kwargs ) [source] Binary question use radio inputs and have two options, coded as 0 and 1. Inherits from hemlock.qpolymorphs.check.CheckBase . Its default debug function is click_choices . Parameters: label : str or bs4.BeautifulSoup, default='' Check question label. choices : list of [str, str], default=['Yes', 'No'] Choices which participants can check. The first choice is coded as 1, the second as 0. template : str, default='hemlock/check.html' Template for the check body. Attributes: choices : list of hemlock.Choice Set from the choices parameter. inline : bool, default=True multiple : bool, default=False Indicates that the participant may select multiple choices. Examples from hemlock import Binary , Page , push_app_context app = push_app_context () Page ( Binary ( '<p>Yes or no?</p>' )) . preview ()","title":"Check"},{"location":"check/#check","text":"","title":"Check"},{"location":"check/#hemlockqpolymorphscheckcheckbase","text":"Base for hemlock.Binary and hemlock.Check question types. Inherits from hemlock.ChoiceQuestion . Attributes: align : str, default='left' Alignment of the choice text. Value can be 'left' , 'center' , or 'right' . inline : bool, default=False Indicates that choices should be inline , as opposed to vertical.","title":"hemlock.qpolymorphs.check.CheckBase"},{"location":"check/#hemlockcheck","text":"class hemlock. Check ( label='', choices=[], template='hemlock/check.html', ** kwargs ) [source] Check questions use radio inputs if only one choice can be selected, or checkbox inputs if multiple choices can be selected. Inherits from hemlock.qpolymorphs.check.CheckBase . Its default debug function is click_choices . Parameters: label : str or bs4.BeautifulSoup, default='' Check question label. choices : list of hemlock.Choice, str, tuple, or dict, default=[] Choices which participants can check. template : str, default='hemlock/check.html' Template for the check body. Attributes: choices : list of hemlock.Choice Set from the choices parameter. inline : default=False multiple : bool, default=False Indicates that the participant may select multiple choices.","title":"hemlock.Check"},{"location":"check/#examples","text":"from hemlock import Check , Page , push_app_context app = push_app_context () Page ( Check ( '<p>Check one.</p>' , [ 'Yes' , 'No' , 'Maybe' ])) . preview ()","title":"Examples"},{"location":"check/#hemlockbinary","text":"class hemlock. Binary ( label='', choices=['Yes', 'No'], template= 'hemlock/check.html', **kwargs ) [source] Binary question use radio inputs and have two options, coded as 0 and 1. Inherits from hemlock.qpolymorphs.check.CheckBase . Its default debug function is click_choices . Parameters: label : str or bs4.BeautifulSoup, default='' Check question label. choices : list of [str, str], default=['Yes', 'No'] Choices which participants can check. The first choice is coded as 1, the second as 0. template : str, default='hemlock/check.html' Template for the check body. Attributes: choices : list of hemlock.Choice Set from the choices parameter. inline : bool, default=True multiple : bool, default=False Indicates that the participant may select multiple choices.","title":"hemlock.Binary"},{"location":"check/#examples_1","text":"from hemlock import Binary , Page , push_app_context app = push_app_context () Page ( Binary ( '<p>Yes or no?</p>' )) . preview ()","title":"Examples"},{"location":"checklist/","text":"Checklist This is a checklist of the steps involved in initializing, editing, and deploying a hemlock project. This will make sense after you go through the tutorial . Initialize $ hlk init <my-project-name> <my-github-username> <my-github-token> $ cd <my-project-name> Additional steps for Windows git bash hlk setup-venv <my-project-name> Additional steps for WSL Open env.yaml and add the following line: WSL_DISTRIBUTION : Ubuntu-20.04 # or other WSL distribution Edit Iterate quickly on the blackboard: $ jupyter notebook # open blackboard.ipynb, Kernel >> Change kernel >> <my-project-name> Edit survey files: $ code survey.py Run locally: $ hlk serve Debug: $ hlk debug Deploy Deploy to and debug in staging: $ hlk deploy # make sure to set the PASSWORD and URL_ROOT environment variables $ heroku git:remote -a <my-app-name> $ hlk debug --staging Destroy the staging app: $ heroku apps:destroy Change app.json from: { \"addons\" : [ \"heroku-postgresql:hobby-dev\" ], \"formation\" : { \"web\" : { \"quantity\" : 1 , \"size\" : \"free\" } }, ... to: { \"addons\" : [ \"heroku-postgresql:standard-0\" ], \"formation\" : { \"web\" : { \"quantity\" : 10 , \"size\" : \"standard-1x\" } }, ... Deploy in production: hlk deploy # set PASSWORD, URL_ROOT, and DEBUG_FUNCTIONS","title":"Checklist"},{"location":"checklist/#checklist","text":"This is a checklist of the steps involved in initializing, editing, and deploying a hemlock project. This will make sense after you go through the tutorial .","title":"Checklist"},{"location":"checklist/#initialize","text":"$ hlk init <my-project-name> <my-github-username> <my-github-token> $ cd <my-project-name> Additional steps for Windows git bash hlk setup-venv <my-project-name> Additional steps for WSL Open env.yaml and add the following line: WSL_DISTRIBUTION : Ubuntu-20.04 # or other WSL distribution","title":"Initialize"},{"location":"checklist/#edit","text":"Iterate quickly on the blackboard: $ jupyter notebook # open blackboard.ipynb, Kernel >> Change kernel >> <my-project-name> Edit survey files: $ code survey.py Run locally: $ hlk serve Debug: $ hlk debug","title":"Edit"},{"location":"checklist/#deploy","text":"Deploy to and debug in staging: $ hlk deploy # make sure to set the PASSWORD and URL_ROOT environment variables $ heroku git:remote -a <my-app-name> $ hlk debug --staging Destroy the staging app: $ heroku apps:destroy Change app.json from: { \"addons\" : [ \"heroku-postgresql:hobby-dev\" ], \"formation\" : { \"web\" : { \"quantity\" : 1 , \"size\" : \"free\" } }, ... to: { \"addons\" : [ \"heroku-postgresql:standard-0\" ], \"formation\" : { \"web\" : { \"quantity\" : 10 , \"size\" : \"standard-1x\" } }, ... Deploy in production: hlk deploy # set PASSWORD, URL_ROOT, and DEBUG_FUNCTIONS","title":"Deploy"},{"location":"choice/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Choices and Options The difference between hemlock.Choice and hemlock.Option is the former are for hemlock.Check questions, while latter are for hemlock.Select questions. The use of choice and option models is not due to any deep functional difference between them, but reflects the underlying html. hemlock. ChoiceBase class hemlock. ChoiceBase ( label, template, **kwargs ) [source] Base class for choices. Parameters: label : str or bs4.BeautifulSoup, default='' Choice label. template : str Jinja template for the choice html. The choice object is passed to the template as a parameter named self_ . value : default=None Value of the choice if selected. e.g. a choice with label 'Yes' might have a value of 1 . If None , the label is used. For a question where only one choice can be selected, this is the value of the question's data if this choice is selected. For a question where multiple choices may be selected, data are one-hot encoded; the value is the suffix of the column name associated with the indicator variable that this choice was selected. name : default=None Name associated with this choice in the dataframe. If None , the label is used. Attributes: id : str Randomly generated from ascii letters and digits. body : bs4.BeautifulSoup Choice html created from the template parameter. label : str or bs4.BeautifulSoup Set from the label parameter. value : Set from the value parameter. name : Set from the name parameter. Notes If passing value and name to contructor, these must be passed as keyword arguments Methods is_default ( self, question ) [source] Parameters: question : hemlock.Question The question to which this choice belongs. Returns: is_default : bool Indicate that this choice is (one of) its question's default choice(s). Notes The question's default choice(s) is the question's response if the participant responded to the question, or the question's default if the participant has not yet responded to the question. set_all ( self, val ) [source] Set the choice's label, name, and value. Parameters: val : Value to which the choice's label, name, and value should be set. Returns: self : hemlock.Choice hemlock. Choice class hemlock. Choice ( label='', template='hemlock/choice.html', **kwargs ) [source] Choices are displayed as part of their question (usually hemlock.Check ). Inherits from hemlock.ChoiceBase . Parameters: label : str or bs4.BeautifulSoup, default='' Choice label. template : str, default='hemlock/choice.html' Template for the choice body . **kwargs : Set the choice's value and name using keyword arguments. Methods click ( self, driver, if_selected=None ) [source] Use a selenium webdriver to click on this choice. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver The selenium webdriver that clicks this choice. Does not have to be chromedriver. if_selected : bool or None, default=None Indicates that the choice will be clicked only if it is already selected. If False the choice will be clicked only if it is not already selected. If None the choice will be clicked whether or not it is selected. Returns: self : is_displayed ( self, driver ) [source] Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver The selenium webdriver that clicks this choice. Does not have to be chromedriver. Returns: is_displayed : bool Indicates that this choice is visible in the browser. hemlock. Option class hemlock. Option ( label='', template='hemlock/option.html', **kwargs ) [source] Options are displayed as part of their question (usually hemlock.Select ). Inherits from hemlock.ChoiceBase . Its functionality is similar to hemlock.Choice , but for Select questions instead of Check questions. Parameters: label : str or bs4.BeautifulSoup, default='' Choice label. template : str, default='hemlock/option.html' Template for the choice body . **kwargs : Set the choice's value and name using keyword arguments. Methods click ( self, driver, if_selected=None ) [source] Use a selenium webdriver to click on this choice. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver The selenium webdriver that clicks this choice. Does not have to be chromedriver. if_selected : bool or None, default=None Indicates that the choice will be clicked only if it is already selected. If False the choice will be clicked only if it is not already selected. If None the choice will be clicked whether or not it is selected. Returns: self : is_displayed ( self, driver ) [source] Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver The selenium webdriver that clicks this choice. Does not have to be chromedriver. Returns: is_displayed : bool Indicates that this choice is visible in the browser.","title":"Choice"},{"location":"choice/#choices-and-options","text":"The difference between hemlock.Choice and hemlock.Option is the former are for hemlock.Check questions, while latter are for hemlock.Select questions. The use of choice and option models is not due to any deep functional difference between them, but reflects the underlying html.","title":"Choices and Options"},{"location":"choice/#hemlockchoicebase","text":"class hemlock. ChoiceBase ( label, template, **kwargs ) [source] Base class for choices. Parameters: label : str or bs4.BeautifulSoup, default='' Choice label. template : str Jinja template for the choice html. The choice object is passed to the template as a parameter named self_ . value : default=None Value of the choice if selected. e.g. a choice with label 'Yes' might have a value of 1 . If None , the label is used. For a question where only one choice can be selected, this is the value of the question's data if this choice is selected. For a question where multiple choices may be selected, data are one-hot encoded; the value is the suffix of the column name associated with the indicator variable that this choice was selected. name : default=None Name associated with this choice in the dataframe. If None , the label is used. Attributes: id : str Randomly generated from ascii letters and digits. body : bs4.BeautifulSoup Choice html created from the template parameter. label : str or bs4.BeautifulSoup Set from the label parameter. value : Set from the value parameter. name : Set from the name parameter.","title":"hemlock.ChoiceBase"},{"location":"choice/#notes","text":"If passing value and name to contructor, these must be passed as keyword arguments","title":"Notes"},{"location":"choice/#methods","text":"is_default ( self, question ) [source] Parameters: question : hemlock.Question The question to which this choice belongs. Returns: is_default : bool Indicate that this choice is (one of) its question's default choice(s).","title":"Methods"},{"location":"choice/#notes_1","text":"The question's default choice(s) is the question's response if the participant responded to the question, or the question's default if the participant has not yet responded to the question. set_all ( self, val ) [source] Set the choice's label, name, and value. Parameters: val : Value to which the choice's label, name, and value should be set. Returns: self : hemlock.Choice","title":"Notes"},{"location":"choice/#hemlockchoice","text":"class hemlock. Choice ( label='', template='hemlock/choice.html', **kwargs ) [source] Choices are displayed as part of their question (usually hemlock.Check ). Inherits from hemlock.ChoiceBase . Parameters: label : str or bs4.BeautifulSoup, default='' Choice label. template : str, default='hemlock/choice.html' Template for the choice body . **kwargs : Set the choice's value and name using keyword arguments.","title":"hemlock.Choice"},{"location":"choice/#methods_1","text":"click ( self, driver, if_selected=None ) [source] Use a selenium webdriver to click on this choice. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver The selenium webdriver that clicks this choice. Does not have to be chromedriver. if_selected : bool or None, default=None Indicates that the choice will be clicked only if it is already selected. If False the choice will be clicked only if it is not already selected. If None the choice will be clicked whether or not it is selected. Returns: self : is_displayed ( self, driver ) [source] Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver The selenium webdriver that clicks this choice. Does not have to be chromedriver. Returns: is_displayed : bool Indicates that this choice is visible in the browser.","title":"Methods"},{"location":"choice/#hemlockoption","text":"class hemlock. Option ( label='', template='hemlock/option.html', **kwargs ) [source] Options are displayed as part of their question (usually hemlock.Select ). Inherits from hemlock.ChoiceBase . Its functionality is similar to hemlock.Choice , but for Select questions instead of Check questions. Parameters: label : str or bs4.BeautifulSoup, default='' Choice label. template : str, default='hemlock/option.html' Template for the choice body . **kwargs : Set the choice's value and name using keyword arguments.","title":"hemlock.Option"},{"location":"choice/#methods_2","text":"click ( self, driver, if_selected=None ) [source] Use a selenium webdriver to click on this choice. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver The selenium webdriver that clicks this choice. Does not have to be chromedriver. if_selected : bool or None, default=None Indicates that the choice will be clicked only if it is already selected. If False the choice will be clicked only if it is not already selected. If None the choice will be clicked whether or not it is selected. Returns: self : is_displayed ( self, driver ) [source] Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver The selenium webdriver that clicks this choice. Does not have to be chromedriver. Returns: is_displayed : bool Indicates that this choice is visible in the browser.","title":"Methods"},{"location":"compile_functions/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Compile functions hemlock.functions.compile. call_method def hemlock.functions.compile. call_method ( obj, method_name, *args, **kwargs ) [source] Calls one of the object's methods. Parameters: obj : Object whose methods will be called. method_name : str Names of the method to call. *args, **kwargs : Arguments and keyword arguments to pass to the method. Examples from hemlock import Compile as C , Page , push_app_context app = push_app_context () p = Page ( error = 'Error message' , compile = C . call_method ( 'clear_error' )) p . preview () . _compile () . preview () hemlock.functions.compile. clear_error def hemlock.functions.compile. clear_error ( obj ) [source] Calls the object's clear_error method. Parameters: obj : Object whose clear_error method will be called. Examples from hemlock import Compile as C , Page , push_app_context app = push_app_context () p = Page ( error = 'Error message' , compile = C . clear_error ()) p . preview () . _compile () . preview () hemlock.functions.compile. clear_response def hemlock.functions.compile. clear_response ( obj ) [source] Calls the object's clear_response method. Parameters: obj : Object whose clear_response method will be called. Examples from hemlock import Compile as C , Input , Page , push_app_context app = push_app_context () p = Page ( Input ( response = 'Hello World' ), compile = C . clear_response ()) p . preview () . _compile () . preview () hemlock.functions.compile. shuffle def hemlock.functions.compile. shuffle ( obj, *attrs ) [source] Shuffle an object's attributes. Parameters: obj : Objects whose attributes should be shuffled. *attrs : str Names of attributes to shuffle. Notes If the object is a hemlock.Page , the default shuffled attribute is its questions . If the object is a hemlock.ChoiceQuestion , the default shuffled attribute is its choices . Examples from hemlock import Compile as C , Label , Page , push_app_context app = push_app_context () p = Page ( * ( Label ( '<p>Label {} </p>' . format ( i )) for i in range ( 4 )), compile = C . shuffle () ) p . preview () . _compile () . preview ()","title":"Compile"},{"location":"compile_functions/#compile-functions","text":"","title":"Compile functions"},{"location":"compile_functions/#hemlockfunctionscompilecall_method","text":"def hemlock.functions.compile. call_method ( obj, method_name, *args, **kwargs ) [source] Calls one of the object's methods. Parameters: obj : Object whose methods will be called. method_name : str Names of the method to call. *args, **kwargs : Arguments and keyword arguments to pass to the method.","title":"hemlock.functions.compile.call_method"},{"location":"compile_functions/#examples","text":"from hemlock import Compile as C , Page , push_app_context app = push_app_context () p = Page ( error = 'Error message' , compile = C . call_method ( 'clear_error' )) p . preview () . _compile () . preview ()","title":"Examples"},{"location":"compile_functions/#hemlockfunctionscompileclear_error","text":"def hemlock.functions.compile. clear_error ( obj ) [source] Calls the object's clear_error method. Parameters: obj : Object whose clear_error method will be called.","title":"hemlock.functions.compile.clear_error"},{"location":"compile_functions/#examples_1","text":"from hemlock import Compile as C , Page , push_app_context app = push_app_context () p = Page ( error = 'Error message' , compile = C . clear_error ()) p . preview () . _compile () . preview ()","title":"Examples"},{"location":"compile_functions/#hemlockfunctionscompileclear_response","text":"def hemlock.functions.compile. clear_response ( obj ) [source] Calls the object's clear_response method. Parameters: obj : Object whose clear_response method will be called.","title":"hemlock.functions.compile.clear_response"},{"location":"compile_functions/#examples_2","text":"from hemlock import Compile as C , Input , Page , push_app_context app = push_app_context () p = Page ( Input ( response = 'Hello World' ), compile = C . clear_response ()) p . preview () . _compile () . preview ()","title":"Examples"},{"location":"compile_functions/#hemlockfunctionscompileshuffle","text":"def hemlock.functions.compile. shuffle ( obj, *attrs ) [source] Shuffle an object's attributes. Parameters: obj : Objects whose attributes should be shuffled. *attrs : str Names of attributes to shuffle.","title":"hemlock.functions.compile.shuffle"},{"location":"compile_functions/#notes","text":"If the object is a hemlock.Page , the default shuffled attribute is its questions . If the object is a hemlock.ChoiceQuestion , the default shuffled attribute is its choices .","title":"Notes"},{"location":"compile_functions/#examples_3","text":"from hemlock import Compile as C , Label , Page , push_app_context app = push_app_context () p = Page ( * ( Label ( '<p>Label {} </p>' . format ( i )) for i in range ( 4 )), compile = C . shuffle () ) p . preview () . _compile () . preview ()","title":"Examples"},{"location":"comprehension/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Comprehension check hemlock.tools. comprehension_check def hemlock.tools. comprehension_check ( instructions, checks, attempts=None ) [source] A comprehension check consists of 'instruction' pages followed by 'check' pages. The data of all questions in a check page must evaluate to True to pass the check. When a participant fails a check, he is brought back to the first instructions page. Participants only have to pass each check once. For example, suppose there are two checks, A and B. The participant passes check A but fails check B. He is brought back to the first page of the instructions. After rereading the instructions, he is brought directly to check B, skipping check A. Parameters: instructions : hemlock.Page or list of hemlock.Page Instruction page(s). checks : hemlock.Page or list of hemlock.Page Check page(s). attempts : int or None, default=None Number of attempts allotted. Participants are allowed to proceed with the survey after exceeding the maximum number of attempts. If None , participants must pass the comprehension check before continuing the survey. Returns: pages : list of hemlock.Page List of instructions pages + check pages. Notes This function adds a hemlock.Submit function to each check page. This must be the last submit function of each check page. Examples We have two files in our root directory. In survey.py : from hemlock import Branch , Page , Label , Input , Submit as S , route from hemlock.tools import comprehension_check @route ( '/survey' ) def start (): return Branch ( * comprehension_check ( instructions = Page ( Label ( '<p>Here are some instructions.</p>' ) ), checks = Page ( Input ( '<p>Enter \"hello world\" or you... shall not... PASS!</p>' , submit = S . match ( 'hello world' ) ) ) ), Page ( Label ( '<p>You passed the comprehension check!</p>' ), terminal = True ) ) In app.py : import survey from hemlock import create_app app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) Run the app with: $ python app.py # or python3 app.py Open your browser to http://localhost:5000/ .","title":"Comprehension check"},{"location":"comprehension/#comprehension-check","text":"","title":"Comprehension check"},{"location":"comprehension/#hemlocktoolscomprehension_check","text":"def hemlock.tools. comprehension_check ( instructions, checks, attempts=None ) [source] A comprehension check consists of 'instruction' pages followed by 'check' pages. The data of all questions in a check page must evaluate to True to pass the check. When a participant fails a check, he is brought back to the first instructions page. Participants only have to pass each check once. For example, suppose there are two checks, A and B. The participant passes check A but fails check B. He is brought back to the first page of the instructions. After rereading the instructions, he is brought directly to check B, skipping check A. Parameters: instructions : hemlock.Page or list of hemlock.Page Instruction page(s). checks : hemlock.Page or list of hemlock.Page Check page(s). attempts : int or None, default=None Number of attempts allotted. Participants are allowed to proceed with the survey after exceeding the maximum number of attempts. If None , participants must pass the comprehension check before continuing the survey. Returns: pages : list of hemlock.Page List of instructions pages + check pages.","title":"hemlock.tools.comprehension_check"},{"location":"comprehension/#notes","text":"This function adds a hemlock.Submit function to each check page. This must be the last submit function of each check page.","title":"Notes"},{"location":"comprehension/#examples","text":"We have two files in our root directory. In survey.py : from hemlock import Branch , Page , Label , Input , Submit as S , route from hemlock.tools import comprehension_check @route ( '/survey' ) def start (): return Branch ( * comprehension_check ( instructions = Page ( Label ( '<p>Here are some instructions.</p>' ) ), checks = Page ( Input ( '<p>Enter \"hello world\" or you... shall not... PASS!</p>' , submit = S . match ( 'hello world' ) ) ) ), Page ( Label ( '<p>You passed the comprehension check!</p>' ), terminal = True ) ) In app.py : import survey from hemlock import create_app app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) Run the app with: $ python app.py # or python3 app.py Open your browser to http://localhost:5000/ .","title":"Examples"},{"location":"contact/","text":"Contact For-profit and political research If you're a marketing, political advertising, or other for-profit company interested in using hemlock, email me (Dillon Bowen) at dsbowen@wharton.upenn.edu with the subject heading Hemlock for-profit . You may either: Hire me as a consultant to make surveys for you. Purchase a Hemlock Commercial License for developers at your company. Non-profit and academic research If you're an academic or non-profit researcher interested in using hemlock for your research, email me (Dillon Bowen) at dsbowen@wharton.upenn.edu with the subject heading Hemlock research . Collaboration policy I appreciate that you may be wary of investing the time required to learn hemlock upfront, so for a limited time I am offering to make studies for you using hemlock free of charge (subject to my time constraints as a PhD candidate). In return, I expect that you will: Cite hemlock in any publications which result from our collaboration. Mention hemlock in any talks related to our collaboration (e.g. \"we created our studies using hemlock; a python package for behavioral science research\"). Include a link to the hemlock documentation, https://dsbowen.github.io/hemlock/ , in any slide decks related to our collaboration. If you would like me to make multiple studies, or a single complex study which requires me to build new features or extensions, you should add me as a co-author. Feature requests and bugs If you would like to submit a feature request, report a bug, or have any other suggestions for improving hemlock, open an issue on github here .","title":"Contact"},{"location":"contact/#contact","text":"","title":"Contact"},{"location":"contact/#for-profit-and-political-research","text":"If you're a marketing, political advertising, or other for-profit company interested in using hemlock, email me (Dillon Bowen) at dsbowen@wharton.upenn.edu with the subject heading Hemlock for-profit . You may either: Hire me as a consultant to make surveys for you. Purchase a Hemlock Commercial License for developers at your company.","title":"For-profit and political research"},{"location":"contact/#non-profit-and-academic-research","text":"If you're an academic or non-profit researcher interested in using hemlock for your research, email me (Dillon Bowen) at dsbowen@wharton.upenn.edu with the subject heading Hemlock research .","title":"Non-profit and academic research"},{"location":"contact/#collaboration-policy","text":"I appreciate that you may be wary of investing the time required to learn hemlock upfront, so for a limited time I am offering to make studies for you using hemlock free of charge (subject to my time constraints as a PhD candidate). In return, I expect that you will: Cite hemlock in any publications which result from our collaboration. Mention hemlock in any talks related to our collaboration (e.g. \"we created our studies using hemlock; a python package for behavioral science research\"). Include a link to the hemlock documentation, https://dsbowen.github.io/hemlock/ , in any slide decks related to our collaboration. If you would like me to make multiple studies, or a single complex study which requires me to build new features or extensions, you should add me as a co-author.","title":"Collaboration policy"},{"location":"contact/#feature-requests-and-bugs","text":"If you would like to submit a feature request, report a bug, or have any other suggestions for improving hemlock, open an issue on github here .","title":"Feature requests and bugs"},{"location":"dashboard/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Dashboard hemlock. Dashboard class hemlock. Dashboard ( label='', template='hemlock/dash.html', **kwargs ) [source] Embeds a dash app . Parameters: label : str or bs4.BeautifulSoup, default='' Dashboard label. template : str, default='hemlock/dash.html' Template for the dashboard body. Attributes: aspect_ratio : tuple of (int, int), default=(16, 9) Aspect ratio of the embedded application. See https://getbootstrap.com/docs/4.0/utilities/embed/#aspect-ratios . embed : bs4.Tag <div> tag of the embedded app. g : dict Mutable dictionary with dashboard arguments. iframe : bs4.Tag <iframe> tag of the embedded app. src : str src attribute of the <iframe> tag. Examples In this example, we create a simple dash app in which participants click on a button. We embed this app in a hemlock survey, and record the number of times a participant clicked the button. Install dash with: $ hlk install dash Or: $ pip install dash In survey.py : from hemlock import Branch , Dashboard , Label , Page , route @route ( '/survey' ) def start (): return Branch ( Page ( Dashboard ( src = '/dashapp/' , var = 'n_clicks' ) ), Page ( Label ( '<p>The end.</p>' ), terminal = True ) ) In app.py : import survey import dash import dash_core_components as dcc import dash_html_components as html from dash.dependencies import Input , Output from hemlock import Dashboard , create_app app = create_app () dash_app = dash . Dash ( server = app , routes_pathname_prefix = '/dashapp/' , external_stylesheets = [ 'https://codepen.io/chriddyp/pen/bWLwgP.css' ] ) dash_app . layout = html . Div ([ dcc . Location ( id = 'url' ), html . Button ( 'Click me!' , id = 'button' ), html . P ( id = 'click-tracker' ), ]) @dash_app . callback ( Output ( 'click-tracker' , 'children' ), [ Input ( 'url' , 'search' ), Input ( 'button' , 'n_clicks' )] ) def update_clicks ( search , n_clicks ): n_clicks = n_clicks or 0 Dashboard . record_response ( search , n_clicks ) return ' {} clicks' . format ( n_clicks ) if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) Run the app with: $ hlk serve Or: $ python app.py Then open your browser and navigate to http://localhost:5000/ . Methods get ( search ) [source] Utility for retrieving a dashboard question in a dash callback. Parameters: search : str, formatted as URL query string Must have 'id' and 'key' parameters. Returns: dashboard : hemlock_dash.Dashboard Dashboard specified by the id in the search string. Examples ... import dash_core_components as dcc from hemlock import Dashboard app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), ... ]) @app . callback ( Output ( ... ), [ Input ( 'url' , 'search' ), ... ] ) def my_callback ( search , ... ): dashboard = Dashboard . get ( search ) record_response ( search, response ) [source] Utility for writing the response attribute of the dashboard question. Parameters: search : str, formatted as URL query string Must have 'id' and 'key' parameters. response : Value to which to set the dash question's repsonse attribute. Returns: dashboard : hemlock_dash.Dashboard Dashboard specified by the id in the search string. Examples ```python ... import dash_core_components as dcc from hemlock import Dashboard app.layout = html.Div([ dcc.Location(id='url', refresh=False), ... ]) @app.callback( Output(...), [Input('url', 'search'), ...] ) def my_callback(search, ...): Dashboard.record_response(search, 'hello world')","title":"Dashboard"},{"location":"dashboard/#dashboard","text":"","title":"Dashboard"},{"location":"dashboard/#hemlockdashboard","text":"class hemlock. Dashboard ( label='', template='hemlock/dash.html', **kwargs ) [source] Embeds a dash app . Parameters: label : str or bs4.BeautifulSoup, default='' Dashboard label. template : str, default='hemlock/dash.html' Template for the dashboard body. Attributes: aspect_ratio : tuple of (int, int), default=(16, 9) Aspect ratio of the embedded application. See https://getbootstrap.com/docs/4.0/utilities/embed/#aspect-ratios . embed : bs4.Tag <div> tag of the embedded app. g : dict Mutable dictionary with dashboard arguments. iframe : bs4.Tag <iframe> tag of the embedded app. src : str src attribute of the <iframe> tag.","title":"hemlock.Dashboard"},{"location":"dashboard/#examples","text":"In this example, we create a simple dash app in which participants click on a button. We embed this app in a hemlock survey, and record the number of times a participant clicked the button. Install dash with: $ hlk install dash Or: $ pip install dash In survey.py : from hemlock import Branch , Dashboard , Label , Page , route @route ( '/survey' ) def start (): return Branch ( Page ( Dashboard ( src = '/dashapp/' , var = 'n_clicks' ) ), Page ( Label ( '<p>The end.</p>' ), terminal = True ) ) In app.py : import survey import dash import dash_core_components as dcc import dash_html_components as html from dash.dependencies import Input , Output from hemlock import Dashboard , create_app app = create_app () dash_app = dash . Dash ( server = app , routes_pathname_prefix = '/dashapp/' , external_stylesheets = [ 'https://codepen.io/chriddyp/pen/bWLwgP.css' ] ) dash_app . layout = html . Div ([ dcc . Location ( id = 'url' ), html . Button ( 'Click me!' , id = 'button' ), html . P ( id = 'click-tracker' ), ]) @dash_app . callback ( Output ( 'click-tracker' , 'children' ), [ Input ( 'url' , 'search' ), Input ( 'button' , 'n_clicks' )] ) def update_clicks ( search , n_clicks ): n_clicks = n_clicks or 0 Dashboard . record_response ( search , n_clicks ) return ' {} clicks' . format ( n_clicks ) if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) Run the app with: $ hlk serve Or: $ python app.py Then open your browser and navigate to http://localhost:5000/ .","title":"Examples"},{"location":"dashboard/#methods","text":"get ( search ) [source] Utility for retrieving a dashboard question in a dash callback. Parameters: search : str, formatted as URL query string Must have 'id' and 'key' parameters. Returns: dashboard : hemlock_dash.Dashboard Dashboard specified by the id in the search string.","title":"Methods"},{"location":"dashboard/#examples_1","text":"... import dash_core_components as dcc from hemlock import Dashboard app . layout = html . Div ([ dcc . Location ( id = 'url' , refresh = False ), ... ]) @app . callback ( Output ( ... ), [ Input ( 'url' , 'search' ), ... ] ) def my_callback ( search , ... ): dashboard = Dashboard . get ( search ) record_response ( search, response ) [source] Utility for writing the response attribute of the dashboard question. Parameters: search : str, formatted as URL query string Must have 'id' and 'key' parameters. response : Value to which to set the dash question's repsonse attribute. Returns: dashboard : hemlock_dash.Dashboard Dashboard specified by the id in the search string.","title":"Examples"},{"location":"dashboard/#examples_2","text":"```python ... import dash_core_components as dcc from hemlock import Dashboard app.layout = html.Div([ dcc.Location(id='url', refresh=False), ... ]) @app.callback( Output(...), [Input('url', 'search'), ...] ) def my_callback(search, ...): Dashboard.record_response(search, 'hello world')","title":"Examples"},{"location":"debug/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Debugger The debugger sends 'AI participants' through the survey. The AI participants attempt to break the survey by clicking random objects and entering random responses. Notes If your app is running on a different local host port than 5000, set the url root as an environment variable before opening the python shell in your second terminal: $ export ULR_ROOT=http://localhost:xxxx If your application import is not app.app , set the import as an enviornment variable before opening the python shell in your second terminal: $ export APP_IMPORT=path.to.app AI participants run in batches of specified sizes. For local debugging, I recommend a batch size of 1. For production debugging, you can safely go up to 3. Examples This example debugs an app locally. In survey.py : from hemlock import Branch , Page , Label , route @route ( '/survey' ) def start (): x = 1 / 0 return Branch ( Page ( Label ( '<p>Hello World</p>' ), terminal = True )) In app.py : import survey from hemlock import create_app app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app ) Open a terminal and run the app with: $ python app.py $ or python3 app.py Open a second terminal and open the python shell with: $ python # or python3 Run the debugger in the second terminal: >>> from hemlock.debug import AIParticipant, debug >>> debug() The debugger will open a chromedriver and attempt to complete the survey. The first terminal window will display this error: File \"/home/<username>/hemlock/survey.py\", line 9, in start x = 1/0 ZeroDivisionError: division by zero hemlock.debug. debug def hemlock.debug. debug ( num_batches=1, batch_size=1 ) [source] Run the debugger. Parameters: num_batches : int, default=1 Number of batches of AI participants to run. batch_size : int, default=1 Number of AI participants to run per batch. Returns: result : bool True if all AI participants in all batches run sucessfully. Otherwise, the program will crash. Notes When called from the command line tool, num_batches and batch_size are passed as strings. hemlock.debug. run_batch def hemlock.debug. run_batch ( batch_size=1 ) [source] Run a batch of AI participants. Parameters: batch_size : int, default=1 Number of AI participants to run in this batch. Returns: result : bool True if all AI participants in this batch run successfully. Otherwise, the program will crash. hemlock.debug. run_participant def hemlock.debug. run_participant ( ) [source] Run a single AI participant through the survey. Assert that the participant does not encounter failures or errors. Returns: result : bool True if the participant ran successfully.","title":"Debugging"},{"location":"debug/#debugger","text":"The debugger sends 'AI participants' through the survey. The AI participants attempt to break the survey by clicking random objects and entering random responses.","title":"Debugger"},{"location":"debug/#notes","text":"If your app is running on a different local host port than 5000, set the url root as an environment variable before opening the python shell in your second terminal: $ export ULR_ROOT=http://localhost:xxxx If your application import is not app.app , set the import as an enviornment variable before opening the python shell in your second terminal: $ export APP_IMPORT=path.to.app AI participants run in batches of specified sizes. For local debugging, I recommend a batch size of 1. For production debugging, you can safely go up to 3.","title":"Notes"},{"location":"debug/#examples","text":"This example debugs an app locally. In survey.py : from hemlock import Branch , Page , Label , route @route ( '/survey' ) def start (): x = 1 / 0 return Branch ( Page ( Label ( '<p>Hello World</p>' ), terminal = True )) In app.py : import survey from hemlock import create_app app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app ) Open a terminal and run the app with: $ python app.py $ or python3 app.py Open a second terminal and open the python shell with: $ python # or python3 Run the debugger in the second terminal: >>> from hemlock.debug import AIParticipant, debug >>> debug() The debugger will open a chromedriver and attempt to complete the survey. The first terminal window will display this error: File \"/home/<username>/hemlock/survey.py\", line 9, in start x = 1/0 ZeroDivisionError: division by zero","title":"Examples"},{"location":"debug/#hemlockdebugdebug","text":"def hemlock.debug. debug ( num_batches=1, batch_size=1 ) [source] Run the debugger. Parameters: num_batches : int, default=1 Number of batches of AI participants to run. batch_size : int, default=1 Number of AI participants to run per batch. Returns: result : bool True if all AI participants in all batches run sucessfully. Otherwise, the program will crash.","title":"hemlock.debug.debug"},{"location":"debug/#notes_1","text":"When called from the command line tool, num_batches and batch_size are passed as strings.","title":"Notes"},{"location":"debug/#hemlockdebugrun_batch","text":"def hemlock.debug. run_batch ( batch_size=1 ) [source] Run a batch of AI participants. Parameters: batch_size : int, default=1 Number of AI participants to run in this batch. Returns: result : bool True if all AI participants in this batch run successfully. Otherwise, the program will crash.","title":"hemlock.debug.run_batch"},{"location":"debug/#hemlockdebugrun_participant","text":"def hemlock.debug. run_participant ( ) [source] Run a single AI participant through the survey. Assert that the participant does not encounter failures or errors. Returns: result : bool True if the participant ran successfully.","title":"hemlock.debug.run_participant"},{"location":"debug_functions/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Debug functions Debug functions tell the AI participant what to do during debugging. They generally take a selenium webdriver as their first argument and a page or question as their second argument. Notes The following examples open a webdriver. After running the examples, close the driver with driver.close() . By default, the last debug function of a page navigates. To remove this, run page.debug.pop() . hemlock.functions.debug. forward def hemlock.functions.debug. forward ( driver, page, max_wait=30, wait_interval=3 ) [source] Click the forward button. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page Examples from hemlock import Debug as D , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( debug = [ D . debug_questions (), D . forward ()]) p . preview ( driver ) . _debug ( driver ) hemlock.functions.debug. back def hemlock.functions.debug. back ( driver, page, max_wait=30, wait_interval=1 ) [source] Click the back button. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page Examples from hemlock import Debug as D , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( debug = [ D . debug_questions (), D . back ()]) p . preview ( driver ) . _debug ( driver ) hemlock.functions.debug. send_keys def hemlock.functions.debug. send_keys ( driver, question, *keys, p_num=0.5 ) [source] Send the specified keys to the <textarea> or <input> . Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Question *keys : Keys to send to the textarea or input. If empty, keys are randomly selected. p_num : float, default=.5 Probability of sending a random number if keys are not specified (as opposed to a random string). Notes This debug function is skipped if the question is not displayed. Examples from hemlock import Debug as D , Input , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( Input ( debug = D . send_keys ( 'hello world' ))) p . preview ( driver ) . _debug ( driver ) hemlock.functions.debug. random_str def hemlock.functions.debug. random_str ( driver, question, magnitude=2, p_whitespace=0.2 ) [source] Send a random string to the textarea. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Question magnitude : int, default=2 Maximum magnitude of the length of the string. e.g. the default magnitude of 2 means that the maximum length is 10^2=100 characters. p_whitespace : float, default=.2 Frequency with which whitespace characters appear in the string. Notes This debug function is skipped if the question is not displayed. Examples from hemlock import Debug as D , Input , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( Input ( debug = D . random_str ())) p . preview ( driver ) . _debug ( driver ) hemlock.functions.debug. random_number def hemlock.functions.debug. random_number ( driver, question, *args, **kwargs ) [source] Send a random number to the textarea or input. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Question magn_lb : int, default=0 Lower bound for the magnitude of the number. mag_ub : int, default=10 Upper bound for the magnitude of the number. max_decimals : int, default=5 Maximum number of decimals to which the number can be rounded. p_int : float, default=.5 Probability that the number is an integer. p_neg : float, default=.1 Probability that the number is negative. Notes This debug function is skipped if the question is not displayed. Examples from hemlock import Debug as D , Input , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( Input ( debug = D . random_number ())) p . preview ( driver ) . _debug ( driver ) hemlock.functions.debug. send_datetime def hemlock.functions.debug. send_datetime ( driver, question, datetime_=None ) [source] Send a datetime.datetime object to an input. Inputs should be of type 'date', 'datetime-local', 'month', 'time', or 'week', Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Question datetime_ : datetime.datetime or None, default=None The datetime object to send. If None , a date and time are chosen randomly. Notes This debug function is skipped if the question is not displayed. Examples from hemlock import Debug as D , Input , Page , push_app_context from hemlock.tools import chromedriver from datetime import datetime app = push_app_context () driver = chromedriver () p = Page ( Input ( type = 'date' , debug = D . send_datetime ( datetime . utcnow ()))) p . preview ( driver ) . _debug ( driver ) hemlock.functions.debug. drag_range def hemlock.functions.debug. drag_range ( driver, range_, target=None, tol=0, max_iter=10 ) [source] Drag a range slider to specified target value. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver range_ : hemlock.Range target : float or None, default=None Target value to which the slider should be dragged. If None , a random target value will be chosen. tol : float, default=0 Tolerance for error if the slider cannot be dragged to the exact target. max_iter : int, default=10 Maximum number of iterations for the slider to reach the target. Notes This debug function is skipped if the question is not displayed. Examples from hemlock import Debug as D , Page , Range , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( Range ( debug = D . drag_range ( 80 ))) p . preview ( driver ) . _debug ( driver ) hemlock.functions.debug. click_choices def hemlock.functions.debug. click_choices ( driver, question, *values, if_selected=None ) [source] Click on choices or options. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.ChoiceQuestion *values : Values of the choices on which to click. If no choices are specified, the debugger will click on random choices. if_selected : bool or None, default=None Indicates that the choices will be clicked only if they are already selected. If False the choices will be clicked only if they are not already selected. If None the choices will be clicked whether or not they are selected. Notes Will not attempt to click choices or options which are not displayed. Examples from hemlock import Binary , Debug as D , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( Binary ( '<p>Click \"Yes\".</p>' , debug = D . click_choices ( 'Yes' ) ) ) p . preview ( driver ) . _debug ( driver ) ##hemlock.functions.debug.**clear_choices** < p class = \"func-header\" > < i > def </ i > hemlock . functions . debug .< b > clear_choices </ b > ( < i > driver , question </ i > ) < a class = \"src-href\" target = \"_blank\" href = \"https://github.com/dsbowen/hemlock/blob/master/hemlock/functions/debug.py#L408\" > [ source ] </ a > </ p > Clear selected choices . < table class = \"docutils field-list field-table\" frame = \"void\" rules = \"none\" > < col class = \"field-name\" /> < col class = \"field-body\" /> < tbody valign = \"top\" > < tr class = \"field\" > < th class = \"field-name\" >< b > Parameters : </ b ></ td > < td class = \"field-body\" width = \"100%\" >< b > driver : < i > selenium . webdriver . chrome . webdriver . WebDriver </ i ></ b > < p class = \"attr\" > </ p > < b > question : < i > hemlock . ChoiceQuestion </ i ></ b > < p class = \"attr\" > </ p ></ td > </ tr > </ tbody > </ table > ####Notes Intended only for questions in which multiple choices may be selected . ####Examples ``` python from hemlock import Check , Debug as D , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( Check ( \"<p>Which ice cream flavors do you like?</p>\" , [ 'Chocolate' , 'Vanilla' , 'Strawberry' ], default = 'Chocolate' , multiple = True , debug = D . clear_choices () ) ) p . preview ( driver ) . _debug ( driver )","title":"Debug"},{"location":"debug_functions/#debug-functions","text":"Debug functions tell the AI participant what to do during debugging. They generally take a selenium webdriver as their first argument and a page or question as their second argument.","title":"Debug functions"},{"location":"debug_functions/#notes","text":"The following examples open a webdriver. After running the examples, close the driver with driver.close() . By default, the last debug function of a page navigates. To remove this, run page.debug.pop() .","title":"Notes"},{"location":"debug_functions/#hemlockfunctionsdebugforward","text":"def hemlock.functions.debug. forward ( driver, page, max_wait=30, wait_interval=3 ) [source] Click the forward button. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page","title":"hemlock.functions.debug.forward"},{"location":"debug_functions/#examples","text":"from hemlock import Debug as D , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( debug = [ D . debug_questions (), D . forward ()]) p . preview ( driver ) . _debug ( driver )","title":"Examples"},{"location":"debug_functions/#hemlockfunctionsdebugback","text":"def hemlock.functions.debug. back ( driver, page, max_wait=30, wait_interval=1 ) [source] Click the back button. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page","title":"hemlock.functions.debug.back"},{"location":"debug_functions/#examples_1","text":"from hemlock import Debug as D , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( debug = [ D . debug_questions (), D . back ()]) p . preview ( driver ) . _debug ( driver )","title":"Examples"},{"location":"debug_functions/#hemlockfunctionsdebugsend_keys","text":"def hemlock.functions.debug. send_keys ( driver, question, *keys, p_num=0.5 ) [source] Send the specified keys to the <textarea> or <input> . Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Question *keys : Keys to send to the textarea or input. If empty, keys are randomly selected. p_num : float, default=.5 Probability of sending a random number if keys are not specified (as opposed to a random string).","title":"hemlock.functions.debug.send_keys"},{"location":"debug_functions/#notes_1","text":"This debug function is skipped if the question is not displayed.","title":"Notes"},{"location":"debug_functions/#examples_2","text":"from hemlock import Debug as D , Input , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( Input ( debug = D . send_keys ( 'hello world' ))) p . preview ( driver ) . _debug ( driver )","title":"Examples"},{"location":"debug_functions/#hemlockfunctionsdebugrandom_str","text":"def hemlock.functions.debug. random_str ( driver, question, magnitude=2, p_whitespace=0.2 ) [source] Send a random string to the textarea. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Question magnitude : int, default=2 Maximum magnitude of the length of the string. e.g. the default magnitude of 2 means that the maximum length is 10^2=100 characters. p_whitespace : float, default=.2 Frequency with which whitespace characters appear in the string.","title":"hemlock.functions.debug.random_str"},{"location":"debug_functions/#notes_2","text":"This debug function is skipped if the question is not displayed.","title":"Notes"},{"location":"debug_functions/#examples_3","text":"from hemlock import Debug as D , Input , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( Input ( debug = D . random_str ())) p . preview ( driver ) . _debug ( driver )","title":"Examples"},{"location":"debug_functions/#hemlockfunctionsdebugrandom_number","text":"def hemlock.functions.debug. random_number ( driver, question, *args, **kwargs ) [source] Send a random number to the textarea or input. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Question magn_lb : int, default=0 Lower bound for the magnitude of the number. mag_ub : int, default=10 Upper bound for the magnitude of the number. max_decimals : int, default=5 Maximum number of decimals to which the number can be rounded. p_int : float, default=.5 Probability that the number is an integer. p_neg : float, default=.1 Probability that the number is negative.","title":"hemlock.functions.debug.random_number"},{"location":"debug_functions/#notes_3","text":"This debug function is skipped if the question is not displayed.","title":"Notes"},{"location":"debug_functions/#examples_4","text":"from hemlock import Debug as D , Input , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( Input ( debug = D . random_number ())) p . preview ( driver ) . _debug ( driver )","title":"Examples"},{"location":"debug_functions/#hemlockfunctionsdebugsend_datetime","text":"def hemlock.functions.debug. send_datetime ( driver, question, datetime_=None ) [source] Send a datetime.datetime object to an input. Inputs should be of type 'date', 'datetime-local', 'month', 'time', or 'week', Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Question datetime_ : datetime.datetime or None, default=None The datetime object to send. If None , a date and time are chosen randomly.","title":"hemlock.functions.debug.send_datetime"},{"location":"debug_functions/#notes_4","text":"This debug function is skipped if the question is not displayed.","title":"Notes"},{"location":"debug_functions/#examples_5","text":"from hemlock import Debug as D , Input , Page , push_app_context from hemlock.tools import chromedriver from datetime import datetime app = push_app_context () driver = chromedriver () p = Page ( Input ( type = 'date' , debug = D . send_datetime ( datetime . utcnow ()))) p . preview ( driver ) . _debug ( driver )","title":"Examples"},{"location":"debug_functions/#hemlockfunctionsdebugdrag_range","text":"def hemlock.functions.debug. drag_range ( driver, range_, target=None, tol=0, max_iter=10 ) [source] Drag a range slider to specified target value. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver range_ : hemlock.Range target : float or None, default=None Target value to which the slider should be dragged. If None , a random target value will be chosen. tol : float, default=0 Tolerance for error if the slider cannot be dragged to the exact target. max_iter : int, default=10 Maximum number of iterations for the slider to reach the target.","title":"hemlock.functions.debug.drag_range"},{"location":"debug_functions/#notes_5","text":"This debug function is skipped if the question is not displayed.","title":"Notes"},{"location":"debug_functions/#examples_6","text":"from hemlock import Debug as D , Page , Range , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( Range ( debug = D . drag_range ( 80 ))) p . preview ( driver ) . _debug ( driver )","title":"Examples"},{"location":"debug_functions/#hemlockfunctionsdebugclick_choices","text":"def hemlock.functions.debug. click_choices ( driver, question, *values, if_selected=None ) [source] Click on choices or options. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.ChoiceQuestion *values : Values of the choices on which to click. If no choices are specified, the debugger will click on random choices. if_selected : bool or None, default=None Indicates that the choices will be clicked only if they are already selected. If False the choices will be clicked only if they are not already selected. If None the choices will be clicked whether or not they are selected.","title":"hemlock.functions.debug.click_choices"},{"location":"debug_functions/#notes_6","text":"Will not attempt to click choices or options which are not displayed.","title":"Notes"},{"location":"debug_functions/#examples_7","text":"from hemlock import Binary , Debug as D , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( Binary ( '<p>Click \"Yes\".</p>' , debug = D . click_choices ( 'Yes' ) ) ) p . preview ( driver ) . _debug ( driver ) ##hemlock.functions.debug.**clear_choices** < p class = \"func-header\" > < i > def </ i > hemlock . functions . debug .< b > clear_choices </ b > ( < i > driver , question </ i > ) < a class = \"src-href\" target = \"_blank\" href = \"https://github.com/dsbowen/hemlock/blob/master/hemlock/functions/debug.py#L408\" > [ source ] </ a > </ p > Clear selected choices . < table class = \"docutils field-list field-table\" frame = \"void\" rules = \"none\" > < col class = \"field-name\" /> < col class = \"field-body\" /> < tbody valign = \"top\" > < tr class = \"field\" > < th class = \"field-name\" >< b > Parameters : </ b ></ td > < td class = \"field-body\" width = \"100%\" >< b > driver : < i > selenium . webdriver . chrome . webdriver . WebDriver </ i ></ b > < p class = \"attr\" > </ p > < b > question : < i > hemlock . ChoiceQuestion </ i ></ b > < p class = \"attr\" > </ p ></ td > </ tr > </ tbody > </ table > ####Notes Intended only for questions in which multiple choices may be selected . ####Examples ``` python from hemlock import Check , Debug as D , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () p = Page ( Check ( \"<p>Which ice cream flavors do you like?</p>\" , [ 'Chocolate' , 'Vanilla' , 'Strawberry' ], default = 'Chocolate' , multiple = True , debug = D . clear_choices () ) ) p . preview ( driver ) . _debug ( driver )","title":"Examples"},{"location":"download/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Download button See https://dsbowen.github.io/flask-download-btn/ for more details. hemlock. Download class hemlock. Download ( label='', template='hemlock/download.html', **kwargs ) [source] Allows participants to download files. Inherits from flask_download_btn.DownloadBtnMixin and hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Download button label. template : str, default='hemlock/download.html' Download button body template. Relationships: create_file_functions : list of hemlock.CreateFile Functions for creating files and executing other operations after form handling and before beginning download. More on [file creation] (https://dsbowen.github.io/flask-download-btn/create/). handle_form_functions : list of hemlock.HandleForm Functions for making the download button responsive to web forms. These functions are executed before file creation functions. More on form handling . Examples from hemlock import Download , Page , push_app_context app = push_app_context () Page ( Download ( '<p>Click here to download a file.</p>' , downloads = [( 'HELLO_WORLD_URL' , 'hello_world.txt' )] )) . preview () Replace 'HELLO_WORLD_URL' with your file download URL. Note that the download button will not download your file from a preview. hemlock. CreateFile Function models for creating files and executing other operations after form handling and before download. Inherits from hemlock.models.FunctionRegistrar . hemlock. HandleForm Function models for form handling. Inherits from hemlock.models.FunctionRegistrar .","title":"Download"},{"location":"download/#download-button","text":"See https://dsbowen.github.io/flask-download-btn/ for more details.","title":"Download button"},{"location":"download/#hemlockdownload","text":"class hemlock. Download ( label='', template='hemlock/download.html', **kwargs ) [source] Allows participants to download files. Inherits from flask_download_btn.DownloadBtnMixin and hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Download button label. template : str, default='hemlock/download.html' Download button body template. Relationships: create_file_functions : list of hemlock.CreateFile Functions for creating files and executing other operations after form handling and before beginning download. More on [file creation] (https://dsbowen.github.io/flask-download-btn/create/). handle_form_functions : list of hemlock.HandleForm Functions for making the download button responsive to web forms. These functions are executed before file creation functions. More on form handling .","title":"hemlock.Download"},{"location":"download/#examples","text":"from hemlock import Download , Page , push_app_context app = push_app_context () Page ( Download ( '<p>Click here to download a file.</p>' , downloads = [( 'HELLO_WORLD_URL' , 'hello_world.txt' )] )) . preview () Replace 'HELLO_WORLD_URL' with your file download URL. Note that the download button will not download your file from a preview.","title":"Examples"},{"location":"download/#hemlockcreatefile","text":"Function models for creating files and executing other operations after form handling and before download. Inherits from hemlock.models.FunctionRegistrar .","title":"hemlock.CreateFile"},{"location":"download/#hemlockhandleform","text":"Function models for form handling. Inherits from hemlock.models.FunctionRegistrar .","title":"hemlock.HandleForm"},{"location":"embedded/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Embedded data and timers hemlock. Embedded class hemlock. Embedded ( var=None, data=None, data_rows=1, **kwargs ) [source] Embedded data belong to a branch or page. Use embedded data to manually input data to the dataframe; as opposed to recording data from participant responses. Polymorphic with hemlock.models.Data . Parameters: var : str or None, default=None Variable name associated with this data element. If None , the data will not be recorded. data : sqlalchemy_mutable.MutableType Data this element contributes to the dataframe. data_rows : int, default=1 Number of rows this data element contributes to the dataframe for its participant. If negative, this data element will 'fill in' any emtpy rows at the end of the dataframe with its most recent value. Relationships: participant : hemlock.Participant or None The participant to whom this data element belongs. branch : hemlock.Branch or None The branch to which the embedded data element belongs. page : hemlock.Page or None The page to which this embedded data element belongs. Examples from hemlock import Branch , Embedded , Page , Participant , push_app_context def start (): return Branch ( Page ()) app = push_app_context () part = Participant . gen_test_participant ( start ) part . embedded = [ Embedded ( 'Name' , 'Socrates' , data_rows =- 1 )] part . get_data () Out: {'ID': [1], 'EndTime': [datetime.datetime(2020, 7, 4, 17, 57, 23, 854272)], 'StartTime': [datetime.datetime(2020, 7, 4, 17, 57, 23, 854272)], 'Status': ['InProgress'], 'Name': ['Socrates'], 'NameOrder': [0], 'NameIndex': [0]} hemlock. Timer class hemlock. Timer ( var=None, data_rows=1, **kwargs ) [source] Tracks how much time a participant spends in various parts of the survey. Inherits from hemlock.Embedded . Attributes: data : float or None Read only. Number of seconds for which the timer has been running. end_time : datetime.datetime or None Read only. If the timer is running, this is the current time. If the timer is paused, this is the time at which the timer was last paused. start_time : datetime.datetime or None The time at which the timer was started. state : str 'not started' , 'running ', or 'paused' . total_time : datetime.timedelta or None Read only. Total time the timer has been running. Examples from hemlock import Timer , push_app_context import time app = push_app_context () timer = Timer () print ( timer . state ) timer . start () print ( timer . state ) time . sleep ( 1 ) print ( timer . data ) timer . pause () print ( timer . state ) time . sleep ( 1 ) print ( timer . data ) Out: not started running 1.002405 paused 1.002983 Methods start ( self ) [source] Start the timer. Returns: self : hemlock.Timer pause ( self ) [source] Pause the timer. Returns: self : hemlock.Timer reset ( self ) [source] Reset all attributes to their default values. Returns: self : hemlock.Timer","title":"Embedded data and timers"},{"location":"embedded/#embedded-data-and-timers","text":"","title":"Embedded data and timers"},{"location":"embedded/#hemlockembedded","text":"class hemlock. Embedded ( var=None, data=None, data_rows=1, **kwargs ) [source] Embedded data belong to a branch or page. Use embedded data to manually input data to the dataframe; as opposed to recording data from participant responses. Polymorphic with hemlock.models.Data . Parameters: var : str or None, default=None Variable name associated with this data element. If None , the data will not be recorded. data : sqlalchemy_mutable.MutableType Data this element contributes to the dataframe. data_rows : int, default=1 Number of rows this data element contributes to the dataframe for its participant. If negative, this data element will 'fill in' any emtpy rows at the end of the dataframe with its most recent value. Relationships: participant : hemlock.Participant or None The participant to whom this data element belongs. branch : hemlock.Branch or None The branch to which the embedded data element belongs. page : hemlock.Page or None The page to which this embedded data element belongs.","title":"hemlock.Embedded"},{"location":"embedded/#examples","text":"from hemlock import Branch , Embedded , Page , Participant , push_app_context def start (): return Branch ( Page ()) app = push_app_context () part = Participant . gen_test_participant ( start ) part . embedded = [ Embedded ( 'Name' , 'Socrates' , data_rows =- 1 )] part . get_data () Out: {'ID': [1], 'EndTime': [datetime.datetime(2020, 7, 4, 17, 57, 23, 854272)], 'StartTime': [datetime.datetime(2020, 7, 4, 17, 57, 23, 854272)], 'Status': ['InProgress'], 'Name': ['Socrates'], 'NameOrder': [0], 'NameIndex': [0]}","title":"Examples"},{"location":"embedded/#hemlocktimer","text":"class hemlock. Timer ( var=None, data_rows=1, **kwargs ) [source] Tracks how much time a participant spends in various parts of the survey. Inherits from hemlock.Embedded . Attributes: data : float or None Read only. Number of seconds for which the timer has been running. end_time : datetime.datetime or None Read only. If the timer is running, this is the current time. If the timer is paused, this is the time at which the timer was last paused. start_time : datetime.datetime or None The time at which the timer was started. state : str 'not started' , 'running ', or 'paused' . total_time : datetime.timedelta or None Read only. Total time the timer has been running.","title":"hemlock.Timer"},{"location":"embedded/#examples_1","text":"from hemlock import Timer , push_app_context import time app = push_app_context () timer = Timer () print ( timer . state ) timer . start () print ( timer . state ) time . sleep ( 1 ) print ( timer . data ) timer . pause () print ( timer . state ) time . sleep ( 1 ) print ( timer . data ) Out: not started running 1.002405 paused 1.002983","title":"Examples"},{"location":"embedded/#methods","text":"start ( self ) [source] Start the timer. Returns: self : hemlock.Timer pause ( self ) [source] Pause the timer. Returns: self : hemlock.Timer reset ( self ) [source] Reset all attributes to their default values. Returns: self : hemlock.Timer","title":"Methods"},{"location":"file/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } File upload hemlock. upload_to_bucket def hemlock. upload_to_bucket ( file_ ) [source] Default hemlock.File submit function. Uploads a participant file to Google bucket. Parameters: file_ : hemlock.File hemlock. File class hemlock. File ( label='', template='hemlock/file.html', **kwargs ) [source] Allows participants to upload files. Inherits from hemlock.qpolymorphs.InputGroup , hemlock.models.InputBase , and hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Upload file label. template : str, default='hemlock/file.html' Template for the file upload body. Attributes: allowed_extensions : list Allowed file extensions, e.g. ['.png','.jpeg'] . filename : str Name of the file as stored in the Google bucket. Examples Set up a Google bucket with the appropriate CORS permissions . Set an environment variable BUCKET to the name of the bucket, and GOOGLE_APPLICATION_CREDENTIALS to the name of your Google application credentials JSON file . export BUCKET=<my-bucket> GOOGLE_APPLICATION_CREDENTIALS=<my-credentials.json> In survey.py : from hemlock import Branch , File , Page , Label , route @route ( '/survey' ) def start (): return Branch ( Page ( File ( '<p>Upload a .png</p>' , filename = 'upload' , allowed_extensions = [ '.png' ] )), Page ( Label ( '<p>The End</p>' ), terminal = True ) ) In app.py : import survey from hemlock import create_app app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) Run the app locally with: $ python app.py # or python3 app.py And open your browser to http://localhost:5000/ . Upload a .png and click to the next page. You'll find your uploaded file in your Google bucket in participant-1/upload.png . Methods generate_signed_url ( self, expiration=timedelta(hours=0.5), **kwargs ) [source] Generate a signed URL for the uploaded file. Parameters: expiration : datetime.timedelta, default=datetime.timedelta(0, 1800) Duration for which this signed URL is valid. **kwargs : Additional keyword arguments are passed to the generate_signed_url method. Notes Read more about signed URLs . get_allowed_types ( self ) [source] Returns: allowed_types : list List of allowed mimetypes. Derived from self.allowed_extensions . get_path ( self ) [source] Returns: path : str Path to the uploaded file in the Google bucket.","title":"File upload"},{"location":"file/#file-upload","text":"","title":"File upload"},{"location":"file/#hemlockupload_to_bucket","text":"def hemlock. upload_to_bucket ( file_ ) [source] Default hemlock.File submit function. Uploads a participant file to Google bucket. Parameters: file_ : hemlock.File","title":"hemlock.upload_to_bucket"},{"location":"file/#hemlockfile","text":"class hemlock. File ( label='', template='hemlock/file.html', **kwargs ) [source] Allows participants to upload files. Inherits from hemlock.qpolymorphs.InputGroup , hemlock.models.InputBase , and hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Upload file label. template : str, default='hemlock/file.html' Template for the file upload body. Attributes: allowed_extensions : list Allowed file extensions, e.g. ['.png','.jpeg'] . filename : str Name of the file as stored in the Google bucket.","title":"hemlock.File"},{"location":"file/#examples","text":"Set up a Google bucket with the appropriate CORS permissions . Set an environment variable BUCKET to the name of the bucket, and GOOGLE_APPLICATION_CREDENTIALS to the name of your Google application credentials JSON file . export BUCKET=<my-bucket> GOOGLE_APPLICATION_CREDENTIALS=<my-credentials.json> In survey.py : from hemlock import Branch , File , Page , Label , route @route ( '/survey' ) def start (): return Branch ( Page ( File ( '<p>Upload a .png</p>' , filename = 'upload' , allowed_extensions = [ '.png' ] )), Page ( Label ( '<p>The End</p>' ), terminal = True ) ) In app.py : import survey from hemlock import create_app app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) Run the app locally with: $ python app.py # or python3 app.py And open your browser to http://localhost:5000/ . Upload a .png and click to the next page. You'll find your uploaded file in your Google bucket in participant-1/upload.png .","title":"Examples"},{"location":"file/#methods","text":"generate_signed_url ( self, expiration=timedelta(hours=0.5), **kwargs ) [source] Generate a signed URL for the uploaded file. Parameters: expiration : datetime.timedelta, default=datetime.timedelta(0, 1800) Duration for which this signed URL is valid. **kwargs : Additional keyword arguments are passed to the generate_signed_url method.","title":"Methods"},{"location":"file/#notes","text":"Read more about signed URLs . get_allowed_types ( self ) [source] Returns: allowed_types : list List of allowed mimetypes. Derived from self.allowed_extensions . get_path ( self ) [source] Returns: path : str Path to the uploaded file in the Google bucket.","title":"Notes"},{"location":"functions/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Function models hemlock. FunctionRegistrar Mixin for Function models which provides a method for function registration. Inherits from sqlalchemy_function.FunctionMixin . Attributes: index : int or None Order in which this Function will be executed, relative to other Functions belonging to the same parent object. Methods register ( cls, func ) [source] This decorator registers a function. Parameters: func : callable The function to register. hemlock. Compile Helps compile a page or question html before it is rendered and displayed to a participant. Inherits from hemlock.FunctionRegistrar . Relationships: page : hemlock.Page or None Page to which this model belongs. question : hemlock.Question or None Question to which this model belongs. Examples from hemlock import Compile as C , Input , Label , Page , push_app_context app = push_app_context () @C . register def greet ( greet_q , name_q ): greet_q . label = '<p>Hello {} !</p>' . format ( name_q . response ) name_q = Input ( \"<p>What's your name?</p>\" ) p = Page ( Label ( compile = C . greet ( name_q ))) name_q . response = 'World' p . _compile () . preview () hemlock. Debug class hemlock. Debug ( *args, **kwargs ) [source] Run to help debug the survey. Inherits from hemlock.FunctionRegistrar . Attributes: p_exec : float, default=1. Probability that the debug function will execute. You can set this by passing in an p_exec keyword argument to the constructor. Relationships: page : hemlock.Page or None Page to which this model belongs. question : hemlock.Question or None Question to which this model belongs. Examples from hemlock import Debug as D , Input , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () @D . register def greet ( driver , greet_q ): inpt = greet_q . input_from_driver ( driver ) inpt . clear () inpt . send_keys ( 'Hello World!' ) p = Page ( Input ( '<p>Enter a greeting.</p>' , debug = D . greet ())) p . debug . pop ( - 1 ) # so the page won't navigate p . preview ( driver ) . _debug ( driver ) Methods __call__ ( self, *args, **kwargs ) [source] Execute the debug function with probability self.p_exec . hemlock. Validate class hemlock. Validate ( *args, **kwargs ) [source] Validates a participant's response. Inherits from hemlock.FunctionRegistrar . Attributes: error_msg : str or None If the validate function returns an error message, the error_msg attribute is returned instead of the output of the validate function. You can set this by passing in an error_msg keyword argument to the constructor. Relationships: page : hemlock.Page or None Page to which this model belongs. question : hemlock.Question or None Question to which this model belongs. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () @Validate . register def match ( inpt , pattern ): if inpt . response != pattern : return '<p>You entered \" {} \", not \" {} \"</p>' . format ( inpt . response , pattern ) pattern = 'hello world' inpt = Input ( validate = V . match ( pattern )) inpt . response = 'goodbye moon' inpt . _validate () inpt . error Out: You entered \"goodbye moon\", not \"hello world\" Methods __call__ ( self, *args, **kwargs ) [source] Returns: error_msg : str or None Return None if there is no error. If there is an error, return self.error_msg or the output of self.func . hemlock. Submit Runs after a participant has successfully submitted a page. Inherits from hemlock.FunctionRegistrar . Relationships: page : hemlock.Page or None Page to which this model belongs. question : hemlock.Question or None Question to which this model belongs. Examples from hemlock import Input , Submit as S , push_app_context app = push_app_context () @S . register def get_initials ( name_q ): names = name_q . response . split () name_q . data = '.' . join ([ name [ 0 ] for name in names ]) + '.' inpt = Input ( \"<p>What's your name?</p>\" , submit = S . get_initials ()) inpt . response = 'Andrew Yang' inpt . _submit () . data Out: A.Y. hemlock. Navigate Creates a new branch to which the participant will navigate. Relationships: branch : hemlock.Branch or None Branch to which this model belongs. page : hemlock.Page or None Page to which this model belongs. Examples from hemlock import Branch , Navigate as N , Page , Participant , push_app_context def start (): return Branch ( Page (), navigate = N . end ()) @N . register def end ( start_branch ): return Branch ( Page ( terminal = True )) app = push_app_context () part = Participant . gen_test_participant ( start ) part . view_nav () Out: <Branch 1> <Page 1> C C = current page T = terminal page In: part . forward () . view_nav () Out: <Branch 1> <Page 1> <Branch 2> <Page 2> C T C = current page T = terminal page Methods __call__ ( self, *args, **kwargs ) [source] Create a new branch and 'link' it to the tree. Linking in the new branch involves setting the next_branch and origin_branch or origin_page relationships.","title":"Function models"},{"location":"functions/#function-models","text":"","title":"Function models"},{"location":"functions/#hemlockfunctionregistrar","text":"Mixin for Function models which provides a method for function registration. Inherits from sqlalchemy_function.FunctionMixin . Attributes: index : int or None Order in which this Function will be executed, relative to other Functions belonging to the same parent object.","title":"hemlock.FunctionRegistrar"},{"location":"functions/#methods","text":"register ( cls, func ) [source] This decorator registers a function. Parameters: func : callable The function to register.","title":"Methods"},{"location":"functions/#hemlockcompile","text":"Helps compile a page or question html before it is rendered and displayed to a participant. Inherits from hemlock.FunctionRegistrar . Relationships: page : hemlock.Page or None Page to which this model belongs. question : hemlock.Question or None Question to which this model belongs.","title":"hemlock.Compile"},{"location":"functions/#examples","text":"from hemlock import Compile as C , Input , Label , Page , push_app_context app = push_app_context () @C . register def greet ( greet_q , name_q ): greet_q . label = '<p>Hello {} !</p>' . format ( name_q . response ) name_q = Input ( \"<p>What's your name?</p>\" ) p = Page ( Label ( compile = C . greet ( name_q ))) name_q . response = 'World' p . _compile () . preview ()","title":"Examples"},{"location":"functions/#hemlockdebug","text":"class hemlock. Debug ( *args, **kwargs ) [source] Run to help debug the survey. Inherits from hemlock.FunctionRegistrar . Attributes: p_exec : float, default=1. Probability that the debug function will execute. You can set this by passing in an p_exec keyword argument to the constructor. Relationships: page : hemlock.Page or None Page to which this model belongs. question : hemlock.Question or None Question to which this model belongs.","title":"hemlock.Debug"},{"location":"functions/#examples_1","text":"from hemlock import Debug as D , Input , Page , push_app_context from hemlock.tools import chromedriver app = push_app_context () driver = chromedriver () @D . register def greet ( driver , greet_q ): inpt = greet_q . input_from_driver ( driver ) inpt . clear () inpt . send_keys ( 'Hello World!' ) p = Page ( Input ( '<p>Enter a greeting.</p>' , debug = D . greet ())) p . debug . pop ( - 1 ) # so the page won't navigate p . preview ( driver ) . _debug ( driver )","title":"Examples"},{"location":"functions/#methods_1","text":"__call__ ( self, *args, **kwargs ) [source] Execute the debug function with probability self.p_exec .","title":"Methods"},{"location":"functions/#hemlockvalidate","text":"class hemlock. Validate ( *args, **kwargs ) [source] Validates a participant's response. Inherits from hemlock.FunctionRegistrar . Attributes: error_msg : str or None If the validate function returns an error message, the error_msg attribute is returned instead of the output of the validate function. You can set this by passing in an error_msg keyword argument to the constructor. Relationships: page : hemlock.Page or None Page to which this model belongs. question : hemlock.Question or None Question to which this model belongs.","title":"hemlock.Validate"},{"location":"functions/#examples_2","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () @Validate . register def match ( inpt , pattern ): if inpt . response != pattern : return '<p>You entered \" {} \", not \" {} \"</p>' . format ( inpt . response , pattern ) pattern = 'hello world' inpt = Input ( validate = V . match ( pattern )) inpt . response = 'goodbye moon' inpt . _validate () inpt . error Out: You entered \"goodbye moon\", not \"hello world\"","title":"Examples"},{"location":"functions/#methods_2","text":"__call__ ( self, *args, **kwargs ) [source] Returns: error_msg : str or None Return None if there is no error. If there is an error, return self.error_msg or the output of self.func .","title":"Methods"},{"location":"functions/#hemlocksubmit","text":"Runs after a participant has successfully submitted a page. Inherits from hemlock.FunctionRegistrar . Relationships: page : hemlock.Page or None Page to which this model belongs. question : hemlock.Question or None Question to which this model belongs.","title":"hemlock.Submit"},{"location":"functions/#examples_3","text":"from hemlock import Input , Submit as S , push_app_context app = push_app_context () @S . register def get_initials ( name_q ): names = name_q . response . split () name_q . data = '.' . join ([ name [ 0 ] for name in names ]) + '.' inpt = Input ( \"<p>What's your name?</p>\" , submit = S . get_initials ()) inpt . response = 'Andrew Yang' inpt . _submit () . data Out: A.Y.","title":"Examples"},{"location":"functions/#hemlocknavigate","text":"Creates a new branch to which the participant will navigate. Relationships: branch : hemlock.Branch or None Branch to which this model belongs. page : hemlock.Page or None Page to which this model belongs.","title":"hemlock.Navigate"},{"location":"functions/#examples_4","text":"from hemlock import Branch , Navigate as N , Page , Participant , push_app_context def start (): return Branch ( Page (), navigate = N . end ()) @N . register def end ( start_branch ): return Branch ( Page ( terminal = True )) app = push_app_context () part = Participant . gen_test_participant ( start ) part . view_nav () Out: <Branch 1> <Page 1> C C = current page T = terminal page In: part . forward () . view_nav () Out: <Branch 1> <Page 1> <Branch 2> <Page 2> C T C = current page T = terminal page","title":"Examples"},{"location":"functions/#methods_3","text":"__call__ ( self, *args, **kwargs ) [source] Create a new branch and 'link' it to the tree. Linking in the new branch involves setting the next_branch and origin_branch or origin_page relationships.","title":"Methods"},{"location":"input/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Input hemlock. random_input def hemlock. random_input ( driver, question ) [source] Default debug function for input questions. This function sends a random string or number if the input takes text, or a random datetime.datetime object if the input takes dates or times. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Input hemlock. Input class hemlock. Input ( label='', template='hemlock/input.html', **kwargs ) [source] Inputs take text input by default, or other types of html inputs. Inherits from hemlock.qpolymorphs.InputGroup , hemlock.models.InputBase and hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Input label. template : str, default='hemlock/input.html' Template for the input body. Attributes: attrs : dict Input tag attributes. type : str, default='text' Type of html input. See https://www.w3schools.com/html/html_form_input_types.asp . placeholder : str or None, default=None Html placeholder. step : float, str, or None, default=None Step attribute for number inputs. By default, the step for number inputs is 1. Set to 'any' for any step. Examples from hemlock import Input , Page , push_app_context app = push_app_context () Page ( Input ( '<p>Input text here.</p>' )) . preview ()","title":"Input"},{"location":"input/#input","text":"","title":"Input"},{"location":"input/#hemlockrandom_input","text":"def hemlock. random_input ( driver, question ) [source] Default debug function for input questions. This function sends a random string or number if the input takes text, or a random datetime.datetime object if the input takes dates or times. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver question : hemlock.Input","title":"hemlock.random_input"},{"location":"input/#hemlockinput","text":"class hemlock. Input ( label='', template='hemlock/input.html', **kwargs ) [source] Inputs take text input by default, or other types of html inputs. Inherits from hemlock.qpolymorphs.InputGroup , hemlock.models.InputBase and hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Input label. template : str, default='hemlock/input.html' Template for the input body. Attributes: attrs : dict Input tag attributes. type : str, default='text' Type of html input. See https://www.w3schools.com/html/html_form_input_types.asp . placeholder : str or None, default=None Html placeholder. step : float, str, or None, default=None Step attribute for number inputs. By default, the step for number inputs is 1. Set to 'any' for any step.","title":"hemlock.Input"},{"location":"input/#examples","text":"from hemlock import Input , Page , push_app_context app = push_app_context () Page ( Input ( '<p>Input text here.</p>' )) . preview ()","title":"Examples"},{"location":"input_group/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Input group base hemlock.qpolymorphs. InputGroup A base class for questions with input groups . Attributes: append : str Text appended to the input field. Specifically, the text of the div.input-group-append tag. prepend : str Text prepended to the input field. Specifically, the text of the div.input-group-prepend tag.","title":"Input group"},{"location":"input_group/#input-group-base","text":"","title":"Input group base"},{"location":"input_group/#hemlockqpolymorphsinputgroup","text":"A base class for questions with input groups . Attributes: append : str Text appended to the input field. Specifically, the text of the div.input-group-append tag. prepend : str Text prepended to the input field. Specifically, the text of the div.input-group-prepend tag.","title":"hemlock.qpolymorphs.InputGroup"},{"location":"label/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Label hemlock. Label class hemlock. Label ( label='', template='hemlock/form-group.html', **kwargs ) [source] This question contains a label and does not receive input from the participant. Parameters: label : str or bs4.BeautifulSoup, default='' Question label. template : str, default='hemlock/form-group.html' Path to the Jinja template for the label body. Examples from hemlock import Label , Page , push_app_context app = push_app_context () Page ( Label ( '<p>Hello World</p>' )) . preview ()","title":"Label"},{"location":"label/#label","text":"","title":"Label"},{"location":"label/#hemlocklabel","text":"class hemlock. Label ( label='', template='hemlock/form-group.html', **kwargs ) [source] This question contains a label and does not receive input from the participant. Parameters: label : str or bs4.BeautifulSoup, default='' Question label. template : str, default='hemlock/form-group.html' Path to the Jinja template for the label body.","title":"hemlock.Label"},{"location":"label/#examples","text":"from hemlock import Label , Page , push_app_context app = push_app_context () Page ( Label ( '<p>Hello World</p>' )) . preview ()","title":"Examples"},{"location":"lang/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Language tools hemlock.tools. indef_article def hemlock.tools. indef_article ( word ) [source] Parameters: word : str Word to which the indefinite article belongs. Returns: article : str 'an' if word starts with a vowel, or 'a' otherwise, followed by the word. Examples from hemlock.tools import indef_article [ indef_article ( fruit ) for fruit in ( 'apple' , 'banana' )] Out: ['an apple', 'a banana'] hemlock.tools. join def hemlock.tools. join ( joiner, *items ) [source] Parameters: joiner : str Joins the first n-1 items with the last item, e.g. 'and' . *items : str Items to join. Returns: joined : str Joined items. Examples from hemlock.tools import join print ( join ( 'and' , 'world' , 'sun' )) print ( join ( 'or' , 'world' , 'sun' , 'moon' )) Out: world and sun world, sun, or moon hemlock.tools. plural def hemlock.tools. plural ( n, singular, plural=None ) [source] Parameters: n : int Number. singular : str The singular form of the word. plural : str or None, default=None The plural form of the word. If None , the plural form is assumed to be the singular + 's'. Returns: word : str The singular form if number is 1, plural form otherwise. Examples from hemlock.tools import plural [ ' {} {} ' . format ( n , plural ( n , 'cat' )) for n in range ( 0 , 3 )] Out: ['0 cats', '1 cat', '2 cats'] hemlock.tools. pronouns def hemlock.tools. pronouns ( person, singular, gender=None, pfx='' ) [source] Parameters: person : int 1 , 2 , or 3 for first, second, or third person. singular : bool True for singular, False for plural. gender : str or None, default=None 'male' , 'female' , 'neuter' , or 'epicene' . Required for third person singular pronouns. pfx : str, default='' Prefix for dictionary keys. Use this to distinguish between multiple entities in a single string. Returns: pronouns : dict Mapping of pronoun keys to pronouns. Pronoun keys are 'subject' , 'object' , 'dep_poss' (dependent possessive), 'indep_poss' , (indepedent possessive), 'reflex' (reflexive). Examples from hemlock.tools import pronouns string = ''' {A_subject} said hello to {B_object} as {B_subject} was walking {B_dep_poss} neighbor's dog. 'Is that dog {B_indep_poss} ?', {A_subject} thought to {A_reflex} . ''' string . format ( ** pronouns ( 3 , True , 'male' , pfx = 'A_' ), ** pronouns ( 3 , True , 'female' , pfx = 'B_' ) ) Out: he said hello to her as she was walking her neighbor's dog. 'Is that dog hers?', he thought to himself. In: string . format ( ** pronouns ( 3 , True , 'female' , pfx = 'A_' ), ** pronouns ( 3 , True , 'male' , pfx = 'B_' ) ) Out: she said hello to him as he was walking his neighbor's dog. 'Is that dog his?', she thought to herself.","title":"Language"},{"location":"lang/#language-tools","text":"","title":"Language tools"},{"location":"lang/#hemlocktoolsindef_article","text":"def hemlock.tools. indef_article ( word ) [source] Parameters: word : str Word to which the indefinite article belongs. Returns: article : str 'an' if word starts with a vowel, or 'a' otherwise, followed by the word.","title":"hemlock.tools.indef_article"},{"location":"lang/#examples","text":"from hemlock.tools import indef_article [ indef_article ( fruit ) for fruit in ( 'apple' , 'banana' )] Out: ['an apple', 'a banana']","title":"Examples"},{"location":"lang/#hemlocktoolsjoin","text":"def hemlock.tools. join ( joiner, *items ) [source] Parameters: joiner : str Joins the first n-1 items with the last item, e.g. 'and' . *items : str Items to join. Returns: joined : str Joined items.","title":"hemlock.tools.join"},{"location":"lang/#examples_1","text":"from hemlock.tools import join print ( join ( 'and' , 'world' , 'sun' )) print ( join ( 'or' , 'world' , 'sun' , 'moon' )) Out: world and sun world, sun, or moon","title":"Examples"},{"location":"lang/#hemlocktoolsplural","text":"def hemlock.tools. plural ( n, singular, plural=None ) [source] Parameters: n : int Number. singular : str The singular form of the word. plural : str or None, default=None The plural form of the word. If None , the plural form is assumed to be the singular + 's'. Returns: word : str The singular form if number is 1, plural form otherwise.","title":"hemlock.tools.plural"},{"location":"lang/#examples_2","text":"from hemlock.tools import plural [ ' {} {} ' . format ( n , plural ( n , 'cat' )) for n in range ( 0 , 3 )] Out: ['0 cats', '1 cat', '2 cats']","title":"Examples"},{"location":"lang/#hemlocktoolspronouns","text":"def hemlock.tools. pronouns ( person, singular, gender=None, pfx='' ) [source] Parameters: person : int 1 , 2 , or 3 for first, second, or third person. singular : bool True for singular, False for plural. gender : str or None, default=None 'male' , 'female' , 'neuter' , or 'epicene' . Required for third person singular pronouns. pfx : str, default='' Prefix for dictionary keys. Use this to distinguish between multiple entities in a single string. Returns: pronouns : dict Mapping of pronoun keys to pronouns. Pronoun keys are 'subject' , 'object' , 'dep_poss' (dependent possessive), 'indep_poss' , (indepedent possessive), 'reflex' (reflexive).","title":"hemlock.tools.pronouns"},{"location":"lang/#examples_3","text":"from hemlock.tools import pronouns string = ''' {A_subject} said hello to {B_object} as {B_subject} was walking {B_dep_poss} neighbor's dog. 'Is that dog {B_indep_poss} ?', {A_subject} thought to {A_reflex} . ''' string . format ( ** pronouns ( 3 , True , 'male' , pfx = 'A_' ), ** pronouns ( 3 , True , 'female' , pfx = 'B_' ) ) Out: he said hello to her as she was walking her neighbor's dog. 'Is that dog hers?', he thought to himself. In: string . format ( ** pronouns ( 3 , True , 'female' , pfx = 'A_' ), ** pronouns ( 3 , True , 'male' , pfx = 'B_' ) ) Out: she said hello to him as he was walking his neighbor's dog. 'Is that dog his?', she thought to herself.","title":"Examples"},{"location":"manifesto/","text":"Why Hemlock? The 3 day challenge It's March 2019, and I'm sitting at my computer furiously hacking away at the next great Hemlock feature. Next door, I can hear one of my fellow PhD candidates on the phone with Qualtrics support, trying to figure out how to add this one simple feature to her survey. She's spent all day yesterday by herself, and all morning today with a Qualtrics tech, trying to figure this out. My ears perk up. I walk over and knock on her door and ask her what she wants her survey to do. In 10 minutes, I code her survey exactly as specified and send her a link. She's excited. How did you do that? she asks. I invite her over to my computer and open up my python file. Her face drops. Ugh, I have to learn how to code? she says, audibly, then turns around and re-dials Qualtrics support. Coding is scary. I get it. As an undergrad, I had to take computer science 101 three times because I failed out of it twice. (And I never did get that comp sci major). But after wasting hundreds of hours wrestling with Qualtrics in the first year of my PhD, I decided learn how to code because coding gives you more power and flexibility than a GUI ever will. Because I get how scary coding can be when you're starting out, I've done everything I can think of to make Hemlock as easy as possible for you. But it's not going to be a walk in the park. You have to learn basic python, and you have to learn the Hemlock package. Expect to struggle. Hemlock isn't a product for your convenience; it's a tool for your craft. If you're an intermediate-level programmer (e.g. comfortable with R, new to python), expect 3 full days to get up to speed. 3 days sounds like a lot. But if you can invest that time right now, Hemlock will save you hundreds of hours over the course of your career, and allow you to shatter boundaries in your field. Hemlock saves you time A few weeks ago, my colleague from Cornell and I are shooting the breeze. He tells me his collaborator made a study that required some relatively simple (but still too complicated for Qualtrics) loop logic. So, the collaborator spent a full 40-hour work week copying and pasting blocks and adding convoluted branching logic in the Qualtrics GUI and QSF. I like a good challenge, so I tell my colleague to simply describe the study to me verbally start a timer. 1 hour and 13 minutes later, I email him a link to the Hemlock version. Let's imagine an alternative universe where my colleague's collaborator decides to use Hemlock instead of Qualtrics. Let's say it takes him 4 full days (32 hours) to learn basic python and the Hemlock package. And let's say, because he's new to Hemlock, that it takes him 4 times as long as it took me to make his study (5 hours). In this alternative universe, the collaborator learns python and Hemlock, makes his study, and still has 3 hours left over to kick back and sip mojitos. Here's a rough back-of-the-envelope calculation. Suppose, conservatively, you spend an average of 1 day a week making studies in Qualtrics for 5 years - e.g. as a PhD student - for a total of 2,000 hours. Now suppose you learn Hemlock, which (again, conservatively) speeds up the process by an average of 25%. That's a time savings of 500 hours. I'm guessing you're a researcher at a selective university, which means you're among the luckiest and brightest people in the world. Your time is valuable, and what you do matters. Copying and pasting blocks in a GUI that looks like it was downloaded from a dusted-off floppy disk is an unacceptable waste of your time and effort. Hemlock allows you to shatter boundaries The arc of technical progress There is no more low-hanging fruit Let me address an ostensible contraditiction: Common objections If I can do it it Qualtrics, I will do it in Qualtrics I'm giving a Hemlock demo in my department when one of my colleagues asks, Can you give me an example of when I would want to use Hemlock instead of Qualtrics? . No problem. Prof. Bob Axelrod from Michigan is running forecasting studies in which participants predict AI players' actions in a game theoretic setting. He's got the python code written to simulate the AI players. The players play a game, and after each of 40 rounds, the participant predicts what the players will do next. But it's not integrated into the survey. So, he displays the game in a terminal window, which looks something like this: Player 1: ['Defect', 'Defect', 'Cooperate', 'Cooperate', 'Defect', 'Cooperate', 'Cooperate', 'Defect', 'Cooperate', 'Defect'] Player 2: ['Cooperate', 'Cooperate', 'Defect', 'Defect', 'Cooperate', 'Defect', 'Cooperate', 'Cooperate', 'Cooperate', 'Cooperate'] Participants have to go back and forth between entering things into the terminal window and entering things in Qualtrics to keep the python simulation synchronized with Qualtrics. (And, by the way, because participants have to use a terminal window, you can't distribute the study online). But now imagine you're using Hemlock. You've already got the python code to run the simulation, so all you need is one line of code to put the results a table. Problem solved! Okay, but you could still do something like this in Qualtrics, my colleagues say. For one thing, you could run (let's say) 20 different games, write code to translate each round of each game into an HTML table, and copy and paste each table into Qualtrics. Another idea: you could write python code to write out QSF code. Let's take these suggestions one at a time. First, my colleague suggests running 20 games, 40 rounds each (that's 800 tables), copying and pasting them one by one into a corresponding 800 Qualtrics pages, then writing the branching logic to randomly assign participants to observe one of the 20 games. And what happens when you want to run a variation of this study? Copy and paste another 800 HTML tables? Second, my colleague suggests writing python code to write QSF code. But then, why not just use Hemlock and write python code? That's like saying you should first write your paper in Norwegian and then translate it into English instead of just writing it in English to begin with. This reaction is an example of a common objection: If I can do it in Qualtrics, I will do it in Qualtrics. Sure, maybe it's not literally impossible to do your research in Qualtrics. But is it easier to do your research in Qualtrics? Put differently, which scares you more: spending 3 days learning python and Hemlock, or copying and pasting dozens of blocks and hundreds of HTML tables for study after study in paper after paper for your entire career?","title":"Manifesto"},{"location":"manifesto/#why-hemlock","text":"","title":"Why Hemlock?"},{"location":"manifesto/#the-3-day-challenge","text":"It's March 2019, and I'm sitting at my computer furiously hacking away at the next great Hemlock feature. Next door, I can hear one of my fellow PhD candidates on the phone with Qualtrics support, trying to figure out how to add this one simple feature to her survey. She's spent all day yesterday by herself, and all morning today with a Qualtrics tech, trying to figure this out. My ears perk up. I walk over and knock on her door and ask her what she wants her survey to do. In 10 minutes, I code her survey exactly as specified and send her a link. She's excited. How did you do that? she asks. I invite her over to my computer and open up my python file. Her face drops. Ugh, I have to learn how to code? she says, audibly, then turns around and re-dials Qualtrics support. Coding is scary. I get it. As an undergrad, I had to take computer science 101 three times because I failed out of it twice. (And I never did get that comp sci major). But after wasting hundreds of hours wrestling with Qualtrics in the first year of my PhD, I decided learn how to code because coding gives you more power and flexibility than a GUI ever will. Because I get how scary coding can be when you're starting out, I've done everything I can think of to make Hemlock as easy as possible for you. But it's not going to be a walk in the park. You have to learn basic python, and you have to learn the Hemlock package. Expect to struggle. Hemlock isn't a product for your convenience; it's a tool for your craft. If you're an intermediate-level programmer (e.g. comfortable with R, new to python), expect 3 full days to get up to speed. 3 days sounds like a lot. But if you can invest that time right now, Hemlock will save you hundreds of hours over the course of your career, and allow you to shatter boundaries in your field.","title":"The 3 day challenge"},{"location":"manifesto/#hemlock-saves-you-time","text":"A few weeks ago, my colleague from Cornell and I are shooting the breeze. He tells me his collaborator made a study that required some relatively simple (but still too complicated for Qualtrics) loop logic. So, the collaborator spent a full 40-hour work week copying and pasting blocks and adding convoluted branching logic in the Qualtrics GUI and QSF. I like a good challenge, so I tell my colleague to simply describe the study to me verbally start a timer. 1 hour and 13 minutes later, I email him a link to the Hemlock version. Let's imagine an alternative universe where my colleague's collaborator decides to use Hemlock instead of Qualtrics. Let's say it takes him 4 full days (32 hours) to learn basic python and the Hemlock package. And let's say, because he's new to Hemlock, that it takes him 4 times as long as it took me to make his study (5 hours). In this alternative universe, the collaborator learns python and Hemlock, makes his study, and still has 3 hours left over to kick back and sip mojitos. Here's a rough back-of-the-envelope calculation. Suppose, conservatively, you spend an average of 1 day a week making studies in Qualtrics for 5 years - e.g. as a PhD student - for a total of 2,000 hours. Now suppose you learn Hemlock, which (again, conservatively) speeds up the process by an average of 25%. That's a time savings of 500 hours. I'm guessing you're a researcher at a selective university, which means you're among the luckiest and brightest people in the world. Your time is valuable, and what you do matters. Copying and pasting blocks in a GUI that looks like it was downloaded from a dusted-off floppy disk is an unacceptable waste of your time and effort.","title":"Hemlock saves you time"},{"location":"manifesto/#hemlock-allows-you-to-shatter-boundaries","text":"","title":"Hemlock allows you to shatter boundaries"},{"location":"manifesto/#the-arc-of-technical-progress","text":"","title":"The arc of technical progress"},{"location":"manifesto/#there-is-no-more-low-hanging-fruit","text":"Let me address an ostensible contraditiction:","title":"There is no more low-hanging fruit"},{"location":"manifesto/#common-objections","text":"","title":"Common objections"},{"location":"manifesto/#if-i-can-do-it-it-qualtrics-i-will-do-it-in-qualtrics","text":"I'm giving a Hemlock demo in my department when one of my colleagues asks, Can you give me an example of when I would want to use Hemlock instead of Qualtrics? . No problem. Prof. Bob Axelrod from Michigan is running forecasting studies in which participants predict AI players' actions in a game theoretic setting. He's got the python code written to simulate the AI players. The players play a game, and after each of 40 rounds, the participant predicts what the players will do next. But it's not integrated into the survey. So, he displays the game in a terminal window, which looks something like this: Player 1: ['Defect', 'Defect', 'Cooperate', 'Cooperate', 'Defect', 'Cooperate', 'Cooperate', 'Defect', 'Cooperate', 'Defect'] Player 2: ['Cooperate', 'Cooperate', 'Defect', 'Defect', 'Cooperate', 'Defect', 'Cooperate', 'Cooperate', 'Cooperate', 'Cooperate'] Participants have to go back and forth between entering things into the terminal window and entering things in Qualtrics to keep the python simulation synchronized with Qualtrics. (And, by the way, because participants have to use a terminal window, you can't distribute the study online). But now imagine you're using Hemlock. You've already got the python code to run the simulation, so all you need is one line of code to put the results a table. Problem solved! Okay, but you could still do something like this in Qualtrics, my colleagues say. For one thing, you could run (let's say) 20 different games, write code to translate each round of each game into an HTML table, and copy and paste each table into Qualtrics. Another idea: you could write python code to write out QSF code. Let's take these suggestions one at a time. First, my colleague suggests running 20 games, 40 rounds each (that's 800 tables), copying and pasting them one by one into a corresponding 800 Qualtrics pages, then writing the branching logic to randomly assign participants to observe one of the 20 games. And what happens when you want to run a variation of this study? Copy and paste another 800 HTML tables? Second, my colleague suggests writing python code to write QSF code. But then, why not just use Hemlock and write python code? That's like saying you should first write your paper in Norwegian and then translate it into English instead of just writing it in English to begin with. This reaction is an example of a common objection: If I can do it in Qualtrics, I will do it in Qualtrics. Sure, maybe it's not literally impossible to do your research in Qualtrics. But is it easier to do your research in Qualtrics? Put differently, which scares you more: spending 3 days learning python and Hemlock, or copying and pasting dozens of blocks and hundreds of HTML tables for study after study in paper after paper for your entire career?","title":"If I can do it it Qualtrics, I will do it in Qualtrics"},{"location":"navbar/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Navigation bar Examples from hemlock import Page , push_app_context from hemlock.tools import Navbar , Navitem , Navitemdd , Dropdownitem app = push_app_context () url_root = 'https://dsbowen.github.io/' navbar = Navbar ( 'Hemlock' , [ Navitem ( 'Application' , href = url_root + 'app' ), Navitemdd ( 'Tools' , [ Dropdownitem ( 'Language' , href = url_root + 'lang' ), Dropdownitem ( 'Navbar' , href = url_root + 'navbar' ) ] ) ], href = url_root + 'hemlock' ) Page ( navbar = navbar . render ()) . preview () hemlock.tools. NavBase class hemlock.tools. NavBase ( template, **kwargs ) [source] All navigation models inherit from this base. Parameters: template : str Path to template file. This is not a Jinja template, as you may wish to generate html for statics outside the application context. **kwargs : Any attribute of navigation objects can be set by passing it as a keyword argument. Attributes: a : bs4.Tag <a> tag. body : bs4.BeautifulSoup (sqlalchemy_mutablesoup.MutableSoup) Html container. label : str Navigation object label. href : str Hyperref associated with the object. Methods is_active ( self ) [source] Returns: is_active : bool Indicates that the object's href is active. hemlock.tools. Navbar class hemlock.tools. Navbar ( label='', navitems=[], template=os.path.join(DIR, 'navbar.html'), **kwargs ) [source] Parameters: label : str, default='' Navbar brand. navitems : list of hemlock.tools.Navitem and hemlock.tools.Navitemdd Navigation items associated with the navbar. template : str, default='directory/navbar.html' By default, this is a file stored in the directory of the current file. Methods render ( self ) [source] Returns: redered : bs4.BeautifulSoup A copy of self.body with rendered navitems. hemlock.tools. Navitem class hemlock.tools. Navitem ( label='', template=os.path.join(DIR, 'navitem.html'), ** kwargs ) [source] Navigation item without dropdown items. Parameters: label : str, default='' template : str, default='directory/navitem.html' By default, this is a file stored in the directory of the current file. Methods render ( self ) [source] Returns: rendered : bs4.BeautifulSoup Copy of self.body . hemlock.tools. Navitemdd class hemlock.tools. Navitemdd ( label='', dropdownitems=[], template=os.path.join(DIR, 'navitemdd.html'), **kwargs ) [source] Navigation item with dropdown items. Parameters: label : str, default='' dropdownitems : list of hemlock.tools.Dropdownitem template : str, default='directory/navitemdd.html' By default, this is a file stored in the directory of the current file. Methods render ( self ) [source] Returns: rendered : bs4.BeautifulSoup A copy of self.body with rendered dropdown items. hemlock.tools. Dropdownitem class hemlock.tools. Dropdownitem ( label='', template=os.path.join(DIR, 'dropdownitem.html' ), **kwargs ) [source] Parameters: label : str, default='' template : str, default='directory/dropdownitem.html' By default, this is a file stored in the directory of the current file. Methods render ( self ) [source] Returns: rendered : bs4.BeautifulSoup Copy of self.body .","title":"Navbar"},{"location":"navbar/#navigation-bar","text":"","title":"Navigation bar"},{"location":"navbar/#examples","text":"from hemlock import Page , push_app_context from hemlock.tools import Navbar , Navitem , Navitemdd , Dropdownitem app = push_app_context () url_root = 'https://dsbowen.github.io/' navbar = Navbar ( 'Hemlock' , [ Navitem ( 'Application' , href = url_root + 'app' ), Navitemdd ( 'Tools' , [ Dropdownitem ( 'Language' , href = url_root + 'lang' ), Dropdownitem ( 'Navbar' , href = url_root + 'navbar' ) ] ) ], href = url_root + 'hemlock' ) Page ( navbar = navbar . render ()) . preview ()","title":"Examples"},{"location":"navbar/#hemlocktoolsnavbase","text":"class hemlock.tools. NavBase ( template, **kwargs ) [source] All navigation models inherit from this base. Parameters: template : str Path to template file. This is not a Jinja template, as you may wish to generate html for statics outside the application context. **kwargs : Any attribute of navigation objects can be set by passing it as a keyword argument. Attributes: a : bs4.Tag <a> tag. body : bs4.BeautifulSoup (sqlalchemy_mutablesoup.MutableSoup) Html container. label : str Navigation object label. href : str Hyperref associated with the object.","title":"hemlock.tools.NavBase"},{"location":"navbar/#methods","text":"is_active ( self ) [source] Returns: is_active : bool Indicates that the object's href is active.","title":"Methods"},{"location":"navbar/#hemlocktoolsnavbar","text":"class hemlock.tools. Navbar ( label='', navitems=[], template=os.path.join(DIR, 'navbar.html'), **kwargs ) [source] Parameters: label : str, default='' Navbar brand. navitems : list of hemlock.tools.Navitem and hemlock.tools.Navitemdd Navigation items associated with the navbar. template : str, default='directory/navbar.html' By default, this is a file stored in the directory of the current file.","title":"hemlock.tools.Navbar"},{"location":"navbar/#methods_1","text":"render ( self ) [source] Returns: redered : bs4.BeautifulSoup A copy of self.body with rendered navitems.","title":"Methods"},{"location":"navbar/#hemlocktoolsnavitem","text":"class hemlock.tools. Navitem ( label='', template=os.path.join(DIR, 'navitem.html'), ** kwargs ) [source] Navigation item without dropdown items. Parameters: label : str, default='' template : str, default='directory/navitem.html' By default, this is a file stored in the directory of the current file.","title":"hemlock.tools.Navitem"},{"location":"navbar/#methods_2","text":"render ( self ) [source] Returns: rendered : bs4.BeautifulSoup Copy of self.body .","title":"Methods"},{"location":"navbar/#hemlocktoolsnavitemdd","text":"class hemlock.tools. Navitemdd ( label='', dropdownitems=[], template=os.path.join(DIR, 'navitemdd.html'), **kwargs ) [source] Navigation item with dropdown items. Parameters: label : str, default='' dropdownitems : list of hemlock.tools.Dropdownitem template : str, default='directory/navitemdd.html' By default, this is a file stored in the directory of the current file.","title":"hemlock.tools.Navitemdd"},{"location":"navbar/#methods_3","text":"render ( self ) [source] Returns: rendered : bs4.BeautifulSoup A copy of self.body with rendered dropdown items.","title":"Methods"},{"location":"navbar/#hemlocktoolsdropdownitem","text":"class hemlock.tools. Dropdownitem ( label='', template=os.path.join(DIR, 'dropdownitem.html' ), **kwargs ) [source] Parameters: label : str, default='' template : str, default='directory/dropdownitem.html' By default, this is a file stored in the directory of the current file.","title":"hemlock.tools.Dropdownitem"},{"location":"navbar/#methods_4","text":"render ( self ) [source] Returns: rendered : bs4.BeautifulSoup Copy of self.body .","title":"Methods"},{"location":"page/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Page The survey 'flow' is: Compile. Execute a page's compile functions. By default, a page's first compile function runs its questions' compile methods in index order. Render. Render the page for the participant and wait for them to respond. Record response. Record the participant's response to every question on the page. This sets the response attribute of the questions. Validate. When the participant attempts to submit the page, validate the responses. As with the compile method, the validate method executes a page's validate functions in index order. By default, a page's first validate function runs its questions' validate methods in index order. Record data. Record the data associated with the participant's responses to every question on the page. This sets the data attribute of the questions. Submit. Execute the page's submit functions. By default, a page's first submit function runs its questions' submit methods in index order. Navigate. If the page has a navigate function, create a new branch originating from this page. hemlock. compile_questions def hemlock. compile_questions ( page ) [source] Execute the page's questions' compile methods in index order. Parameters: page : hemlock.Page hemlock. validate_questions def hemlock. validate_questions ( page ) [source] Execute the page's questions' validate methods in index order. Parameters: page : hemlock.Page hemlock. submit_questions def hemlock. submit_questions ( page ) [source] Execute the page's questions' submit methods in index order. Parameters: page : hemlock.Page hemlock. debug_questions def hemlock. debug_questions ( driver, page ) [source] Execute the page's questions' debug methods in random order. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page hemlock. navigate def hemlock. navigate ( driver, page, p_forward=0.8, p_back=0.1, sleep_time=3 ) [source] Randomly navigate forward or backward, or refresh the page. By default, it is executed after the default page debug function. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page p_forward : float, default=.8 Probability of clicking the forward button. p_back : float, default=.1 Probability of clicking the back button. sleep_time : float, default=3 Number of seconds to sleep if there is no forward or back button on the page. Notes The probability of refreshing the page is 1-p_forward-p_back . hemlock. Page class hemlock. Page ( *questions, template='hemlock/page-body.html', **kwargs ) [source] Pages are queued in a branch. A page contains a list of questions which it displays to the participant in index order. It inherits from hemlock.model.HTMLMixin . Parameters: *questions : list of hemlock.Question, default=[] Questions to be displayed on this page. template : str, default='hemlock/page-body.html' Template for the page body . Attributes: back : str or None, default=None Text of the back button. If None , no back button will appear on the page. You may also set back to True , which will set the text to '<<' . banner : str or bs4.Tag, default=hemlock banner Banner at the bottom of the page. cache_compile : bool, default=False Indicates that this page should cache the result of its compile functions. Specifically, it removes all compile functions and the compile worker from the page self self._compile is called. direction_from : str or None, default=None Direction in which the participant navigated from this page. Possible values are 'back' , 'invalid' , or 'forward' . direction_to : str or None, default=None Direction in which the participant navigated to this page. Possible values are 'back' , 'invalid' , and 'forward' . error : str or None, default=None Text of the page error message. forward : str or None, default='>>' Text of the forward button. If None , no forward button will appear on the page. You may also set forward to True , which will set the text to '>>' . g : dict, default={} Dictionary of miscellaneous objects. index : int or None, default=None Order in which this page appears in its branch's page queue. navbar : sqlalchemy_mutablesoup.MutableSoupType Navigation bar. terminal : bool, default=False Indicates that the survey terminates on this page. viewed : bool, default=False Indicates that the participant has viewed this page. Relationships: part : hemlock.Participant or None, default=None Participant to which this page belongs. Read only; derived from self. branch . branch : hemlock.Branch or None, default=None Branch to which this page belongs. next_branch : hemlock.Branch or None, default=None Branch which originated from this page. This is automatically set when this page runs its navigate function. back_to : hemlock.Page or None Page to which this page navigates when going back. If None , this page navigates back to the previous page. forward_to : hemlock.Page or None Page to which this page navigates when going forward. If None , this page navigates to the next page. embedded : list of hemlock.Embedded, default=[] List of embedded data elements. timer : hemlock.Timer or None, default=hemlock.Timer Tracks timing data for this page. 1. Timer can be set as a Timer object. 2. Setting timer to a str or None sets the timer object variable. 3. Setting timer to a tuple sets the timer object variable and data rows. 4. Setting timer to a dict sets the timer object attributes. The dict maps attribute names to values. questions : list of hemlock.Question, default=[] List of questions which this page displays to its participant. data_elements : list of hemlock.DataElement List of data elements which belong to this page; in order, self. timer , self.embedded , self.questions . compile : list of hemlock.Compile List of compile functions; run before the page is rendered. The default page compile function runs its questions' compile functions in index order. compile_worker : hemlock.Worker or None, default=None Worker which sends the compile functions to a Redis queue. validate : list of hemlock.Validate List of validate functions; run to validate participant responses. The default page validate function runs its questions' validate functions in index order. validate_worker : hemlock.Worker or None, default=None Worker which sends the validate functions to a Redis queue. submit : list of hemlock.Submit List of submit functions; run after participant responses have been validated. The default submit function runs its questions' submit functions in index order. submit_worker : hemlock.Worker or None, default=None Worker which sends the submit functions to a Redis queue. navigate : hemlock.Navigate or None, default=None Navigate function which returns a new branch originating from this page. navigate_worker : hemlock.Worker Worker which sends the navigate function to a Redis queue. debug_functions : list of hemlock.Debug List of debug functions; run during debugging. The default debug function runs its questions' debug functions in random order. Examples from hemlock import Page , push_app_context app = push_app_context () Page ( Label ( '<p>Hello World</p>' )) . preview () Methods clear_error ( self ) [source] Clear the error message from this page and all of its questions. Returns: self : hemlock.Page clear_response ( self ) [source] Clear the response from all of this page's questions. Returns: self : hemlock.Page first_page ( self ) [source] Returns: is_first_page : bool Indicator that this is the first page in its participant's survey. is_valid ( self ) [source] Returns: valid : bool Indicator that all of the participant's responses are valid. That is, that there are no error messages on the page or any of its questions. preview ( self, driver=None ) [source] Preview the page in a browser window. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver or None, default=None Driver to preview page debugging. If None , the page will be opened in a web browser. Returns: self : hemlock.Page Notes If running in WSL, first specify the distribution as an environment variable. For example, if running in Ubuntu: $ export WSL_DISTRIBUTION = Ubuntu This method does not run the compile functions. view_nav ( self, indent=0 ) [source] Print the navigation starting at this page for debugging purposes. Parameters: indent : int, default=0 Starting indentation. Returns: self : hemlock.Page","title":"Page"},{"location":"page/#page","text":"The survey 'flow' is: Compile. Execute a page's compile functions. By default, a page's first compile function runs its questions' compile methods in index order. Render. Render the page for the participant and wait for them to respond. Record response. Record the participant's response to every question on the page. This sets the response attribute of the questions. Validate. When the participant attempts to submit the page, validate the responses. As with the compile method, the validate method executes a page's validate functions in index order. By default, a page's first validate function runs its questions' validate methods in index order. Record data. Record the data associated with the participant's responses to every question on the page. This sets the data attribute of the questions. Submit. Execute the page's submit functions. By default, a page's first submit function runs its questions' submit methods in index order. Navigate. If the page has a navigate function, create a new branch originating from this page.","title":"Page"},{"location":"page/#hemlockcompile_questions","text":"def hemlock. compile_questions ( page ) [source] Execute the page's questions' compile methods in index order. Parameters: page : hemlock.Page","title":"hemlock.compile_questions"},{"location":"page/#hemlockvalidate_questions","text":"def hemlock. validate_questions ( page ) [source] Execute the page's questions' validate methods in index order. Parameters: page : hemlock.Page","title":"hemlock.validate_questions"},{"location":"page/#hemlocksubmit_questions","text":"def hemlock. submit_questions ( page ) [source] Execute the page's questions' submit methods in index order. Parameters: page : hemlock.Page","title":"hemlock.submit_questions"},{"location":"page/#hemlockdebug_questions","text":"def hemlock. debug_questions ( driver, page ) [source] Execute the page's questions' debug methods in random order. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page","title":"hemlock.debug_questions"},{"location":"page/#hemlocknavigate","text":"def hemlock. navigate ( driver, page, p_forward=0.8, p_back=0.1, sleep_time=3 ) [source] Randomly navigate forward or backward, or refresh the page. By default, it is executed after the default page debug function. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver page : hemlock.Page p_forward : float, default=.8 Probability of clicking the forward button. p_back : float, default=.1 Probability of clicking the back button. sleep_time : float, default=3 Number of seconds to sleep if there is no forward or back button on the page.","title":"hemlock.navigate"},{"location":"page/#notes","text":"The probability of refreshing the page is 1-p_forward-p_back .","title":"Notes"},{"location":"page/#hemlockpage","text":"class hemlock. Page ( *questions, template='hemlock/page-body.html', **kwargs ) [source] Pages are queued in a branch. A page contains a list of questions which it displays to the participant in index order. It inherits from hemlock.model.HTMLMixin . Parameters: *questions : list of hemlock.Question, default=[] Questions to be displayed on this page. template : str, default='hemlock/page-body.html' Template for the page body . Attributes: back : str or None, default=None Text of the back button. If None , no back button will appear on the page. You may also set back to True , which will set the text to '<<' . banner : str or bs4.Tag, default=hemlock banner Banner at the bottom of the page. cache_compile : bool, default=False Indicates that this page should cache the result of its compile functions. Specifically, it removes all compile functions and the compile worker from the page self self._compile is called. direction_from : str or None, default=None Direction in which the participant navigated from this page. Possible values are 'back' , 'invalid' , or 'forward' . direction_to : str or None, default=None Direction in which the participant navigated to this page. Possible values are 'back' , 'invalid' , and 'forward' . error : str or None, default=None Text of the page error message. forward : str or None, default='>>' Text of the forward button. If None , no forward button will appear on the page. You may also set forward to True , which will set the text to '>>' . g : dict, default={} Dictionary of miscellaneous objects. index : int or None, default=None Order in which this page appears in its branch's page queue. navbar : sqlalchemy_mutablesoup.MutableSoupType Navigation bar. terminal : bool, default=False Indicates that the survey terminates on this page. viewed : bool, default=False Indicates that the participant has viewed this page. Relationships: part : hemlock.Participant or None, default=None Participant to which this page belongs. Read only; derived from self. branch . branch : hemlock.Branch or None, default=None Branch to which this page belongs. next_branch : hemlock.Branch or None, default=None Branch which originated from this page. This is automatically set when this page runs its navigate function. back_to : hemlock.Page or None Page to which this page navigates when going back. If None , this page navigates back to the previous page. forward_to : hemlock.Page or None Page to which this page navigates when going forward. If None , this page navigates to the next page. embedded : list of hemlock.Embedded, default=[] List of embedded data elements. timer : hemlock.Timer or None, default=hemlock.Timer Tracks timing data for this page. 1. Timer can be set as a Timer object. 2. Setting timer to a str or None sets the timer object variable. 3. Setting timer to a tuple sets the timer object variable and data rows. 4. Setting timer to a dict sets the timer object attributes. The dict maps attribute names to values. questions : list of hemlock.Question, default=[] List of questions which this page displays to its participant. data_elements : list of hemlock.DataElement List of data elements which belong to this page; in order, self. timer , self.embedded , self.questions . compile : list of hemlock.Compile List of compile functions; run before the page is rendered. The default page compile function runs its questions' compile functions in index order. compile_worker : hemlock.Worker or None, default=None Worker which sends the compile functions to a Redis queue. validate : list of hemlock.Validate List of validate functions; run to validate participant responses. The default page validate function runs its questions' validate functions in index order. validate_worker : hemlock.Worker or None, default=None Worker which sends the validate functions to a Redis queue. submit : list of hemlock.Submit List of submit functions; run after participant responses have been validated. The default submit function runs its questions' submit functions in index order. submit_worker : hemlock.Worker or None, default=None Worker which sends the submit functions to a Redis queue. navigate : hemlock.Navigate or None, default=None Navigate function which returns a new branch originating from this page. navigate_worker : hemlock.Worker Worker which sends the navigate function to a Redis queue. debug_functions : list of hemlock.Debug List of debug functions; run during debugging. The default debug function runs its questions' debug functions in random order.","title":"hemlock.Page"},{"location":"page/#examples","text":"from hemlock import Page , push_app_context app = push_app_context () Page ( Label ( '<p>Hello World</p>' )) . preview ()","title":"Examples"},{"location":"page/#methods","text":"clear_error ( self ) [source] Clear the error message from this page and all of its questions. Returns: self : hemlock.Page clear_response ( self ) [source] Clear the response from all of this page's questions. Returns: self : hemlock.Page first_page ( self ) [source] Returns: is_first_page : bool Indicator that this is the first page in its participant's survey. is_valid ( self ) [source] Returns: valid : bool Indicator that all of the participant's responses are valid. That is, that there are no error messages on the page or any of its questions. preview ( self, driver=None ) [source] Preview the page in a browser window. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver or None, default=None Driver to preview page debugging. If None , the page will be opened in a web browser. Returns: self : hemlock.Page","title":"Methods"},{"location":"page/#notes_1","text":"If running in WSL, first specify the distribution as an environment variable. For example, if running in Ubuntu: $ export WSL_DISTRIBUTION = Ubuntu This method does not run the compile functions. view_nav ( self, indent=0 ) [source] Print the navigation starting at this page for debugging purposes. Parameters: indent : int, default=0 Starting indentation. Returns: self : hemlock.Page","title":"Notes"},{"location":"participant/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Participant hemlock. Participant class hemlock. Participant ( **kwargs ) [source] The Participant class stores data for an individual survey participant and handles navigation for that participant. Inherits from hemlock.models.Base . Attributes: completed : bool, default=False Indicates that the participant has completed the survey. end_time : datetime.datetime Last time the participant submitted a page. g : dict, default={} Dictionary of miscellaneous objects. meta : dict, default={} Participant metadata, such as IP address. start_time : datetime.datetime Time at which the participant started he survey. status : str, default='InProgress' Participant's current status; 'InProgress' , 'TimedOut' , or 'Completed' . Read only; derived from self.completed and self.time_expired . time_expired : bool, default=False Indicates that the participant has exceeded their allotted time for the survey. updated : bool, default=True Indicates that the participant's data was updated after the last time their data was stored; if True , the participant's data will be re-stored when data are downloaded. Relationships: branch_stack : list of hemlock.Branch The participant's stack of branches. current_branch : hemlock.Branch Participant's current branch (head of self.branch_stack ). current_page : hemlock.Page Participant's current page (head of self.current_branch ). pages : list of hemlock.Page Pages belonging to the participant. embedded : list of hemlock.Embedded Embedded data elements belonging to the participant. data_elements : list of hemlock.DataElement List of all data elements belonging to the participant, ordered by id . Examples from hemlock import Branch , Label , Page , Participant , push_app_context def start (): return Branch ( Page ( Label ( '<p>Hello World</p>' ))) app = push_app_context () part = Participant . gen_test_participant ( start ) part . current_page . preview () Methods back ( self, back_to=None ) [source] Navigate back for debugging purposes. Parameters: back_to : hemlock.Page or None, default=None Navigate back to this page; if None , navigate back one page. Returns: self : hemlock.Participant forward ( self, forward_to=None ) [source] Navigate forward for debugging purposes. Parameters: forward_to : hemlock.Page or None, default=None Navigate forward to this page; if None , navigate forward one page. Returns: self : hemlock.Participant gen_test_participant ( gen_root=None ) [source] Generate a test participant for debugging purposes. Parameters: gen_root : callable or None, default=None Function to generate the root branch of the participant's tree. This should return a hemlock.Branch . Returns: part : hemlock.Participant get_data ( self ) [source] Returns: df : hemlock.models.private.DataFrame Data associated with the participant. Notes Data elements are added to the dataframe in the order in which they were created (i.e. by id). This is not necessarily the order in which they appeared to the Participant. Examples get_meta ( self ) [source] This is where it gets meta. Returns: meta : dict Participant's metadata, including the ID, end time, start time, and current status. view_nav ( self ) [source] View participant's branch stack. Returns: self : hemlock.Participant","title":"Participant"},{"location":"participant/#participant","text":"","title":"Participant"},{"location":"participant/#hemlockparticipant","text":"class hemlock. Participant ( **kwargs ) [source] The Participant class stores data for an individual survey participant and handles navigation for that participant. Inherits from hemlock.models.Base . Attributes: completed : bool, default=False Indicates that the participant has completed the survey. end_time : datetime.datetime Last time the participant submitted a page. g : dict, default={} Dictionary of miscellaneous objects. meta : dict, default={} Participant metadata, such as IP address. start_time : datetime.datetime Time at which the participant started he survey. status : str, default='InProgress' Participant's current status; 'InProgress' , 'TimedOut' , or 'Completed' . Read only; derived from self.completed and self.time_expired . time_expired : bool, default=False Indicates that the participant has exceeded their allotted time for the survey. updated : bool, default=True Indicates that the participant's data was updated after the last time their data was stored; if True , the participant's data will be re-stored when data are downloaded. Relationships: branch_stack : list of hemlock.Branch The participant's stack of branches. current_branch : hemlock.Branch Participant's current branch (head of self.branch_stack ). current_page : hemlock.Page Participant's current page (head of self.current_branch ). pages : list of hemlock.Page Pages belonging to the participant. embedded : list of hemlock.Embedded Embedded data elements belonging to the participant. data_elements : list of hemlock.DataElement List of all data elements belonging to the participant, ordered by id .","title":"hemlock.Participant"},{"location":"participant/#examples","text":"from hemlock import Branch , Label , Page , Participant , push_app_context def start (): return Branch ( Page ( Label ( '<p>Hello World</p>' ))) app = push_app_context () part = Participant . gen_test_participant ( start ) part . current_page . preview ()","title":"Examples"},{"location":"participant/#methods","text":"back ( self, back_to=None ) [source] Navigate back for debugging purposes. Parameters: back_to : hemlock.Page or None, default=None Navigate back to this page; if None , navigate back one page. Returns: self : hemlock.Participant forward ( self, forward_to=None ) [source] Navigate forward for debugging purposes. Parameters: forward_to : hemlock.Page or None, default=None Navigate forward to this page; if None , navigate forward one page. Returns: self : hemlock.Participant gen_test_participant ( gen_root=None ) [source] Generate a test participant for debugging purposes. Parameters: gen_root : callable or None, default=None Function to generate the root branch of the participant's tree. This should return a hemlock.Branch . Returns: part : hemlock.Participant get_data ( self ) [source] Returns: df : hemlock.models.private.DataFrame Data associated with the participant.","title":"Methods"},{"location":"participant/#notes","text":"Data elements are added to the dataframe in the order in which they were created (i.e. by id). This is not necessarily the order in which they appeared to the Participant.","title":"Notes"},{"location":"participant/#examples_1","text":"get_meta ( self ) [source] This is where it gets meta. Returns: meta : dict Participant's metadata, including the ID, end time, start time, and current status. view_nav ( self ) [source] View participant's branch stack. Returns: self : hemlock.Participant","title":"Examples"},{"location":"question/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Questions hemlock.Question and hemlock.ChoiceQuestion are 'question skeletons'; most useful when fleshed out. See section on question polymorphs. hemlock. Question class hemlock. Question ( label='', template=None, **kwargs ) [source] Base object for questions. Questions are displayed on their page in index order. It inherits from hemlock.models.Data and hemlock.models.HTMLMixin . Parameters: label : str or bs4.BeautifulSoup, default='' Question label. template : str, default='form-group.html' Template for the question body . Attributes: default : sqlalchemy_mutable.MutableType Default question response. error : str or None, default=None Text of the question error message. label : str or None, default=None Question label. response : sqlalchemy_mutable.MutableType Participant's response. Relationships: part : hemlock.Participant or None The participant to which this question belongs. Derived from self.page . branch : hemlock.Branch or None The branch to which this question belongs. Derived from self.page . page : hemlock.Page or None The page to which this question belongs. compile : list of hemlock.Compile, default=[] List of compile functions; run before the question is rendered. validate : list of hemlock.Validate, default=[] List of validate functions; run to validate the participant's response. submit : list of hemlock.Submit, default=[] List of submit functions; run after the participant's responses have been validated for all questions on a page. debug : list of hemlock.Debug, default=[] List of debug functions; run during debugging. The default debug function is unique to the question type. Methods clear_error ( self ) [source] Clear the error message. Returns: self : hemlock.Question clear_response ( self ) [source] Clear the response. Returns: self : hemlock.Question hemlock. ChoiceQuestion class hemlock. ChoiceQuestion ( label='', choices=[], template=None, **kwargs ) [source] A question which contains choices. Inherits from hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Question label. choices : list, default=[] Choices which belong to this question. List items are usually hemlock.Choice or hemlock.Option . template : str or None, default=None Template for the question body. Attributes: choices : list, default=[] Set from choices parameter. choice_cls : class, default=hemlock.Choice Class of the choices in the choices list. multiple : bool, default=False Indicates that the participant can select multiple choices. Notes choices can be set using the following formats: 1. list of choice objects. 2. list of str , treated as choice labels. 3. list of (choice label, value) tuples. 4. list of (choice label, value, name) tuples. 5. list of dictionaries with choice keyword arguments.","title":"Question"},{"location":"question/#questions","text":"hemlock.Question and hemlock.ChoiceQuestion are 'question skeletons'; most useful when fleshed out. See section on question polymorphs.","title":"Questions"},{"location":"question/#hemlockquestion","text":"class hemlock. Question ( label='', template=None, **kwargs ) [source] Base object for questions. Questions are displayed on their page in index order. It inherits from hemlock.models.Data and hemlock.models.HTMLMixin . Parameters: label : str or bs4.BeautifulSoup, default='' Question label. template : str, default='form-group.html' Template for the question body . Attributes: default : sqlalchemy_mutable.MutableType Default question response. error : str or None, default=None Text of the question error message. label : str or None, default=None Question label. response : sqlalchemy_mutable.MutableType Participant's response. Relationships: part : hemlock.Participant or None The participant to which this question belongs. Derived from self.page . branch : hemlock.Branch or None The branch to which this question belongs. Derived from self.page . page : hemlock.Page or None The page to which this question belongs. compile : list of hemlock.Compile, default=[] List of compile functions; run before the question is rendered. validate : list of hemlock.Validate, default=[] List of validate functions; run to validate the participant's response. submit : list of hemlock.Submit, default=[] List of submit functions; run after the participant's responses have been validated for all questions on a page. debug : list of hemlock.Debug, default=[] List of debug functions; run during debugging. The default debug function is unique to the question type.","title":"hemlock.Question"},{"location":"question/#methods","text":"clear_error ( self ) [source] Clear the error message. Returns: self : hemlock.Question clear_response ( self ) [source] Clear the response. Returns: self : hemlock.Question","title":"Methods"},{"location":"question/#hemlockchoicequestion","text":"class hemlock. ChoiceQuestion ( label='', choices=[], template=None, **kwargs ) [source] A question which contains choices. Inherits from hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Question label. choices : list, default=[] Choices which belong to this question. List items are usually hemlock.Choice or hemlock.Option . template : str or None, default=None Template for the question body. Attributes: choices : list, default=[] Set from choices parameter. choice_cls : class, default=hemlock.Choice Class of the choices in the choices list. multiple : bool, default=False Indicates that the participant can select multiple choices.","title":"hemlock.ChoiceQuestion"},{"location":"question/#notes","text":"choices can be set using the following formats: 1. list of choice objects. 2. list of str , treated as choice labels. 3. list of (choice label, value) tuples. 4. list of (choice label, value, name) tuples. 5. list of dictionaries with choice keyword arguments.","title":"Notes"},{"location":"random/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Randomization tools hemlock.tools. key def hemlock.tools. key ( len_=90 ) [source] Parameters: len_ : int, default=90 Length of the key to generate. Returns: key : str Randomly generated key of ascii letters and digits of specificed length. Notes The first character is a letter. This allows you to use key to generate strongly random id's for html elements. (Html element id's cannot start with a digit.) Examples from hemlock import tools tools . key ( 10 ) Out: gpGmZuRfF7 hemlock.tools. Randomizer class hemlock.tools. Randomizer ( elements, r=1, combination=True ) [source] Evenly randomizes over a set of elements. Parameters: elements : iterable Set of elements over which to randomize. r : int, default=1 Size of the subset of elements to select. combination : bool, default=True Indicates randomization over combinations of the elements, as opposed to permutations. Attributes: elements : iterable Set from the elements parameter. Examples from hemlock.tools import Randomizer elements = ( 'world' , 'moon' , 'star' ) randomizer = Randomizer ( elements , r = 2 , combination = False ) randomizer . next () Out: ('moon', 'world') Methods next ( self ) [source] Returns: subset : Selected subset of elements. hemlock.tools. Assigner class hemlock.tools. Assigner ( conditions ) [source] Evenly assigns participants to conditions. Inherits from hemlock.tools.Randomizer . Parameters: conditions : dict Maps condition variable name to iterable of possible assignments. Attributes: keys : iterable Condition variable names. elements : iterable All possible combinations of condition values to which a participant may be assigned. Examples from hemlock import Participant , push_app_context from hemlock.tools import Assigner push_app_context () part = Participant . gen_test_participant () conditions = { 'Treatment' : ( 0 , 1 ), 'Level' : ( 'low' , 'med' , 'high' )} assigner = Assigner ( conditions ) assigner . next () Out: {'Treatment': 1, 'Level': 'low'} In: [( e . var , e . data ) for e in part . embedded ] Out: [('Treatment', 0), ('Level', 'low')] Methods next ( self ) [source] Assigns the participant to a condition. The condition assigment updates the participant's metadata. Returns: assignment : dict Maps condition variable names to assigned conditions.","title":"Randomization"},{"location":"random/#randomization-tools","text":"","title":"Randomization tools"},{"location":"random/#hemlocktoolskey","text":"def hemlock.tools. key ( len_=90 ) [source] Parameters: len_ : int, default=90 Length of the key to generate. Returns: key : str Randomly generated key of ascii letters and digits of specificed length.","title":"hemlock.tools.key"},{"location":"random/#notes","text":"The first character is a letter. This allows you to use key to generate strongly random id's for html elements. (Html element id's cannot start with a digit.)","title":"Notes"},{"location":"random/#examples","text":"from hemlock import tools tools . key ( 10 ) Out: gpGmZuRfF7","title":"Examples"},{"location":"random/#hemlocktoolsrandomizer","text":"class hemlock.tools. Randomizer ( elements, r=1, combination=True ) [source] Evenly randomizes over a set of elements. Parameters: elements : iterable Set of elements over which to randomize. r : int, default=1 Size of the subset of elements to select. combination : bool, default=True Indicates randomization over combinations of the elements, as opposed to permutations. Attributes: elements : iterable Set from the elements parameter.","title":"hemlock.tools.Randomizer"},{"location":"random/#examples_1","text":"from hemlock.tools import Randomizer elements = ( 'world' , 'moon' , 'star' ) randomizer = Randomizer ( elements , r = 2 , combination = False ) randomizer . next () Out: ('moon', 'world')","title":"Examples"},{"location":"random/#methods","text":"next ( self ) [source] Returns: subset : Selected subset of elements.","title":"Methods"},{"location":"random/#hemlocktoolsassigner","text":"class hemlock.tools. Assigner ( conditions ) [source] Evenly assigns participants to conditions. Inherits from hemlock.tools.Randomizer . Parameters: conditions : dict Maps condition variable name to iterable of possible assignments. Attributes: keys : iterable Condition variable names. elements : iterable All possible combinations of condition values to which a participant may be assigned.","title":"hemlock.tools.Assigner"},{"location":"random/#examples_2","text":"from hemlock import Participant , push_app_context from hemlock.tools import Assigner push_app_context () part = Participant . gen_test_participant () conditions = { 'Treatment' : ( 0 , 1 ), 'Level' : ( 'low' , 'med' , 'high' )} assigner = Assigner ( conditions ) assigner . next () Out: {'Treatment': 1, 'Level': 'low'} In: [( e . var , e . data ) for e in part . embedded ] Out: [('Treatment', 0), ('Level', 'low')]","title":"Examples"},{"location":"random/#methods_1","text":"next ( self ) [source] Assigns the participant to a condition. The condition assigment updates the participant's metadata. Returns: assignment : dict Maps condition variable names to assigned conditions.","title":"Methods"},{"location":"range/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Range slider hemlock. Range class hemlock. Range ( label='', template='hemlock/range.html', **kwargs ) [source] Range sliders can be dragged between minimum and maximum values in step increments. Inherits from hemlock.InputBase and hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Range label. template : str, default='hemlock/range.html' Template for the range body. Attributes: max : float, default=100 Maximum value of the range slider. min : float, default=0 Minimum value of the range slider. step : float, default=1 Increments in which the range slider steps. Notes Ranges have a default javascript which displays the value of the range slider to participants. This will be appended to any js and extra_js arguments passed to the constructor. Examples from hemlock import Range , Page , push_app_context app = push_app_context () Page ( Range ( '<p>This is a range slider.</p>' )) . preview ()","title":"Range"},{"location":"range/#range-slider","text":"","title":"Range slider"},{"location":"range/#hemlockrange","text":"class hemlock. Range ( label='', template='hemlock/range.html', **kwargs ) [source] Range sliders can be dragged between minimum and maximum values in step increments. Inherits from hemlock.InputBase and hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Range label. template : str, default='hemlock/range.html' Template for the range body. Attributes: max : float, default=100 Maximum value of the range slider. min : float, default=0 Minimum value of the range slider. step : float, default=1 Increments in which the range slider steps.","title":"hemlock.Range"},{"location":"range/#notes","text":"Ranges have a default javascript which displays the value of the range slider to participants. This will be appended to any js and extra_js arguments passed to the constructor.","title":"Notes"},{"location":"range/#examples","text":"from hemlock import Range , Page , push_app_context app = push_app_context () Page ( Range ( '<p>This is a range slider.</p>' )) . preview ()","title":"Examples"},{"location":"security/","text":"Security features Heroku and Amazon Web Services The location of your data depends on your method of deployment. In the tutorial, I suggest deploying through heroku, which in turn deploys your application using AWS cloud computing. Both have extensive security infrastructures. Read more about heroku security and AWS security . Secure Sockets Layer (SSL) certification Hemlock-CLI's hlk production command, which scales your application in a production environment before distribution to participants, automatically creates an SSL certificate for your application. Hemlock uses flask talisman , developed by Google Cloud Platform, to force HTTPS requests. Hemlock's default content security policy allows application content from only the following third parties: Google API JQuery JSDeliver Bootstrap Password protection Hemlock users should password protect their applications before distribution to participants. This can be done simply with: from hemlock import settings settings [ 'password' ] = '<my-secret-password>' Hemlock will encrypt your password with the werkzeug password hash utility . Note. Be sure not to have your password set in a public code repository while your application is in production. Cross-site request forgery (CSRF) protection Hemlock uses flask download button to protect your data from CSRF attacks. This package employs a standard CSRF prevention technique; it stores a strongly random temporary CSRF authentication token in your browser's session, then authenticates the token when you issue a request to download your data.","title":"Security"},{"location":"security/#security-features","text":"","title":"Security features"},{"location":"security/#heroku-and-amazon-web-services","text":"The location of your data depends on your method of deployment. In the tutorial, I suggest deploying through heroku, which in turn deploys your application using AWS cloud computing. Both have extensive security infrastructures. Read more about heroku security and AWS security .","title":"Heroku and Amazon Web Services"},{"location":"security/#secure-sockets-layer-ssl-certification","text":"Hemlock-CLI's hlk production command, which scales your application in a production environment before distribution to participants, automatically creates an SSL certificate for your application. Hemlock uses flask talisman , developed by Google Cloud Platform, to force HTTPS requests. Hemlock's default content security policy allows application content from only the following third parties: Google API JQuery JSDeliver Bootstrap","title":"Secure Sockets Layer (SSL) certification"},{"location":"security/#password-protection","text":"Hemlock users should password protect their applications before distribution to participants. This can be done simply with: from hemlock import settings settings [ 'password' ] = '<my-secret-password>' Hemlock will encrypt your password with the werkzeug password hash utility . Note. Be sure not to have your password set in a public code repository while your application is in production.","title":"Password protection"},{"location":"security/#cross-site-request-forgery-csrf-protection","text":"Hemlock uses flask download button to protect your data from CSRF attacks. This package employs a standard CSRF prevention technique; it stores a strongly random temporary CSRF authentication token in your browser's session, then authenticates the token when you issue a request to download your data.","title":"Cross-site request forgery (CSRF) protection"},{"location":"select/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Select (dropdown) hemlock. Select class hemlock. Select ( label='', choices=[], template='hemlock/select.html', ** kwargs ) [source] Select questions allow participants to select one or more options from a dropdown menu. Inherits from hemlock.InputGroup and hemlock.ChoiceQuestion . Its default debug function is click_choices . Parameters: label : str or bs4.BeautifulSoup, default='' Select question label. choices : list of hemlock.Option, str, tuple, or dict, default=[] Options which participants can select. template : str, default='hemlock/select.html' Template for the select body. Attributes: align : str, default='left' Choice alignment; 'left' , 'center' , or 'right' . choices : list of hemlock.Option Set for the choices parameter. multiple : bool, default=False Indicates that the participant may select multiple choices. select : bs4.Tag <select> tag. size : int or None, default=None Number of rows of choices to display. Examples from hemlock import Page , Select , Option , push_app_context app = push_app_context () Page ( Select ( '<p>Select one.</p>' , [ 'World' , 'Moon' , 'Star' ])) . preview ()","title":"Select"},{"location":"select/#select-dropdown","text":"","title":"Select (dropdown)"},{"location":"select/#hemlockselect","text":"class hemlock. Select ( label='', choices=[], template='hemlock/select.html', ** kwargs ) [source] Select questions allow participants to select one or more options from a dropdown menu. Inherits from hemlock.InputGroup and hemlock.ChoiceQuestion . Its default debug function is click_choices . Parameters: label : str or bs4.BeautifulSoup, default='' Select question label. choices : list of hemlock.Option, str, tuple, or dict, default=[] Options which participants can select. template : str, default='hemlock/select.html' Template for the select body. Attributes: align : str, default='left' Choice alignment; 'left' , 'center' , or 'right' . choices : list of hemlock.Option Set for the choices parameter. multiple : bool, default=False Indicates that the participant may select multiple choices. select : bs4.Tag <select> tag. size : int or None, default=None Number of rows of choices to display.","title":"hemlock.Select"},{"location":"select/#examples","text":"from hemlock import Page , Select , Option , push_app_context app = push_app_context () Page ( Select ( '<p>Select one.</p>' , [ 'World' , 'Moon' , 'Star' ])) . preview ()","title":"Examples"},{"location":"statics/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Statics Tool for generating statics (embedded images and videos). hemlock.tools. external_css def hemlock.tools. external_css ( **attrs ) [source] Parameters: **attrs : Attribute names and values in the <link/> tag. Returns: css : str <link/> tag. Examples from hemlock import Page , push_app_context from hemlock.tools import external_css app = push_app_context () p = Page ( extra_css = external_css ( href = 'https://my-css-url' )) p . css Out: ... <link href=\"https://my-css-url\" rel=\"stylesheet\" type=\"text/css\"/> hemlock.tools. internal_css def hemlock.tools. internal_css ( style ) [source] Parameters: style : dict Maps css selector to an attributes dictionary. The attributes dictionary maps attribute names to values. Returns: css : str <style> tag. Examples from hemlock import Page , push_app_context from hemlock.tools import internal_css app = push_app_context () p = Page ( extra_css = internal_css ({ 'body' : { 'background' : 'coral' }})) p . css Out: ... <style> body {background:coral;} </style> hemlock.tools. external_js def hemlock.tools. external_js ( **attrs ) [source] Parameters: **attrs : Attribute names and values in the <script> tag. Returns: js : str <script> tag. Examples from hemlock import Page , push_app_context from hemlock.tools import external_js app = push_app_context () p = Page ( extra_js = external_js ( src = 'https://my-js-url' )) p . js Out: ... <script src=\"https://my-js-url\"></script> hemlock.tools. internal_js def hemlock.tools. internal_js ( js ) [source] Parameters: js : str Javascript code. Returns: js : str Javascript code wrapped in <script> tag. Examples from hemlock import Page , push_app_context from hemlock.tools import internal_js app = push_app_context () p = Page ( extra_js = internal_js ( ''' $( document ).ready(function() { alert('hello, world!'); }); ''' ) ) p . js Out: ... <script> $( document ).ready(function() { alert('hello, world!'); }); </script> hemlock.tools. src_from_bucket def hemlock.tools. src_from_bucket ( filename ) [source] Parameters: filename : str Name of the file in the Google bucket. Returns: src : str src html attribute which references the specified file in the Google bucket. Examples Set up a Google bucket with the appropriate CORS permissions . Set an environment variable BUCKET to the name of the bucket. $ export BUCKET=<my-bucket> Upload a file to the bucket, e.g. https://xkcd.com/2138/ and name it wanna_see_the_code.png . from hemlock import Branch , Page , Label , push_app_context from hemlock.tools import Img , src_from_bucket app = push_app_context () img = Img ( src = src_from_bucket ( 'wanna_see_the_code.png' ), align = 'center' ) . render () Page ( Label ( img )) . preview () hemlock.tools. url_from_bucket def hemlock.tools. url_from_bucket ( filename, expiration=1800, **kwargs ) [source] Parameters: filename : str Name of the file in the Google bucket. expiration : float, default=1800 Number of seconds until the url expires. **kwargs : Keyword arguments are passed to the [ generate_signed_url method] (https://cloud.google.com/storage/docs/access-control/signed-urls). Returns: signed_url : str Signed url for the file in the app's bucket. Examples Set up a Google bucket with the appropriate CORS permissions . Set an environment variable BUCKET to the name of the bucket, and GOOGLE_APPLICATION_CREDENTIALS to the name of your Google application credentials JSON file . $ export BUCKET=<my-bucket> GOOGLE_APPLICATION_CREDENTIALS=<my-credentials.json> In survey.py : from hemlock import Branch , Page , Download , route from hemlock.tools import url_from_bucket @route ( '/survey' ) def start (): filename = 'wanna_see_the_code.png' url = url_from_bucket ( filename ) return Branch ( Page ( Download ( downloads = [( url , filename )]))) In app.py : import survey from hemlock import create_app app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) Run the app locally with: $ python app.py # or python3 app.py And open your browser to http://localhost:5000/ . Click on the download button to download the file from your Google bucket. hemlock.tools. Static class hemlock.tools. Static ( template, **kwargs ) [source] Base for static objects (images and videos). Parameters: template : str Path to template file. This is not a Jinja template, as you may wish to generate html for statics outside the application context. **kwargs : Any attribute of the static object can be set by passing it as a keyword argument. Attributes: body : sqlalchemy_mutablesoup.MutableSoup Html of the static object. src_params : dict Maps url parameter names to values. These will be attached to the src html attribute when the static is rendered. Methods render ( self, tag_selector=None ) [source] Parameters: tag_selector : str CSS selector for the html tag containing the src attribute. Returns: html : str Rendered html. hemlock.tools. Img class hemlock.tools. Img ( template=os.path.join(DIR, 'img.html'), **kwargs ) [source] Static image. Parameters: template : str, default='directory/img.html' Image template. By default, this is a file stored in the directory of the current file. Attributes: align : str Image alignment; 'left' , 'center' , or 'right '. caption : str Image caption. figure : bs4.Tag <figure> tag. img : bs4.Tag <img> tag. src : str src attribute of the <img> tag. Examples from hemlock import Page , Label , push_app_context from hemlock.tools import Img app = push_app_context () img = Img ( src = 'https://imgs.xkcd.com/comics/wanna_see_the_code.png' , align = 'center' ) . render () Page ( Label ( img )) . preview () Methods render ( self ) [source] Returns: html : str Rendered image html. hemlock.tools. Vid class hemlock.tools. Vid ( template=os.path.join(DIR, 'vid.html'), **kwargs ) [source] Static video. Parameters: template : str, default='directory/vid.html' Video template. By default, this is a file stored in the directory of the current file. Attributes: iframe : bs4.Tag <iframe> tag. src : str src attribute of the <iframe> tag. Examples from hemlock import Page , Label , push_app_context from hemlock.tools import Vid app = push_app_context () vid = Vid . from_youtube ( 'https://www.youtube.com/watch?v=UbQgXeY_zi4' ) Page ( Label ( vid . render ())) . preview () Methods from_youtube ( src ) [source] Capture the YouTube video id and create an embedded src. Parameters: src : str Link to the YouTube video. Returns: vid : hemlock.tools.Vid Video object. render ( self ) [source] Returns: html : str Rendered video html.","title":"Statics"},{"location":"statics/#statics","text":"Tool for generating statics (embedded images and videos).","title":"Statics"},{"location":"statics/#hemlocktoolsexternal_css","text":"def hemlock.tools. external_css ( **attrs ) [source] Parameters: **attrs : Attribute names and values in the <link/> tag. Returns: css : str <link/> tag.","title":"hemlock.tools.external_css"},{"location":"statics/#examples","text":"from hemlock import Page , push_app_context from hemlock.tools import external_css app = push_app_context () p = Page ( extra_css = external_css ( href = 'https://my-css-url' )) p . css Out: ... <link href=\"https://my-css-url\" rel=\"stylesheet\" type=\"text/css\"/>","title":"Examples"},{"location":"statics/#hemlocktoolsinternal_css","text":"def hemlock.tools. internal_css ( style ) [source] Parameters: style : dict Maps css selector to an attributes dictionary. The attributes dictionary maps attribute names to values. Returns: css : str <style> tag.","title":"hemlock.tools.internal_css"},{"location":"statics/#examples_1","text":"from hemlock import Page , push_app_context from hemlock.tools import internal_css app = push_app_context () p = Page ( extra_css = internal_css ({ 'body' : { 'background' : 'coral' }})) p . css Out: ... <style> body {background:coral;} </style>","title":"Examples"},{"location":"statics/#hemlocktoolsexternal_js","text":"def hemlock.tools. external_js ( **attrs ) [source] Parameters: **attrs : Attribute names and values in the <script> tag. Returns: js : str <script> tag.","title":"hemlock.tools.external_js"},{"location":"statics/#examples_2","text":"from hemlock import Page , push_app_context from hemlock.tools import external_js app = push_app_context () p = Page ( extra_js = external_js ( src = 'https://my-js-url' )) p . js Out: ... <script src=\"https://my-js-url\"></script>","title":"Examples"},{"location":"statics/#hemlocktoolsinternal_js","text":"def hemlock.tools. internal_js ( js ) [source] Parameters: js : str Javascript code. Returns: js : str Javascript code wrapped in <script> tag.","title":"hemlock.tools.internal_js"},{"location":"statics/#examples_3","text":"from hemlock import Page , push_app_context from hemlock.tools import internal_js app = push_app_context () p = Page ( extra_js = internal_js ( ''' $( document ).ready(function() { alert('hello, world!'); }); ''' ) ) p . js Out: ... <script> $( document ).ready(function() { alert('hello, world!'); }); </script>","title":"Examples"},{"location":"statics/#hemlocktoolssrc_from_bucket","text":"def hemlock.tools. src_from_bucket ( filename ) [source] Parameters: filename : str Name of the file in the Google bucket. Returns: src : str src html attribute which references the specified file in the Google bucket.","title":"hemlock.tools.src_from_bucket"},{"location":"statics/#examples_4","text":"Set up a Google bucket with the appropriate CORS permissions . Set an environment variable BUCKET to the name of the bucket. $ export BUCKET=<my-bucket> Upload a file to the bucket, e.g. https://xkcd.com/2138/ and name it wanna_see_the_code.png . from hemlock import Branch , Page , Label , push_app_context from hemlock.tools import Img , src_from_bucket app = push_app_context () img = Img ( src = src_from_bucket ( 'wanna_see_the_code.png' ), align = 'center' ) . render () Page ( Label ( img )) . preview ()","title":"Examples"},{"location":"statics/#hemlocktoolsurl_from_bucket","text":"def hemlock.tools. url_from_bucket ( filename, expiration=1800, **kwargs ) [source] Parameters: filename : str Name of the file in the Google bucket. expiration : float, default=1800 Number of seconds until the url expires. **kwargs : Keyword arguments are passed to the [ generate_signed_url method] (https://cloud.google.com/storage/docs/access-control/signed-urls). Returns: signed_url : str Signed url for the file in the app's bucket.","title":"hemlock.tools.url_from_bucket"},{"location":"statics/#examples_5","text":"Set up a Google bucket with the appropriate CORS permissions . Set an environment variable BUCKET to the name of the bucket, and GOOGLE_APPLICATION_CREDENTIALS to the name of your Google application credentials JSON file . $ export BUCKET=<my-bucket> GOOGLE_APPLICATION_CREDENTIALS=<my-credentials.json> In survey.py : from hemlock import Branch , Page , Download , route from hemlock.tools import url_from_bucket @route ( '/survey' ) def start (): filename = 'wanna_see_the_code.png' url = url_from_bucket ( filename ) return Branch ( Page ( Download ( downloads = [( url , filename )]))) In app.py : import survey from hemlock import create_app app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) Run the app locally with: $ python app.py # or python3 app.py And open your browser to http://localhost:5000/ . Click on the download button to download the file from your Google bucket.","title":"Examples"},{"location":"statics/#hemlocktoolsstatic","text":"class hemlock.tools. Static ( template, **kwargs ) [source] Base for static objects (images and videos). Parameters: template : str Path to template file. This is not a Jinja template, as you may wish to generate html for statics outside the application context. **kwargs : Any attribute of the static object can be set by passing it as a keyword argument. Attributes: body : sqlalchemy_mutablesoup.MutableSoup Html of the static object. src_params : dict Maps url parameter names to values. These will be attached to the src html attribute when the static is rendered.","title":"hemlock.tools.Static"},{"location":"statics/#methods","text":"render ( self, tag_selector=None ) [source] Parameters: tag_selector : str CSS selector for the html tag containing the src attribute. Returns: html : str Rendered html.","title":"Methods"},{"location":"statics/#hemlocktoolsimg","text":"class hemlock.tools. Img ( template=os.path.join(DIR, 'img.html'), **kwargs ) [source] Static image. Parameters: template : str, default='directory/img.html' Image template. By default, this is a file stored in the directory of the current file. Attributes: align : str Image alignment; 'left' , 'center' , or 'right '. caption : str Image caption. figure : bs4.Tag <figure> tag. img : bs4.Tag <img> tag. src : str src attribute of the <img> tag.","title":"hemlock.tools.Img"},{"location":"statics/#examples_6","text":"from hemlock import Page , Label , push_app_context from hemlock.tools import Img app = push_app_context () img = Img ( src = 'https://imgs.xkcd.com/comics/wanna_see_the_code.png' , align = 'center' ) . render () Page ( Label ( img )) . preview ()","title":"Examples"},{"location":"statics/#methods_1","text":"render ( self ) [source] Returns: html : str Rendered image html.","title":"Methods"},{"location":"statics/#hemlocktoolsvid","text":"class hemlock.tools. Vid ( template=os.path.join(DIR, 'vid.html'), **kwargs ) [source] Static video. Parameters: template : str, default='directory/vid.html' Video template. By default, this is a file stored in the directory of the current file. Attributes: iframe : bs4.Tag <iframe> tag. src : str src attribute of the <iframe> tag.","title":"hemlock.tools.Vid"},{"location":"statics/#examples_7","text":"from hemlock import Page , Label , push_app_context from hemlock.tools import Vid app = push_app_context () vid = Vid . from_youtube ( 'https://www.youtube.com/watch?v=UbQgXeY_zi4' ) Page ( Label ( vid . render ())) . preview ()","title":"Examples"},{"location":"statics/#methods_2","text":"from_youtube ( src ) [source] Capture the YouTube video id and create an embedded src. Parameters: src : str Link to the YouTube video. Returns: vid : hemlock.tools.Vid Video object. render ( self ) [source] Returns: html : str Rendered video html.","title":"Methods"},{"location":"submit_functions/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Submit functions hemlock.functions.submit. correct_choices def hemlock.functions.submit. correct_choices ( question, *values ) [source] Convert the question's data to a 0-1 indicator that the participant selected the correct choice(s). Parameters: question : hemlock.ChoiceQuestion *values : Values of the correct choices. Notes If the participant can only select one choice, indicate whether the participant selected one of the correct choices. Examples from hemlock import Check , Submit as S , push_app_context app = push_app_context () check = Check ( '<p>Select the correct choice.</p>' , [ 'correct' , 'incorrect' , 'also incorrect' ], submit = S . correct_choices ( 'correct' ) ) check . response = check . choices [ 0 ] check . _submit () . data Out: 1 hemlock.functions.submit. data_type def hemlock.functions.submit. data_type ( question, new_type, *args, **kwargs ) [source] Convert the quesiton's data to a new type. If the question's data cannot be converted, it is changed to None . Parameters: question : hemlock.Question new_type : class *args, **kwargs : Arguments and keyword arguments to pass to the new_type constructor. Examples from hemlock import Input , Submit as S , push_app_context app = push_app_context () inpt = Input ( data = '1' , submit = S . data_type ( int )) inpt . _submit () inpt . data , isinstance ( inpt . data , int ) Out: (1, True) hemlock.functions.submit. match def hemlock.functions.submit. match ( question, pattern ) [source] Convert the question's data to a 0-1 indicator that the data matches the pattern. Parameters: question : hemlock.Question pattern : str Regex pattern to match. Examples from hemlock import Input , Submit as S , push_app_context app = push_app_context () inpt = Input ( data = 'hello world' , submit = S . match ( 'hello *' )) inpt . _submit () . data Out: 1","title":"Submit"},{"location":"submit_functions/#submit-functions","text":"","title":"Submit functions"},{"location":"submit_functions/#hemlockfunctionssubmitcorrect_choices","text":"def hemlock.functions.submit. correct_choices ( question, *values ) [source] Convert the question's data to a 0-1 indicator that the participant selected the correct choice(s). Parameters: question : hemlock.ChoiceQuestion *values : Values of the correct choices.","title":"hemlock.functions.submit.correct_choices"},{"location":"submit_functions/#notes","text":"If the participant can only select one choice, indicate whether the participant selected one of the correct choices.","title":"Notes"},{"location":"submit_functions/#examples","text":"from hemlock import Check , Submit as S , push_app_context app = push_app_context () check = Check ( '<p>Select the correct choice.</p>' , [ 'correct' , 'incorrect' , 'also incorrect' ], submit = S . correct_choices ( 'correct' ) ) check . response = check . choices [ 0 ] check . _submit () . data Out: 1","title":"Examples"},{"location":"submit_functions/#hemlockfunctionssubmitdata_type","text":"def hemlock.functions.submit. data_type ( question, new_type, *args, **kwargs ) [source] Convert the quesiton's data to a new type. If the question's data cannot be converted, it is changed to None . Parameters: question : hemlock.Question new_type : class *args, **kwargs : Arguments and keyword arguments to pass to the new_type constructor.","title":"hemlock.functions.submit.data_type"},{"location":"submit_functions/#examples_1","text":"from hemlock import Input , Submit as S , push_app_context app = push_app_context () inpt = Input ( data = '1' , submit = S . data_type ( int )) inpt . _submit () inpt . data , isinstance ( inpt . data , int ) Out: (1, True)","title":"Examples"},{"location":"submit_functions/#hemlockfunctionssubmitmatch","text":"def hemlock.functions.submit. match ( question, pattern ) [source] Convert the question's data to a 0-1 indicator that the data matches the pattern. Parameters: question : hemlock.Question pattern : str Regex pattern to match.","title":"hemlock.functions.submit.match"},{"location":"submit_functions/#examples_2","text":"from hemlock import Input , Submit as S , push_app_context app = push_app_context () inpt = Input ( data = 'hello world' , submit = S . match ( 'hello *' )) inpt . _submit () . data Out: 1","title":"Examples"},{"location":"textarea/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Textarea hemlock. Textarea class hemlock. Textarea ( page=None, template='hemlock/textarea.html', **kwargs ) [source] Textareas provide large text boxes for free responses. Inherits from hemlock.qpolymorphs.InputGroup and hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Textarea label. template : str, default='hemlock/textarea.html' Template for the textarea body. Attributes: textarea : bs4.Tag The <textarea> tag. Notes Textareas have a default javascript which displays the character and word count to participants. This will be appended to any js and extra_js arguments passed to the constructor. Examples from hemlock import Page , Textarea , push_app_context app = push_app_context () Page ( Textarea ( '<p>This is a textarea.</p>' )) . preview () Methods textarea_from_driver ( self, driver ) [source] Get textarea from the webdriver for debugging. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver Selenium webdriver (does not need to be Chrome ). Returns: textarea : selenium.webdriver.remote.webelement.WebElement Web element of the <textarea> tag associated with this model.","title":"Textarea"},{"location":"textarea/#textarea","text":"","title":"Textarea"},{"location":"textarea/#hemlocktextarea","text":"class hemlock. Textarea ( page=None, template='hemlock/textarea.html', **kwargs ) [source] Textareas provide large text boxes for free responses. Inherits from hemlock.qpolymorphs.InputGroup and hemlock.Question . Parameters: label : str or bs4.BeautifulSoup, default='' Textarea label. template : str, default='hemlock/textarea.html' Template for the textarea body. Attributes: textarea : bs4.Tag The <textarea> tag.","title":"hemlock.Textarea"},{"location":"textarea/#notes","text":"Textareas have a default javascript which displays the character and word count to participants. This will be appended to any js and extra_js arguments passed to the constructor.","title":"Notes"},{"location":"textarea/#examples","text":"from hemlock import Page , Textarea , push_app_context app = push_app_context () Page ( Textarea ( '<p>This is a textarea.</p>' )) . preview ()","title":"Examples"},{"location":"textarea/#methods","text":"textarea_from_driver ( self, driver ) [source] Get textarea from the webdriver for debugging. Parameters: driver : selenium.webdriver.chrome.webdriver.WebDriver Selenium webdriver (does not need to be Chrome ). Returns: textarea : selenium.webdriver.remote.webelement.WebElement Web element of the <textarea> tag associated with this model.","title":"Methods"},{"location":"utils/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Utilities hemlock.tools. chromedriver def hemlock.tools. chromedriver ( headless=False ) [source] Parameters: headless : bool, default=False Indicates whether to run Chrome in headless mode. Returns: driver : selenium.webdriver.chrome.webdriver.WebDriver Notes Chromedriver must be headless in production. When the application is in production, this method sets headless to True regardless of the parameter you pass. Examples from hemlock.tools import chromedriver driver = chromedriver () hemlock.tools. get_data def hemlock.tools. get_data ( dataframe='data' ) [source] Parameters: dataframe : str, default='data' Name of the dataframe to get; 'data' or 'meta' . Returns: data : dict Maps variable names to list of entries. May not include data from participants who are in progress. Examples from hemlock import Branch , Page , Participant , push_app_context from hemlock.tools import get_data def start (): return Branch ( Page ()) push_app_context () Participant . gen_test_participant ( start ) . completed = True get_data () Out: {'ID': [1], 'EndTime': [datetime.datetime(2020, 7, 6, 17, 11, 0, 245032)], 'StartTime': [datetime.datetime(2020, 7, 6, 17, 11, 0, 245032)], 'Status': ['Completed']} hemlock.tools. show_on_event def hemlock.tools. show_on_event ( target, condition, value, init_hidden=True, *args, **kwargs ) [source] Show the target question when a condition is met. Parameters: target : hemlock.Question The question which will be shown when the condition is met. condition : hemlock.Question The question whose value determines whether the target is shown. value : str or hemlock.Choice > If the condition is an input, the target is shown when the input value matches this value. 2. If the condition has choices, the target is shown when the choice with this value is checked. < init_hidden : bool, defualt=True Indicates that the initial state of the target should be hidden. regex : bool, default=False Indicates that the target will be shown if input value matches the string as a regular expression. event : str or None, default=None Type of event which toggles the target display. If None , this function infers the type of event based on inputs. duration : str or int, default=400 Show/hide event duration in milliseconds. Examples from hemlock import Page , Check , Input , Label , push_app_context from hemlock.tools import show_on_event app = push_app_context () race = Check ( '<p>Indicate your race.</p>' , [ 'White' , 'Black' , 'Other' ], multiple = True ) specify = Input ( '<p>Please specify.</p>' ) show_on_event ( specify , race , 'Other' ) Page ( race , specify ) . preview () name = Input ( \"<p>What's your name?</p>\" ) greet = Label ( \"<p>Hello, World!</p>\" ) show_on_event ( greet , name , '(w|W)orld' , regex = True , duration = 400 ) Page ( name , greet ) . preview () hemlock.tools. url_for def hemlock.tools. url_for ( *args, **kwargs ) [source] Attempt to return flask.url_for(*args, **kwargs) . However, this method does not exit the program when getting a url outside a request context; e.g. when debugging in a shell or notebook. Parameters: *args, **kwargs : Arguments and keyword arguments will be passed to flask.url_for . Returns: url : str Output of flask.url_for if possible; otherwise 'URL_UNAVAILABLE' .","title":"Utilities"},{"location":"utils/#utilities","text":"","title":"Utilities"},{"location":"utils/#hemlocktoolschromedriver","text":"def hemlock.tools. chromedriver ( headless=False ) [source] Parameters: headless : bool, default=False Indicates whether to run Chrome in headless mode. Returns: driver : selenium.webdriver.chrome.webdriver.WebDriver","title":"hemlock.tools.chromedriver"},{"location":"utils/#notes","text":"Chromedriver must be headless in production. When the application is in production, this method sets headless to True regardless of the parameter you pass.","title":"Notes"},{"location":"utils/#examples","text":"from hemlock.tools import chromedriver driver = chromedriver ()","title":"Examples"},{"location":"utils/#hemlocktoolsget_data","text":"def hemlock.tools. get_data ( dataframe='data' ) [source] Parameters: dataframe : str, default='data' Name of the dataframe to get; 'data' or 'meta' . Returns: data : dict Maps variable names to list of entries. May not include data from participants who are in progress.","title":"hemlock.tools.get_data"},{"location":"utils/#examples_1","text":"from hemlock import Branch , Page , Participant , push_app_context from hemlock.tools import get_data def start (): return Branch ( Page ()) push_app_context () Participant . gen_test_participant ( start ) . completed = True get_data () Out: {'ID': [1], 'EndTime': [datetime.datetime(2020, 7, 6, 17, 11, 0, 245032)], 'StartTime': [datetime.datetime(2020, 7, 6, 17, 11, 0, 245032)], 'Status': ['Completed']}","title":"Examples"},{"location":"utils/#hemlocktoolsshow_on_event","text":"def hemlock.tools. show_on_event ( target, condition, value, init_hidden=True, *args, **kwargs ) [source] Show the target question when a condition is met. Parameters: target : hemlock.Question The question which will be shown when the condition is met. condition : hemlock.Question The question whose value determines whether the target is shown. value : str or hemlock.Choice > If the condition is an input, the target is shown when the input value matches this value. 2. If the condition has choices, the target is shown when the choice with this value is checked. < init_hidden : bool, defualt=True Indicates that the initial state of the target should be hidden. regex : bool, default=False Indicates that the target will be shown if input value matches the string as a regular expression. event : str or None, default=None Type of event which toggles the target display. If None , this function infers the type of event based on inputs. duration : str or int, default=400 Show/hide event duration in milliseconds.","title":"hemlock.tools.show_on_event"},{"location":"utils/#examples_2","text":"from hemlock import Page , Check , Input , Label , push_app_context from hemlock.tools import show_on_event app = push_app_context () race = Check ( '<p>Indicate your race.</p>' , [ 'White' , 'Black' , 'Other' ], multiple = True ) specify = Input ( '<p>Please specify.</p>' ) show_on_event ( specify , race , 'Other' ) Page ( race , specify ) . preview () name = Input ( \"<p>What's your name?</p>\" ) greet = Label ( \"<p>Hello, World!</p>\" ) show_on_event ( greet , name , '(w|W)orld' , regex = True , duration = 400 ) Page ( name , greet ) . preview ()","title":"Examples"},{"location":"utils/#hemlocktoolsurl_for","text":"def hemlock.tools. url_for ( *args, **kwargs ) [source] Attempt to return flask.url_for(*args, **kwargs) . However, this method does not exit the program when getting a url outside a request context; e.g. when debugging in a shell or notebook. Parameters: *args, **kwargs : Arguments and keyword arguments will be passed to flask.url_for . Returns: url : str Output of flask.url_for if possible; otherwise 'URL_UNAVAILABLE' .","title":"hemlock.tools.url_for"},{"location":"validate_functions/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Validation functions These are built-in functions to validate a participant's response to a question. They return None if the response is valid, and an error message if the repsonse is invalid. hemlock.functions.validate. response_type def hemlock.functions.validate. response_type ( question, resp_type ) [source] Validate that the response can be converted to a given type. Parameters: question : hemlock.Question resp_type : class The required type of response. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . response_type ( float )) inpt . _validate () inpt . error Out: Please enter a number. hemlock.functions.validate. require def hemlock.functions.validate. require ( question ) [source] Require a response to this question. Parameters: question : hemlock.Question Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = None , validate = V . require ()) inpt . _validate () inpt . error Out: Please respond to this question. hemlock.functions.validate. is_in def hemlock.functions.validate. is_in ( question, valid_set, resp_type=None ) [source] Validate that the question response is in a set of valid responses. Parameters: question : hemlock.Question valid_set : iterable Set of valid responses. resp_type : class or None, default=None Type of response expected; should match the type of elements in valid_set . Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'earth' , validate = V . is_in (( 'wind' , 'fire' ))) inpt . _validate () inpt . error Out: Please enter wind or fire. hemlock.functions.validate. is_not_in def hemlock.functions.validate. is_not_in ( question, invalid_set, resp_type=None ) [source] Validate that the question response is not in a set of invalid responses. Parameters: question : hemlock.Question invalid_set : iterable Set of invalid responses. resp_type : class or None, default=None Type of response expected; should match the type of elements in invalid_set . Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'earth' , validate = V . is_not_in (( 'earth' , 'wind' , 'fire' )) ) inpt . _validate () inpt . error Out: Please do not enter earth, wind, or fire. hemlock.functions.validate. max_val def hemlock.functions.validate. max_val ( question, max_, resp_type=None ) [source] Validate that the response does not exceed a maximum value. Parameters: question : hemlock.Question max_ : Maximum value. resp_type : class or None, default=None Expected type of response. If None , the type of max will be used. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '101' , validate = V . max_val ( 100 )) inpt . _validate () inpt . error Out: Please enter a response less than 100. hemlock.functions.validate. min_val def hemlock.functions.validate. min_val ( question, min_, resp_type=None ) [source] Validate that the response does not deceed a minumum value. Parameters: question : hemlock.Question min_ : Minimum value. resp_type : class or None, default=None Expected type of response. If None , the type of min will be used. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '-1' , validate = V . min_val ( 0 )) inpt . _validate () inpt . error Out: Please enter a response greater than 0. hemlock.functions.validate. range_val def hemlock.functions.validate. range_val ( question, min_, max_, resp_type=None ) [source] Validate that the response is in a given range. Parameters: question : hemlock.Question min_ : Minimum value for the question response. max_ : Maximum value for the question response. resp_type : class or None, default=None Expected type of response. If None , the expected response type is the type of min and max , which must be of the same type. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '101' , validate = V . range_val ( 0 , 100 )) inpt . _validate () inpt . error Out: Please enter a response between 0 and 100. hemlock.functions.validate. exact_len def hemlock.functions.validate. exact_len ( question, len_ ) [source] Validates the exact length of the repsonse. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question len_ : int Required length of the response. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . exact_len ( 5 )) inpt . _validate () inpt . error Out: Please enter exactly 5 characters. hemlock.functions.validate. max_len def hemlock.functions.validate. max_len ( question, max_ ) [source] Validates the maximum length of the response. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question max_ : int Maximum length of the response. Notes A response of None is assumed to satisfy the max length validation. Use Validate.require to require a response that is not None . Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . max_len ( 5 )) inpt . _validate () inpt . error Out: Please enter at most 5 characters. hemlock.functions.validate. min_len def hemlock.functions.validate. min_len ( question, min_ ) [source] Valiadates the minimum length of the response. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question min_ : int Minimum length of the response. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . min_len ( 15 )) inpt . _validate () inpt . error Out: Please enter at least 15 characters. hemlock.functions.validate. range_len def hemlock.functions.validate. range_len ( question, min_, max_ ) [source] Validates the range of the response length. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question min_ : int Minimum response length. max_ : int Maximum response length. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . range_len ( 5 , 10 )) inpt . _validate () inpt . error Out: Please enter 5 to 10 characters. hemlock.functions.validate. exact_words def hemlock.functions.validate. exact_words ( question, nwords ) [source] Validate the exact number of words in the response. Parameters: question : hemlock.Question nwords : int Required number of words. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . exact_words ( 1 )) inpt . _validate () inpt . error Out: Please enter exactly 1 word. hemlock.functions.validate. max_words def hemlock.functions.validate. max_words ( question, max_ ) [source] Validates the maximum number of words in the response. Parameters: question : hemlock.Question max_ : int Maximum number of words. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . max_words ( 1 )) inpt . _validate () inpt . error Out: Please enter at most 1 word. hemlock.functions.validate. min_words def hemlock.functions.validate. min_words ( question, min_ ) [source] Validates the minimum number of words in the repsonse. Parameters: question : hemlock.Question min_ : int Minimum number of words. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . min_words ( 3 )) inpt . _validate () inpt . error Out: Please enter at least 3 words. hemlock.functions.validate. range_words def hemlock.functions.validate. range_words ( question, min_, max_ ) [source] Validates the number of words falls in a given range. Parameters: question : hemlock.Question min_ : int Minumum number of words. max_ : int Maximum number of words. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . range_words ( 3 , 5 )) inpt . _validate () inpt . error Out: Please enter between 3 and 5 words. hemlock.functions.validate. exact_decimals def hemlock.functions.validate. exact_decimals ( question, ndec ) [source] Validates the exact number of decimals. Parameters: question : hemlock.Question ndec : int Required number of decimals. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '1' , validate = V . exact_decimals ( 2 )) inpt . _validate () inpt . error Out: Please enter a number with exactly 2 decimals. hemlock.functions.validate. max_decimals def hemlock.functions.validate. max_decimals ( question, max_ ) [source] Validates the maximum number of decimals. Parameters: question : hemlock.Question max_ : int Maximum number of decimals. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '1.123' , validate = V . max_decimals ( 2 )) inpt . _validate () inpt . error Out: Please enter a number with at most 2 decimals. hemlock.functions.validate. min_decimals def hemlock.functions.validate. min_decimals ( question, min_ ) [source] Validates the minumum number of decimals. Parameters: question : hemlock.Question min_ : int Minumum number of decimals. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '1' , validate = V . min_decimals ( 2 )) inpt . _validate () inpt . error Out: Please enter a number with at least 2 decimals. hemlock.functions.validate. range_decimals def hemlock.functions.validate. range_decimals ( question, min_, max_ ) [source] Validates the number of decimals are in a given range. Parameters: question : hemlock.Question min_ : int Minimum number of decimals. max_ : int Maximum number of decimals. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '1.123' , validate = V . range_decimals ( 0 , 2 )) inpt . _validate () inpt . error Out: Please enter a number with 0 to 2 decimals. hemlock.functions.validate. match def hemlock.functions.validate. match ( question, pattern ) [source] Validate that the response matches the regex pattern. Parameters: question : hemlock.Question pattern : str Regex pattern to match. Examples from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . match ( 'goodbye *' )) inpt . _validate () inpt . error Out: Please enter a response with the correct pattern. hemlock.functions.validate. correct_choices def hemlock.functions.validate. correct_choices ( question, *values ) [source] Validate that selected choice(s) is correct. Parameters: question : hemlock.Question *values : Values of the correct choices. Examples from hemlock import Check , Validate as V , push_app_context app = push_app_context () check = Check ( '<p>Select the correct choice.</p>' , [ 'correct' , 'incorrect' , 'also incorrect' ], validate = V . correct_choices ( 'correct' ), ) check . response = check . choices [ 1 ] check . _validate () check . error Out: Please select the correct choice.","title":"Validate"},{"location":"validate_functions/#validation-functions","text":"These are built-in functions to validate a participant's response to a question. They return None if the response is valid, and an error message if the repsonse is invalid.","title":"Validation functions"},{"location":"validate_functions/#hemlockfunctionsvalidateresponse_type","text":"def hemlock.functions.validate. response_type ( question, resp_type ) [source] Validate that the response can be converted to a given type. Parameters: question : hemlock.Question resp_type : class The required type of response.","title":"hemlock.functions.validate.response_type"},{"location":"validate_functions/#examples","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . response_type ( float )) inpt . _validate () inpt . error Out: Please enter a number.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidaterequire","text":"def hemlock.functions.validate. require ( question ) [source] Require a response to this question. Parameters: question : hemlock.Question","title":"hemlock.functions.validate.require"},{"location":"validate_functions/#examples_1","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = None , validate = V . require ()) inpt . _validate () inpt . error Out: Please respond to this question.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidateis_in","text":"def hemlock.functions.validate. is_in ( question, valid_set, resp_type=None ) [source] Validate that the question response is in a set of valid responses. Parameters: question : hemlock.Question valid_set : iterable Set of valid responses. resp_type : class or None, default=None Type of response expected; should match the type of elements in valid_set .","title":"hemlock.functions.validate.is_in"},{"location":"validate_functions/#examples_2","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'earth' , validate = V . is_in (( 'wind' , 'fire' ))) inpt . _validate () inpt . error Out: Please enter wind or fire.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidateis_not_in","text":"def hemlock.functions.validate. is_not_in ( question, invalid_set, resp_type=None ) [source] Validate that the question response is not in a set of invalid responses. Parameters: question : hemlock.Question invalid_set : iterable Set of invalid responses. resp_type : class or None, default=None Type of response expected; should match the type of elements in invalid_set .","title":"hemlock.functions.validate.is_not_in"},{"location":"validate_functions/#examples_3","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'earth' , validate = V . is_not_in (( 'earth' , 'wind' , 'fire' )) ) inpt . _validate () inpt . error Out: Please do not enter earth, wind, or fire.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidatemax_val","text":"def hemlock.functions.validate. max_val ( question, max_, resp_type=None ) [source] Validate that the response does not exceed a maximum value. Parameters: question : hemlock.Question max_ : Maximum value. resp_type : class or None, default=None Expected type of response. If None , the type of max will be used.","title":"hemlock.functions.validate.max_val"},{"location":"validate_functions/#examples_4","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '101' , validate = V . max_val ( 100 )) inpt . _validate () inpt . error Out: Please enter a response less than 100.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidatemin_val","text":"def hemlock.functions.validate. min_val ( question, min_, resp_type=None ) [source] Validate that the response does not deceed a minumum value. Parameters: question : hemlock.Question min_ : Minimum value. resp_type : class or None, default=None Expected type of response. If None , the type of min will be used.","title":"hemlock.functions.validate.min_val"},{"location":"validate_functions/#examples_5","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '-1' , validate = V . min_val ( 0 )) inpt . _validate () inpt . error Out: Please enter a response greater than 0.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidaterange_val","text":"def hemlock.functions.validate. range_val ( question, min_, max_, resp_type=None ) [source] Validate that the response is in a given range. Parameters: question : hemlock.Question min_ : Minimum value for the question response. max_ : Maximum value for the question response. resp_type : class or None, default=None Expected type of response. If None , the expected response type is the type of min and max , which must be of the same type.","title":"hemlock.functions.validate.range_val"},{"location":"validate_functions/#examples_6","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '101' , validate = V . range_val ( 0 , 100 )) inpt . _validate () inpt . error Out: Please enter a response between 0 and 100.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidateexact_len","text":"def hemlock.functions.validate. exact_len ( question, len_ ) [source] Validates the exact length of the repsonse. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question len_ : int Required length of the response.","title":"hemlock.functions.validate.exact_len"},{"location":"validate_functions/#examples_7","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . exact_len ( 5 )) inpt . _validate () inpt . error Out: Please enter exactly 5 characters.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidatemax_len","text":"def hemlock.functions.validate. max_len ( question, max_ ) [source] Validates the maximum length of the response. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question max_ : int Maximum length of the response.","title":"hemlock.functions.validate.max_len"},{"location":"validate_functions/#notes","text":"A response of None is assumed to satisfy the max length validation. Use Validate.require to require a response that is not None .","title":"Notes"},{"location":"validate_functions/#examples_8","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . max_len ( 5 )) inpt . _validate () inpt . error Out: Please enter at most 5 characters.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidatemin_len","text":"def hemlock.functions.validate. min_len ( question, min_ ) [source] Valiadates the minimum length of the response. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question min_ : int Minimum length of the response.","title":"hemlock.functions.validate.min_len"},{"location":"validate_functions/#examples_9","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . min_len ( 15 )) inpt . _validate () inpt . error Out: Please enter at least 15 characters.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidaterange_len","text":"def hemlock.functions.validate. range_len ( question, min_, max_ ) [source] Validates the range of the response length. For a string response, this is the length of the string. For a choices response, this is the number of choices selected. Parameters: question : hemlock.Question min_ : int Minimum response length. max_ : int Maximum response length.","title":"hemlock.functions.validate.range_len"},{"location":"validate_functions/#examples_10","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . range_len ( 5 , 10 )) inpt . _validate () inpt . error Out: Please enter 5 to 10 characters.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidateexact_words","text":"def hemlock.functions.validate. exact_words ( question, nwords ) [source] Validate the exact number of words in the response. Parameters: question : hemlock.Question nwords : int Required number of words.","title":"hemlock.functions.validate.exact_words"},{"location":"validate_functions/#examples_11","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . exact_words ( 1 )) inpt . _validate () inpt . error Out: Please enter exactly 1 word.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidatemax_words","text":"def hemlock.functions.validate. max_words ( question, max_ ) [source] Validates the maximum number of words in the response. Parameters: question : hemlock.Question max_ : int Maximum number of words.","title":"hemlock.functions.validate.max_words"},{"location":"validate_functions/#examples_12","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . max_words ( 1 )) inpt . _validate () inpt . error Out: Please enter at most 1 word.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidatemin_words","text":"def hemlock.functions.validate. min_words ( question, min_ ) [source] Validates the minimum number of words in the repsonse. Parameters: question : hemlock.Question min_ : int Minimum number of words.","title":"hemlock.functions.validate.min_words"},{"location":"validate_functions/#examples_13","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . min_words ( 3 )) inpt . _validate () inpt . error Out: Please enter at least 3 words.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidaterange_words","text":"def hemlock.functions.validate. range_words ( question, min_, max_ ) [source] Validates the number of words falls in a given range. Parameters: question : hemlock.Question min_ : int Minumum number of words. max_ : int Maximum number of words.","title":"hemlock.functions.validate.range_words"},{"location":"validate_functions/#examples_14","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . range_words ( 3 , 5 )) inpt . _validate () inpt . error Out: Please enter between 3 and 5 words.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidateexact_decimals","text":"def hemlock.functions.validate. exact_decimals ( question, ndec ) [source] Validates the exact number of decimals. Parameters: question : hemlock.Question ndec : int Required number of decimals.","title":"hemlock.functions.validate.exact_decimals"},{"location":"validate_functions/#examples_15","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '1' , validate = V . exact_decimals ( 2 )) inpt . _validate () inpt . error Out: Please enter a number with exactly 2 decimals.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidatemax_decimals","text":"def hemlock.functions.validate. max_decimals ( question, max_ ) [source] Validates the maximum number of decimals. Parameters: question : hemlock.Question max_ : int Maximum number of decimals.","title":"hemlock.functions.validate.max_decimals"},{"location":"validate_functions/#examples_16","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '1.123' , validate = V . max_decimals ( 2 )) inpt . _validate () inpt . error Out: Please enter a number with at most 2 decimals.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidatemin_decimals","text":"def hemlock.functions.validate. min_decimals ( question, min_ ) [source] Validates the minumum number of decimals. Parameters: question : hemlock.Question min_ : int Minumum number of decimals.","title":"hemlock.functions.validate.min_decimals"},{"location":"validate_functions/#examples_17","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '1' , validate = V . min_decimals ( 2 )) inpt . _validate () inpt . error Out: Please enter a number with at least 2 decimals.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidaterange_decimals","text":"def hemlock.functions.validate. range_decimals ( question, min_, max_ ) [source] Validates the number of decimals are in a given range. Parameters: question : hemlock.Question min_ : int Minimum number of decimals. max_ : int Maximum number of decimals.","title":"hemlock.functions.validate.range_decimals"},{"location":"validate_functions/#examples_18","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = '1.123' , validate = V . range_decimals ( 0 , 2 )) inpt . _validate () inpt . error Out: Please enter a number with 0 to 2 decimals.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidatematch","text":"def hemlock.functions.validate. match ( question, pattern ) [source] Validate that the response matches the regex pattern. Parameters: question : hemlock.Question pattern : str Regex pattern to match.","title":"hemlock.functions.validate.match"},{"location":"validate_functions/#examples_19","text":"from hemlock import Input , Validate as V , push_app_context app = push_app_context () inpt = Input ( response = 'hello world' , validate = V . match ( 'goodbye *' )) inpt . _validate () inpt . error Out: Please enter a response with the correct pattern.","title":"Examples"},{"location":"validate_functions/#hemlockfunctionsvalidatecorrect_choices","text":"def hemlock.functions.validate. correct_choices ( question, *values ) [source] Validate that selected choice(s) is correct. Parameters: question : hemlock.Question *values : Values of the correct choices.","title":"hemlock.functions.validate.correct_choices"},{"location":"validate_functions/#examples_20","text":"from hemlock import Check , Validate as V , push_app_context app = push_app_context () check = Check ( '<p>Select the correct choice.</p>' , [ 'correct' , 'incorrect' , 'also incorrect' ], validate = V . correct_choices ( 'correct' ), ) check . response = check . choices [ 1 ] check . _validate () check . error Out: Please select the correct choice.","title":"Examples"},{"location":"worker/","text":"a.src-href { float: right; } p.attr { margin-top: 0.5em; margin-left: 1em; } p.func-header { background-color: gainsboro; border-radius: 0.1em; padding: 0.5em; padding-left: 1em; } table.field-table { border-radius: 0.1em } Worker hemlock. Worker Workers simplify interaction with a Redis queue. A worker attaches to a branch or page, and is responsible for one of its methods (compile, validate, submit, or navigate). When the method for which a worker is responsible is called, the worker sends the method to a Redis queue. While the Redis queue is processing this method, the worker shows participants a loading page. When the Redis queue finishes processing this method, the worker sends the client to his next page. Worker inherits from flask_worker.WorkerMixin . Examples In survey.py : from hemlock import Branch , Compile as C , Label , Page , route @route ( '/survey' ) def start (): return Branch ( Page ( Label ( '<p>Hello, World!</p>' ) ), Page ( Label ( '<p>Goodbye, Moon!</p>' , compile = C . complex_function ( seconds = 5 ) ), compile_worker = True , terminal = True ), ) @C . register def complex_function ( label , seconds ): import time for t in range ( seconds ): print ( 'Progress: {} %' . format ( round ( 100. * t / seconds ))) time . sleep ( 1 ) print ( 'Progress: 100%' ) Note that the second page (or rather, one of its questions), needs to run a complex compile function. We add a worker to it by setting compile_worker=True . Use a similar syntax to add validate, submit, and navigate workers. Our app.py is standard: import survey from hemlock import create_app app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) To run the app locally, you will need to set the REDIS_URL environment variable and run a redis queue from your project's root directory. Note. Windows cannot run redis natively. To run redis on Windows, use Windows Subsystem for Linux . If using the hemlock template and hemlock-CLI: Open env.yaml and add the line REDIS_URL: redis:// . Open a second terminal in your project's root directory and run the redis queue with hlk rq . Run the app by entering hlk serve in your first terminal. If not using the template or hemlock-CLI: Set your environment variable with export REDIS_URL=redis:// . Open a second terminal in your project's root directory and enter rq worker hemlock-task-queue . Run the app by entering python3 app.py in your first terminal. Go to http://localhost:5000/ in your browser. Notice that, when you click past the first page, you see a loading gif before the second page is loaded. In your second terminal window, you should see: Progress: 0% ... Progress: 100% To run redis in production on heroku: Declare a worker process. Open Procfile and add the line worker: rq worker -u $REDIS_URL hemlock-task-queue . Create a redis addon. Add \"heroku-redis:hobby-dev\" to \"addons\" in app.json . Add a worker to your dyno formation. Add \"worker: {\"quantity\": 1, \"size\": \"hobby\"} to \"formation\" in app.json . { \"addons\" : [ \"heroku-postgresql:hobby-basic\" , \"heroku-redis:hobby-dev\" ], \"formation\" : { \"web\" : { \"quantity\" : 1 , \"size\" : \"hobby\" }, \"worker\" : { \"quantity\" : 1 , \"size\" : \"hobby\" } }, ... When scaling for production, I recommend using the premium-1 redis plan, quantity 10, size standard-1x.","title":"Worker"},{"location":"worker/#worker","text":"","title":"Worker"},{"location":"worker/#hemlockworker","text":"Workers simplify interaction with a Redis queue. A worker attaches to a branch or page, and is responsible for one of its methods (compile, validate, submit, or navigate). When the method for which a worker is responsible is called, the worker sends the method to a Redis queue. While the Redis queue is processing this method, the worker shows participants a loading page. When the Redis queue finishes processing this method, the worker sends the client to his next page. Worker inherits from flask_worker.WorkerMixin .","title":"hemlock.Worker"},{"location":"worker/#examples","text":"In survey.py : from hemlock import Branch , Compile as C , Label , Page , route @route ( '/survey' ) def start (): return Branch ( Page ( Label ( '<p>Hello, World!</p>' ) ), Page ( Label ( '<p>Goodbye, Moon!</p>' , compile = C . complex_function ( seconds = 5 ) ), compile_worker = True , terminal = True ), ) @C . register def complex_function ( label , seconds ): import time for t in range ( seconds ): print ( 'Progress: {} %' . format ( round ( 100. * t / seconds ))) time . sleep ( 1 ) print ( 'Progress: 100%' ) Note that the second page (or rather, one of its questions), needs to run a complex compile function. We add a worker to it by setting compile_worker=True . Use a similar syntax to add validate, submit, and navigate workers. Our app.py is standard: import survey from hemlock import create_app app = create_app () if __name__ == '__main__' : from hemlock.app import socketio socketio . run ( app , debug = True ) To run the app locally, you will need to set the REDIS_URL environment variable and run a redis queue from your project's root directory. Note. Windows cannot run redis natively. To run redis on Windows, use Windows Subsystem for Linux . If using the hemlock template and hemlock-CLI: Open env.yaml and add the line REDIS_URL: redis:// . Open a second terminal in your project's root directory and run the redis queue with hlk rq . Run the app by entering hlk serve in your first terminal. If not using the template or hemlock-CLI: Set your environment variable with export REDIS_URL=redis:// . Open a second terminal in your project's root directory and enter rq worker hemlock-task-queue . Run the app by entering python3 app.py in your first terminal. Go to http://localhost:5000/ in your browser. Notice that, when you click past the first page, you see a loading gif before the second page is loaded. In your second terminal window, you should see: Progress: 0% ... Progress: 100% To run redis in production on heroku: Declare a worker process. Open Procfile and add the line worker: rq worker -u $REDIS_URL hemlock-task-queue . Create a redis addon. Add \"heroku-redis:hobby-dev\" to \"addons\" in app.json . Add a worker to your dyno formation. Add \"worker: {\"quantity\": 1, \"size\": \"hobby\"} to \"formation\" in app.json . { \"addons\" : [ \"heroku-postgresql:hobby-basic\" , \"heroku-redis:hobby-dev\" ], \"formation\" : { \"web\" : { \"quantity\" : 1 , \"size\" : \"hobby\" }, \"worker\" : { \"quantity\" : 1 , \"size\" : \"hobby\" } }, ... When scaling for production, I recommend using the premium-1 redis plan, quantity 10, size standard-1x.","title":"Examples"},{"location":"setup/linux/","text":"Linux setup These instructions are based on the Ubuntu distribution of WSL. Python3 and pip3 Python is hemlock's primary language. Pip allows you to install python packages, including hemlock and its command line interface, hemlock-CLI. Many linux distributions come with python3. Verify your python3 installation: $ python3 --version Python 3 .x.x If you don't have python3, download it here . I recommend python3.6. Why? Because heroku, my recommended method of app deployment, uses python3.6, meaning that if you develop in python3.7+ and deploy in python3.6, you may encounter compatibility issues. Make sure python3 is in your path. Upgrade pip: $ python3 -m pip install --upgrade pip Verify your pip installation: $ pip3 --version pip xx.x.x ... pip versus pip3 You'll install several python packages using pip. Conventionally, the command to install these is: $ pip install <my-requested-package> You may need to replace this with: $ pip3 install <my-requested-package> Many hemlock-CLI commands assume you can pip install with pip3 . Hemlock-CLI Hemlock's command line interface, hemlock-CLI, defines many useful commands for initializing, editing, and deploying hemlock projects. Download with: $ pip install -U hemlock-cli Verify your hemlock-CLI installation: $ hlk --version hlk, version x.x.xx Git and github Git is a version control system, and github hosts code repositories. Together, they allow you to share and collaborate on hemlock projects. You will also need git to initialize hemlock projects with the hemlock template. Find installation instructions for git here . Verify your git installation: $ git --version git version x.xx.x.linux.1 Then, create a github account here . Configure your github command line interface: $ git config --global user.name <my-github-username> $ git config --global user.email <my-github-user-email> Finally, you will need a personal access token to initialize hemlock applications with the hemlock command line interface. Read everything until STOP before creating your github token. Create a github token by following these instructions . When setting permissions (step 7), check 'repo'. Copy your token and store it somewhere accessible. For example, I store my token in a file named github_token.txt . STOP. Visual studio code I recommend visual studio code for editing python files. Download VS code here . Close and re-open your terminal. Verify your VS code installation: $ code --version 1 .xx.x Jupyter Jupyter allows you to quickly iterate on project designs. Install jupyter notebook with pip: $ pip install -U notebook Close and re-open your terminal. Verify your jupyter installation: $ jupyter --version jupyter core : x.x.x jupyter-notebook : x.x.x ... Google chrome Hemlock is developed and tested primarily on chrome. Download chrome here . Verify that you can open it as follows: $ python3 >>> import webbrowser >>> webbrowser.open ( 'https://dsbowen.github.io/hemlock' ) True >>> exit () You should see chrome open to the hemlock docs. If you came here from the tutorial, you're now ready to return to it and get started with your first hemlock project. Click here to go back to the First Project section of the tutorial . Chromedriver Hemlock's custom debugging tool and survey view functions use chromedriver . To use these features locally, you'll need to download chromedriver (this command assumes you have curl installed; see here to install curl ): $ hlk setup linux --chromedriver Close and re-open your terminal. Verify your chromedriver installation: $ which chromedriver /home/<my-linux-username>/webdrivers/chromedriver Chrome and chromedriver compatibility As of 07/14/2020, hlk setup linux --chromedriver installs chromedriver for chrome 83. While chrome updates automatically, chromedriver does not. This means that you will encounter compatibility issues when chrome updates to version 84+. To fix this: Download the latest chromedriver here . Put the chrome binary in /home/<my-linux-username>/webdrivers/ . Chromedriver should still be in your path, which you can verify: $ which chromedriver /home/<my-linux-username>/webdrivers/chromedriver If you came here from the Debug section of the tutorial, you're now ready to return to it and run the debugger. Click here to go back to the Debug section of the tutorial . Heroku Heroku is an easy and inexpensive service for deploying web applications (i.e. putting them online), including hemlock applications. Sign up for heroku here . You can install heroku-CLI using hemlock-CLI: $ hlk setup linux --heroku-cli Verify your heroku-CLI installation: $ heroku --version heroku/x.xx.x linux-x64 node-vxx.xx.x Note. See this github issue if you experience a 'EACCES' error. Do not simply use sudo ; this only masks issues you'll encounter later. Click here to return to the Deploy section of the tutorial .","title":"Linux"},{"location":"setup/linux/#linux-setup","text":"These instructions are based on the Ubuntu distribution of WSL.","title":"Linux setup"},{"location":"setup/linux/#python3-and-pip3","text":"Python is hemlock's primary language. Pip allows you to install python packages, including hemlock and its command line interface, hemlock-CLI. Many linux distributions come with python3. Verify your python3 installation: $ python3 --version Python 3 .x.x If you don't have python3, download it here . I recommend python3.6. Why? Because heroku, my recommended method of app deployment, uses python3.6, meaning that if you develop in python3.7+ and deploy in python3.6, you may encounter compatibility issues. Make sure python3 is in your path. Upgrade pip: $ python3 -m pip install --upgrade pip Verify your pip installation: $ pip3 --version pip xx.x.x ...","title":"Python3 and pip3"},{"location":"setup/linux/#pip-versus-pip3","text":"You'll install several python packages using pip. Conventionally, the command to install these is: $ pip install <my-requested-package> You may need to replace this with: $ pip3 install <my-requested-package> Many hemlock-CLI commands assume you can pip install with pip3 .","title":"pip versus pip3"},{"location":"setup/linux/#hemlock-cli","text":"Hemlock's command line interface, hemlock-CLI, defines many useful commands for initializing, editing, and deploying hemlock projects. Download with: $ pip install -U hemlock-cli Verify your hemlock-CLI installation: $ hlk --version hlk, version x.x.xx","title":"Hemlock-CLI"},{"location":"setup/linux/#git-and-github","text":"Git is a version control system, and github hosts code repositories. Together, they allow you to share and collaborate on hemlock projects. You will also need git to initialize hemlock projects with the hemlock template. Find installation instructions for git here . Verify your git installation: $ git --version git version x.xx.x.linux.1 Then, create a github account here . Configure your github command line interface: $ git config --global user.name <my-github-username> $ git config --global user.email <my-github-user-email> Finally, you will need a personal access token to initialize hemlock applications with the hemlock command line interface. Read everything until STOP before creating your github token. Create a github token by following these instructions . When setting permissions (step 7), check 'repo'. Copy your token and store it somewhere accessible. For example, I store my token in a file named github_token.txt . STOP.","title":"Git and github"},{"location":"setup/linux/#visual-studio-code","text":"I recommend visual studio code for editing python files. Download VS code here . Close and re-open your terminal. Verify your VS code installation: $ code --version 1 .xx.x","title":"Visual studio code"},{"location":"setup/linux/#jupyter","text":"Jupyter allows you to quickly iterate on project designs. Install jupyter notebook with pip: $ pip install -U notebook Close and re-open your terminal. Verify your jupyter installation: $ jupyter --version jupyter core : x.x.x jupyter-notebook : x.x.x ...","title":"Jupyter"},{"location":"setup/linux/#google-chrome","text":"Hemlock is developed and tested primarily on chrome. Download chrome here . Verify that you can open it as follows: $ python3 >>> import webbrowser >>> webbrowser.open ( 'https://dsbowen.github.io/hemlock' ) True >>> exit () You should see chrome open to the hemlock docs. If you came here from the tutorial, you're now ready to return to it and get started with your first hemlock project. Click here to go back to the First Project section of the tutorial .","title":"Google chrome"},{"location":"setup/linux/#chromedriver","text":"Hemlock's custom debugging tool and survey view functions use chromedriver . To use these features locally, you'll need to download chromedriver (this command assumes you have curl installed; see here to install curl ): $ hlk setup linux --chromedriver Close and re-open your terminal. Verify your chromedriver installation: $ which chromedriver /home/<my-linux-username>/webdrivers/chromedriver","title":"Chromedriver"},{"location":"setup/linux/#chrome-and-chromedriver-compatibility","text":"As of 07/14/2020, hlk setup linux --chromedriver installs chromedriver for chrome 83. While chrome updates automatically, chromedriver does not. This means that you will encounter compatibility issues when chrome updates to version 84+. To fix this: Download the latest chromedriver here . Put the chrome binary in /home/<my-linux-username>/webdrivers/ . Chromedriver should still be in your path, which you can verify: $ which chromedriver /home/<my-linux-username>/webdrivers/chromedriver If you came here from the Debug section of the tutorial, you're now ready to return to it and run the debugger. Click here to go back to the Debug section of the tutorial .","title":"Chrome and chromedriver compatibility"},{"location":"setup/linux/#heroku","text":"Heroku is an easy and inexpensive service for deploying web applications (i.e. putting them online), including hemlock applications. Sign up for heroku here . You can install heroku-CLI using hemlock-CLI: $ hlk setup linux --heroku-cli Verify your heroku-CLI installation: $ heroku --version heroku/x.xx.x linux-x64 node-vxx.xx.x Note. See this github issue if you experience a 'EACCES' error. Do not simply use sudo ; this only masks issues you'll encounter later. Click here to return to the Deploy section of the tutorial .","title":"Heroku"},{"location":"setup/mac/","text":"Mac setup These instructions were written for Mac OS 10.9. Open a terminal window Hemlock requires you to use a terminal window for setting up, editing, and deploying hemlock projects. To open a terminal window, enter 'terminal' in spotlight search. Terminal commands are written in bash: $ <my-bash-command> Note 1. You don't type $ ; it simply indicates the beginning of a bash command. Note 2. For this tutorial, always make sure to change to your home directory after you open your terminal. Do this by entering: $ cd Xcode Mac OS typically requires Xcode Command-line Tools. Install in your terminal: $ xcode-select --install Or from the Mac app store . Python3 and pip3 Python is hemlock's primary language. Pip allows you to install python packages, including hemlock and its command line interface, hemlock-CLI. Read everything until STOP before downloading or installing anything. You can download the latest version of python here . However, I recommend an earlier version, python3.6. Download python3.6 here . Why do I recommend 3.6 instead of the latest version of python? Because heroku, my recommended method of app deployment, uses python3.6, meaning that if you develop in python3.7+ and deploy in python3.6, you may encounter compatibility issues. When you start the python installer, you'll see an Add Python to PATH option on the first page. Make sure to select this option. STOP. Close and re-open your terminal window. Verify your python installation. $ python3 --version Python 3 .x.x Upgrade pip: $ python3 -m pip install --upgrade pip Verify your pip installation: $ pip3 --version pip xx.x.x ... Hemlock-CLI Hemlock's command line interface, hemlock-CLI, defines many useful commands for initializing, editing, and deploying hemlock projects. Install with: $ pip install -U hemlock-cli Verify your hemlock-CLI installation: $ hlk --version hlk, version x.x.xx Git and github Git is a version control system, and github hosts code repositories. Together, they allow you to share and collaborate on hemlock projects. You will also need git to initialize hemlock projects with the hemlock template. Macs typically have git pre-installed, which you can verify: $ git --version git version 2 .27.0.mac.1 If you don't have git, follow the download and installation instructions here . Then, create a github account here . Configure your github command line interface: $ git config --global user.name <my-github-username> $ git config --global user.email <my-github-user-email> For example, I would enter: $ git config --global user.name dsbowen $ git config --global user.email dsbowen@wharton.upenn.edu Finally, you will need a personal access token to initialize hemlock applications with the hemlock command line interface. Read everything until STOP before creating your github token. Create a github token by following these instructions . When setting permissions (step 7), check 'repo'. Copy your token and store it somewhere accessible. For example, I store my token in a file named github_token.txt . STOP. Visual studio code I recommend visual studio code for editing python files. Download VS code here . Close and re-open your terminal. Verify your VS code installation: $ code --version 1 .xx.x Jupyter Jupyter allows you to quickly iterate on project designs. Install jupyter notebook with pip: $ pip install -U notebook Close and re-open your terminal. Verify your jupyter installation: $ jupyter --version jupyter core : 4 .6.3 jupyter-notebook : 6 .0.3 qtconsole : not installed ipython : 7 .16.1 ipykernel : 5 .3.2 jupyter client : 6 .1.5 jupyter lab : not installed nbconvert : 5 .6.1 ipywidgets : not installed nbformat : 5 .0.7 traitlets : 4 .3.3 Google chrome Hemlock is developed and tested primarily on chrome. Download chrome here . Verify that you can open it as follows: $ python3 >>> import webbrowser >>> webbrowser.open ( 'https://dsbowen.github.io/hemlock' ) True >>> exit () You should see chrome open to the hemlock docs. Note. >>> is where you enter python commands in the python interpreter. If you came here from the tutorial, you're now ready to return to it and get started with your first hemlock project. Click here to go back to the First Project section of the tutorial . Chromedriver Hemlock's custom debugging tool and survey view functions use chromedriver . To use these features locally, you'll need to download chromedriver: $ hlk setup mac --chromedriver Close and re-open your terminal. Verify your chromedriver installation: $ which chromedriver /users/<my-mac-username>/webdrivers/chromedriver Chrome and chromedriver compatibility As of 07/14/2020, hlk setup mac --chromedriver installs chromedriver for chrome 83. While chrome updates automatically, chromedriver does not. This means that you will encounter compatibility issues when chrome updates to version 84+. To fix this: Download the latest chromedriver here . Put the chrome binary, chromedriver , in /users/<my-mac-username>/webdrivers/ . For example, I would put my chromedriver binary in /users/dsbowen/webdrivers/ . Chromedriver should still be in your path, which you can verify: $ which chromedriver /users/<my-mac-username>/webdrivers/chromedriver If you came here from the Debug section of the tutorial, you're now ready to return to it and run the debugger. Click here to go back to the Debug section of the tutorial . Heroku Heroku is an easy and inexpensive service for deploying web applications (i.e. putting them online), including hemlock applications. Sign up for heroku here . You can install heroku-CLI using hemlock-CLI: $ hlk setup mac --heroku-cli Verify your heroku-CLI installation: $ heroku --version heroku/x.xx.x mac node-vxx.xx.x Note. See this github issue if you experience a 'EACCES' error. Do not simply use sudo ; this only masks issues you'll encounter later. Click here to return to the Deploy section of the tutorial .","title":"Mac"},{"location":"setup/mac/#mac-setup","text":"These instructions were written for Mac OS 10.9.","title":"Mac setup"},{"location":"setup/mac/#open-a-terminal-window","text":"Hemlock requires you to use a terminal window for setting up, editing, and deploying hemlock projects. To open a terminal window, enter 'terminal' in spotlight search. Terminal commands are written in bash: $ <my-bash-command> Note 1. You don't type $ ; it simply indicates the beginning of a bash command. Note 2. For this tutorial, always make sure to change to your home directory after you open your terminal. Do this by entering: $ cd","title":"Open a terminal window"},{"location":"setup/mac/#xcode","text":"Mac OS typically requires Xcode Command-line Tools. Install in your terminal: $ xcode-select --install Or from the Mac app store .","title":"Xcode"},{"location":"setup/mac/#python3-and-pip3","text":"Python is hemlock's primary language. Pip allows you to install python packages, including hemlock and its command line interface, hemlock-CLI. Read everything until STOP before downloading or installing anything. You can download the latest version of python here . However, I recommend an earlier version, python3.6. Download python3.6 here . Why do I recommend 3.6 instead of the latest version of python? Because heroku, my recommended method of app deployment, uses python3.6, meaning that if you develop in python3.7+ and deploy in python3.6, you may encounter compatibility issues. When you start the python installer, you'll see an Add Python to PATH option on the first page. Make sure to select this option. STOP. Close and re-open your terminal window. Verify your python installation. $ python3 --version Python 3 .x.x Upgrade pip: $ python3 -m pip install --upgrade pip Verify your pip installation: $ pip3 --version pip xx.x.x ...","title":"Python3 and pip3"},{"location":"setup/mac/#hemlock-cli","text":"Hemlock's command line interface, hemlock-CLI, defines many useful commands for initializing, editing, and deploying hemlock projects. Install with: $ pip install -U hemlock-cli Verify your hemlock-CLI installation: $ hlk --version hlk, version x.x.xx","title":"Hemlock-CLI"},{"location":"setup/mac/#git-and-github","text":"Git is a version control system, and github hosts code repositories. Together, they allow you to share and collaborate on hemlock projects. You will also need git to initialize hemlock projects with the hemlock template. Macs typically have git pre-installed, which you can verify: $ git --version git version 2 .27.0.mac.1 If you don't have git, follow the download and installation instructions here . Then, create a github account here . Configure your github command line interface: $ git config --global user.name <my-github-username> $ git config --global user.email <my-github-user-email> For example, I would enter: $ git config --global user.name dsbowen $ git config --global user.email dsbowen@wharton.upenn.edu Finally, you will need a personal access token to initialize hemlock applications with the hemlock command line interface. Read everything until STOP before creating your github token. Create a github token by following these instructions . When setting permissions (step 7), check 'repo'. Copy your token and store it somewhere accessible. For example, I store my token in a file named github_token.txt . STOP.","title":"Git and github"},{"location":"setup/mac/#visual-studio-code","text":"I recommend visual studio code for editing python files. Download VS code here . Close and re-open your terminal. Verify your VS code installation: $ code --version 1 .xx.x","title":"Visual studio code"},{"location":"setup/mac/#jupyter","text":"Jupyter allows you to quickly iterate on project designs. Install jupyter notebook with pip: $ pip install -U notebook Close and re-open your terminal. Verify your jupyter installation: $ jupyter --version jupyter core : 4 .6.3 jupyter-notebook : 6 .0.3 qtconsole : not installed ipython : 7 .16.1 ipykernel : 5 .3.2 jupyter client : 6 .1.5 jupyter lab : not installed nbconvert : 5 .6.1 ipywidgets : not installed nbformat : 5 .0.7 traitlets : 4 .3.3","title":"Jupyter"},{"location":"setup/mac/#google-chrome","text":"Hemlock is developed and tested primarily on chrome. Download chrome here . Verify that you can open it as follows: $ python3 >>> import webbrowser >>> webbrowser.open ( 'https://dsbowen.github.io/hemlock' ) True >>> exit () You should see chrome open to the hemlock docs. Note. >>> is where you enter python commands in the python interpreter. If you came here from the tutorial, you're now ready to return to it and get started with your first hemlock project. Click here to go back to the First Project section of the tutorial .","title":"Google chrome"},{"location":"setup/mac/#chromedriver","text":"Hemlock's custom debugging tool and survey view functions use chromedriver . To use these features locally, you'll need to download chromedriver: $ hlk setup mac --chromedriver Close and re-open your terminal. Verify your chromedriver installation: $ which chromedriver /users/<my-mac-username>/webdrivers/chromedriver","title":"Chromedriver"},{"location":"setup/mac/#chrome-and-chromedriver-compatibility","text":"As of 07/14/2020, hlk setup mac --chromedriver installs chromedriver for chrome 83. While chrome updates automatically, chromedriver does not. This means that you will encounter compatibility issues when chrome updates to version 84+. To fix this: Download the latest chromedriver here . Put the chrome binary, chromedriver , in /users/<my-mac-username>/webdrivers/ . For example, I would put my chromedriver binary in /users/dsbowen/webdrivers/ . Chromedriver should still be in your path, which you can verify: $ which chromedriver /users/<my-mac-username>/webdrivers/chromedriver If you came here from the Debug section of the tutorial, you're now ready to return to it and run the debugger. Click here to go back to the Debug section of the tutorial .","title":"Chrome and chromedriver compatibility"},{"location":"setup/mac/#heroku","text":"Heroku is an easy and inexpensive service for deploying web applications (i.e. putting them online), including hemlock applications. Sign up for heroku here . You can install heroku-CLI using hemlock-CLI: $ hlk setup mac --heroku-cli Verify your heroku-CLI installation: $ heroku --version heroku/x.xx.x mac node-vxx.xx.x Note. See this github issue if you experience a 'EACCES' error. Do not simply use sudo ; this only masks issues you'll encounter later. Click here to return to the Deploy section of the tutorial .","title":"Heroku"},{"location":"setup/win/","text":"Windows setup These instructions were written for Windows 10. Git and github Git is a version control system, and github hosts code repositories. Together, they allow you to share and collaborate on hemlock projects. You will also need git to initialize hemlock projects with the hemlock template. You can find git download and installation instructions here . We'll use the git bash terminal for this tutorial. Right click anywhere on your desktop and select 'Git Bash Here`. You should see a terminal window appear. Enter the following into your terminal: $ cd This moves you to your home directory. It's not important that you understand exactly what this means, but if you're dying to find out, read this . Note 1. You don't type $ ; it simply indicates the beginning of a bash command. Note 2. For this tutorial, always make sure to change to your home directory by entering cd after you open the git bash terminal. Verify your git installation: $ git --version git version 2 .27.0.windows.1 Note 1. The first line, git --version , is what you enter in the terminal. The second line, git version 2.27.0.windows.1 , is the output. In general, lines that start with $ are things you enter in your terminal; lines without $ are the output of what you just entered. Note 2. It's okay if you have a slightly different version of git. For example, your second line may read git version 2.28.0.windows.1 . Then, create a github account here . Configure your github command line interface: $ git config --global user.name <my-github-username> $ git config --global user.email <my-github-user-email> For example, I would enter: $ git config --global user.name dsbowen $ git config --global user.email dsbowen@wharton.upenn.edu Finally, you will need a personal access token to initialize hemlock applications with the hemlock command line interface (more on this later). Read everything until STOP before creating your github token. Create a github token by following these instructions . When setting permissions (step 7), check 'repo'. Copy your token and store it somewhere accessible. For example, I store my token in a file named github_token.txt . STOP. Python3 and pip3 Python is hemlock's primary language. Pip allows you to install python packages, including hemlock itself. In this section, we're going to download and install python3 and pip3. Read everything until STOP before downloading or installing anything. You can download the latest version of python here . However, I recommend an earlier version, python3.6. Download python3.6 here . Then, click on the file you just downloaded to install it. Why do I recommend 3.6 instead of the latest version of python? Because heroku, my recommended method of app deployment, uses python3.6, meaning that if you develop in python3.7+ and deploy in python3.6, you may encounter compatibility issues. When you start the python installer, you'll see an Add Python to PATH option on the first page. Make sure to select this option. STOP. Close and re-open your terminal window and enter: $ which python You should see a line print underneath which python . This is the location of your python executable (i.e. the file that runs python). On my computer, it looks like: /c/Users/DBSpe/AppData/Local/Programs/Python/Python36-32/python The python executable may be in a different location on your computer. In general, it'll look like: <my-python-location>/python We're going to change directories to that location (i.e. we're going to go to where the python executable is). On my computer, I would enter: $ cd /c/Users/DBSpe/AppData/Local/Programs/Python/Python36-32 In general, you would enter: $ cd <my-python-location> Note. The line that printed under which python was <my-python-location>/python ; you'll then enter cd <my-python-location> , not cd <my-python-location>/python . Copy python.exe to python3.exe : $ cp python.exe python3.exe Verify your python installation: $ python3 --version Python 3 .6.8 It's okay if you have a different version of python. Next, upgrade pip: $ python3 -m pip install --upgrade pip Verify your pip installation: $ pip3 --version pip 20 .1.1 from c: \\u sers \\d bspe \\a ppdata \\l ocal \\p rograms \\p ython \\p ython36-32 \\l ib \\s ite-packages \\p ip ( python3.6 ) Again, it's okay to have a slightly different version of pip. Congratulations! You've installed python. Now return to your home directory: $ cd Hemlock-CLI Hemlock's command line interface, hemlock-CLI, defines many useful commands for initializing, editing, and deploying hemlock projects. Install with: $ pip install -U hemlock-cli Verify your hemlock-CLI installation: $ hlk --version hlk, version x.x.xx Visual studio code I recommend visual studio code for editing python files. You can find download and installation instructions for VS code here . Close and re-open your terminal. Verify your VS code installation: $ code --version 1 .47.2 17299e413d5590b14ab0340ea477cdd86ff13dafx64 Jupyter Jupyter allows you to quickly iterate on project designs. Install jupyter notebook with pip: $ pip install -U notebook Close and re-open your terminal. Verify your jupyter installation: $ jupyter --version jupyter core : 4 .6.3 jupyter-notebook : 6 .0.3 qtconsole : not installed ipython : 7 .16.1 ipykernel : 5 .3.2 jupyter client : 6 .1.5 jupyter lab : not installed nbconvert : 5 .6.1 ipywidgets : not installed nbformat : 5 .0.7 traitlets : 4 .3.3 Google chrome Hemlock is developed and tested primarily on chrome. Download chrome here . Verify that you can open it as follows: $ python3 >>> import webbrowser >>> webbrowser.open ( 'https://dsbowen.github.io/hemlock' ) True >>> exit () You should see chrome open to the hemlock docs. Note. >>> is where you enter python commands. This is called the 'python interpreter'. If you came here from the tutorial, you're now ready to return to it and get started with your first hemlock project. Click here to go back to the First Project section of the tutorial . Chromedriver Hemlock's custom debugging tool and survey view functions use chromedriver . To use these features locally, you'll need to download chromedriver: $ hlk setup win --chromedriver Close and re-open your terminal. Verify your chromedriver installation: $ which chromedriver.exe The line underneath which chromedriver.exe is the location of your chromedriver executable. On my computer, it looks like: /c/users/dbspe/webdrivers/chromedriver.exe It's okay if your chromedriver executable is in a different location. Chrome and chromedriver compatibility As of 07/14/2020, hlk setup win --chromedriver installs chromedriver for chrome 83. While chrome updates automatically, chromedriver does not. This means that you will encounter compatibility issues when chrome updates to version 84+. To fix this: Download the latest chromedriver here . Put the chromedriver executable, chromedriver.exe , in C:\\users\\<my-windows-username>\\webdrivers\\ . For example, I would put my chromedriver executable in C:\\users\\dbspe\\webdrivers\\ . Chromedriver should still be in your path, which you can verify: $ which chromedriver.exe <my-chromedriver-location>/chromedriver.exe If you came here from the Debug section of the tutorial, you're now ready to return to it and run the debugger. Click here to go back to the Debug section of the tutorial . Heroku Heroku is an easy and inexpensive service for deploying web applications (i.e. putting them online), including hemlock applications. Sign up for heroku here . Then, download and install the heroku command line interface (heroku-CLI) following these instructions . Close and re-open your terminal. Verify your heroku-CLI installation: $ heroku --version heroku/x.xx.x win32-x64 node-vxx.xx.x Log into heroku: $ heroku login Click here to return to the Deploy section of the tutorial .","title":"Windows"},{"location":"setup/win/#windows-setup","text":"These instructions were written for Windows 10.","title":"Windows setup"},{"location":"setup/win/#git-and-github","text":"Git is a version control system, and github hosts code repositories. Together, they allow you to share and collaborate on hemlock projects. You will also need git to initialize hemlock projects with the hemlock template. You can find git download and installation instructions here . We'll use the git bash terminal for this tutorial. Right click anywhere on your desktop and select 'Git Bash Here`. You should see a terminal window appear. Enter the following into your terminal: $ cd This moves you to your home directory. It's not important that you understand exactly what this means, but if you're dying to find out, read this . Note 1. You don't type $ ; it simply indicates the beginning of a bash command. Note 2. For this tutorial, always make sure to change to your home directory by entering cd after you open the git bash terminal. Verify your git installation: $ git --version git version 2 .27.0.windows.1 Note 1. The first line, git --version , is what you enter in the terminal. The second line, git version 2.27.0.windows.1 , is the output. In general, lines that start with $ are things you enter in your terminal; lines without $ are the output of what you just entered. Note 2. It's okay if you have a slightly different version of git. For example, your second line may read git version 2.28.0.windows.1 . Then, create a github account here . Configure your github command line interface: $ git config --global user.name <my-github-username> $ git config --global user.email <my-github-user-email> For example, I would enter: $ git config --global user.name dsbowen $ git config --global user.email dsbowen@wharton.upenn.edu Finally, you will need a personal access token to initialize hemlock applications with the hemlock command line interface (more on this later). Read everything until STOP before creating your github token. Create a github token by following these instructions . When setting permissions (step 7), check 'repo'. Copy your token and store it somewhere accessible. For example, I store my token in a file named github_token.txt . STOP.","title":"Git and github"},{"location":"setup/win/#python3-and-pip3","text":"Python is hemlock's primary language. Pip allows you to install python packages, including hemlock itself. In this section, we're going to download and install python3 and pip3. Read everything until STOP before downloading or installing anything. You can download the latest version of python here . However, I recommend an earlier version, python3.6. Download python3.6 here . Then, click on the file you just downloaded to install it. Why do I recommend 3.6 instead of the latest version of python? Because heroku, my recommended method of app deployment, uses python3.6, meaning that if you develop in python3.7+ and deploy in python3.6, you may encounter compatibility issues. When you start the python installer, you'll see an Add Python to PATH option on the first page. Make sure to select this option. STOP. Close and re-open your terminal window and enter: $ which python You should see a line print underneath which python . This is the location of your python executable (i.e. the file that runs python). On my computer, it looks like: /c/Users/DBSpe/AppData/Local/Programs/Python/Python36-32/python The python executable may be in a different location on your computer. In general, it'll look like: <my-python-location>/python We're going to change directories to that location (i.e. we're going to go to where the python executable is). On my computer, I would enter: $ cd /c/Users/DBSpe/AppData/Local/Programs/Python/Python36-32 In general, you would enter: $ cd <my-python-location> Note. The line that printed under which python was <my-python-location>/python ; you'll then enter cd <my-python-location> , not cd <my-python-location>/python . Copy python.exe to python3.exe : $ cp python.exe python3.exe Verify your python installation: $ python3 --version Python 3 .6.8 It's okay if you have a different version of python. Next, upgrade pip: $ python3 -m pip install --upgrade pip Verify your pip installation: $ pip3 --version pip 20 .1.1 from c: \\u sers \\d bspe \\a ppdata \\l ocal \\p rograms \\p ython \\p ython36-32 \\l ib \\s ite-packages \\p ip ( python3.6 ) Again, it's okay to have a slightly different version of pip. Congratulations! You've installed python. Now return to your home directory: $ cd","title":"Python3 and pip3"},{"location":"setup/win/#hemlock-cli","text":"Hemlock's command line interface, hemlock-CLI, defines many useful commands for initializing, editing, and deploying hemlock projects. Install with: $ pip install -U hemlock-cli Verify your hemlock-CLI installation: $ hlk --version hlk, version x.x.xx","title":"Hemlock-CLI"},{"location":"setup/win/#visual-studio-code","text":"I recommend visual studio code for editing python files. You can find download and installation instructions for VS code here . Close and re-open your terminal. Verify your VS code installation: $ code --version 1 .47.2 17299e413d5590b14ab0340ea477cdd86ff13dafx64","title":"Visual studio code"},{"location":"setup/win/#jupyter","text":"Jupyter allows you to quickly iterate on project designs. Install jupyter notebook with pip: $ pip install -U notebook Close and re-open your terminal. Verify your jupyter installation: $ jupyter --version jupyter core : 4 .6.3 jupyter-notebook : 6 .0.3 qtconsole : not installed ipython : 7 .16.1 ipykernel : 5 .3.2 jupyter client : 6 .1.5 jupyter lab : not installed nbconvert : 5 .6.1 ipywidgets : not installed nbformat : 5 .0.7 traitlets : 4 .3.3","title":"Jupyter"},{"location":"setup/win/#google-chrome","text":"Hemlock is developed and tested primarily on chrome. Download chrome here . Verify that you can open it as follows: $ python3 >>> import webbrowser >>> webbrowser.open ( 'https://dsbowen.github.io/hemlock' ) True >>> exit () You should see chrome open to the hemlock docs. Note. >>> is where you enter python commands. This is called the 'python interpreter'. If you came here from the tutorial, you're now ready to return to it and get started with your first hemlock project. Click here to go back to the First Project section of the tutorial .","title":"Google chrome"},{"location":"setup/win/#chromedriver","text":"Hemlock's custom debugging tool and survey view functions use chromedriver . To use these features locally, you'll need to download chromedriver: $ hlk setup win --chromedriver Close and re-open your terminal. Verify your chromedriver installation: $ which chromedriver.exe The line underneath which chromedriver.exe is the location of your chromedriver executable. On my computer, it looks like: /c/users/dbspe/webdrivers/chromedriver.exe It's okay if your chromedriver executable is in a different location.","title":"Chromedriver"},{"location":"setup/win/#chrome-and-chromedriver-compatibility","text":"As of 07/14/2020, hlk setup win --chromedriver installs chromedriver for chrome 83. While chrome updates automatically, chromedriver does not. This means that you will encounter compatibility issues when chrome updates to version 84+. To fix this: Download the latest chromedriver here . Put the chromedriver executable, chromedriver.exe , in C:\\users\\<my-windows-username>\\webdrivers\\ . For example, I would put my chromedriver executable in C:\\users\\dbspe\\webdrivers\\ . Chromedriver should still be in your path, which you can verify: $ which chromedriver.exe <my-chromedriver-location>/chromedriver.exe If you came here from the Debug section of the tutorial, you're now ready to return to it and run the debugger. Click here to go back to the Debug section of the tutorial .","title":"Chrome and chromedriver compatibility"},{"location":"setup/win/#heroku","text":"Heroku is an easy and inexpensive service for deploying web applications (i.e. putting them online), including hemlock applications. Sign up for heroku here . Then, download and install the heroku command line interface (heroku-CLI) following these instructions . Close and re-open your terminal. Verify your heroku-CLI installation: $ heroku --version heroku/x.xx.x win32-x64 node-vxx.xx.x Log into heroku: $ heroku login Click here to return to the Deploy section of the tutorial .","title":"Heroku"},{"location":"setup/wsl/","text":"Windows Subsystem for Linux (WSL) setup These instructions were written for Windows 10. Why WSL? The main reason I use WSL is that Windows OS doesn't have a fork (only a spoon), which means you'll need WSL if you want to run Redis. You can find download instructions for WSL here . Either WSL 1 or 2 should work. I personally use the Ubuntu distribution. After you've installed WSL, open a terminal window (WIN + R, then enter e.g. 'ubuntu2004'. You may be prompted to create a username and password. Python3 and pip3 Python is hemlock's primary language. Pip allows you to install python packages, including hemlock and its command line interface, hemlock-CLI. Most WSL distributions come with python3. Verify your python installation with: $ python3 Python 3.x.x If you don't have python intalled on your WSL distribution, download python here . I recommend python3.6, rather than the latest version. Why? Because heroku, my recommended method of app deployment, uses python3.6, meaning that if you develop in python3.7+ and deploy in python3.6, you may encounter compatibility issues. Update your package lists: $ sudo apt-get update Install pip3: $ sudo apt install -f -y python3-pip Respond 'Yes' if asked whether you want to restart services automatically. Verify your pip3 installation: $ pip3 --version pip x.x.x from /usr/lib/python3/dist-packages ( python 3 .x ) You'll also need the ability to create virtual environments: $ apt install -f -y python3-venv pip versus pip3 You'll install several python packages using pip. Conventionally, the command to install these is: $ pip install <my-requested-package> You may need to replace this with: $ pip3 install <my-requested-package> Many hemlock-CLI commands assume you can pip install with pip3 . Hemlock-CLI Hemlock's command line interface, hemlock-CLI, defines many useful commands for initializing, editing, and deploying hemlock projects. Download with: $ pip install -U hemlock-cli Verify your hemlock-CLI installation: $ hlk --version hlk, version x.x.xx Git and github Git is a version control system, and github hosts code repositories. Together, they allow you to share and collaborate on hemlock projects. You will also need git to initialize hemlock projects with the hemlock template. You can find git download and installation instructions here . Verify your git installation: $ git --version git version 2 .17.1 Then, create a github account here . Configure your github command line interface: $ git config --global user.name <my-github-username> $ git config --global user.email <my-github-user-email> Finally, you will need a personal access token to initialize hemlock applications with the hemlock command line interface. Read everything until STOP before creating your github token. Create a github token by following these instructions . When setting permissions (step 7), check 'repo'. Copy your token and store it somewhere accessible. For example, I store my token in a file named github_token.txt . STOP. Visual studio code I recommend visual studio code for editing python files. Read everything until STOP before downloading or installing anything. You can find download and installation instructions for VS code here . Make sure to download the Windows version, not the Linux version. STOP Close and re-open your terminal. Verify your VS code installation: $ code --version 1 .xx.x Jupyter Jupyter allows you to quickly iterate on project designs. Install jupyter notebook with pip: $ pip install -U notebook Close and re-open your terminal. Verify your jupyter installation: $ jupyter --version jupyter core : x.x.x jupyter-notebook : x.x.x ... Google chrome Hemlock is developed and tested primarily on chrome. Download chrome here . Verify that you can open it as follows: $ python3 >>> import webbrowser >>> webbrowser.open ( 'https://dsbowen.github.io/hemlock' ) True >>> exit () You should see chrome open to the hemlock docs. Note. If this doesn't work, it's probably because the chrome executable isn't in your path. Run the following: $ hlk setup wsl --chrome Close and re-open your terminal. Verify your BROWSER variable: $ echo $BROWSER /mnt/c/program files ( x86 ) /google/chrome/application/chrome.exe Now try again to open the webbrowser. If you came here from the tutorial, you're now ready to return to it and get started with your first hemlock project. Click here to go back to the First Project section of the tutorial . Chromedriver Hemlock's custom debugging tool and survey view functions use chromedriver . To use these features locally, you'll need to download chromedriver: $ hlk setup wsl --chromedriver Close and re-open your terminal. Verify your chromedriver installation: $ which chromedriver /mnt/c/users/<my-windows-username>/webdrivers/chromedriver Chrome and chromedriver compatibility As of 07/14/2020, hlk setup wsl --chromedriver installs chromedriver for chrome 83. While chrome updates automatically, chromedriver does not. This means that you will encounter compatibility issues when chrome updates to version 84+. To fix this: Download the latest chromedriver here . Windows version, not Linux version. Put the chrome executable, chromedriver.exe in C:\\users\\<my-windows-username>\\webdrivers\\ . Rename the executable from chromedriver.exe to chromedriver . Chromedriver should still be in your path, which you can verify: $ which chromedriver /mnt/c/users/<my-windows-username>/webdrivers/chromedriver If you came here from the Debug section of the tutorial, you're now ready to return to it and run the debugger. Click here to go back to the Debug section of the tutorial . Heroku Heroku is an easy and inexpensive service for deploying web applications (i.e. putting them online), including hemlock applications. Sign up for heroku here . If using hemlock-CLI, you can install and configure the heroku command line interface with: $ hlk setup wsl --heroku-cli This will prompt you to create and log in to a heroku account. Verify your heroku-CLI installation: $ heroku --version heroku/x.xx.x linux-x64 node-vxx.xx.x Note. See this github issue if you experience a 'EACCES' error. Do not simply use sudo ; this only masks issues you'll encounter later. Click here to return to the Deploy section of the tutorial .","title":"Windows Subsystem for Linux"},{"location":"setup/wsl/#windows-subsystem-for-linux-wsl-setup","text":"These instructions were written for Windows 10. Why WSL? The main reason I use WSL is that Windows OS doesn't have a fork (only a spoon), which means you'll need WSL if you want to run Redis. You can find download instructions for WSL here . Either WSL 1 or 2 should work. I personally use the Ubuntu distribution. After you've installed WSL, open a terminal window (WIN + R, then enter e.g. 'ubuntu2004'. You may be prompted to create a username and password.","title":"Windows Subsystem for Linux (WSL) setup"},{"location":"setup/wsl/#python3-and-pip3","text":"Python is hemlock's primary language. Pip allows you to install python packages, including hemlock and its command line interface, hemlock-CLI. Most WSL distributions come with python3. Verify your python installation with: $ python3 Python 3.x.x If you don't have python intalled on your WSL distribution, download python here . I recommend python3.6, rather than the latest version. Why? Because heroku, my recommended method of app deployment, uses python3.6, meaning that if you develop in python3.7+ and deploy in python3.6, you may encounter compatibility issues. Update your package lists: $ sudo apt-get update Install pip3: $ sudo apt install -f -y python3-pip Respond 'Yes' if asked whether you want to restart services automatically. Verify your pip3 installation: $ pip3 --version pip x.x.x from /usr/lib/python3/dist-packages ( python 3 .x ) You'll also need the ability to create virtual environments: $ apt install -f -y python3-venv","title":"Python3 and pip3"},{"location":"setup/wsl/#pip-versus-pip3","text":"You'll install several python packages using pip. Conventionally, the command to install these is: $ pip install <my-requested-package> You may need to replace this with: $ pip3 install <my-requested-package> Many hemlock-CLI commands assume you can pip install with pip3 .","title":"pip versus pip3"},{"location":"setup/wsl/#hemlock-cli","text":"Hemlock's command line interface, hemlock-CLI, defines many useful commands for initializing, editing, and deploying hemlock projects. Download with: $ pip install -U hemlock-cli Verify your hemlock-CLI installation: $ hlk --version hlk, version x.x.xx","title":"Hemlock-CLI"},{"location":"setup/wsl/#git-and-github","text":"Git is a version control system, and github hosts code repositories. Together, they allow you to share and collaborate on hemlock projects. You will also need git to initialize hemlock projects with the hemlock template. You can find git download and installation instructions here . Verify your git installation: $ git --version git version 2 .17.1 Then, create a github account here . Configure your github command line interface: $ git config --global user.name <my-github-username> $ git config --global user.email <my-github-user-email> Finally, you will need a personal access token to initialize hemlock applications with the hemlock command line interface. Read everything until STOP before creating your github token. Create a github token by following these instructions . When setting permissions (step 7), check 'repo'. Copy your token and store it somewhere accessible. For example, I store my token in a file named github_token.txt . STOP.","title":"Git and github"},{"location":"setup/wsl/#visual-studio-code","text":"I recommend visual studio code for editing python files. Read everything until STOP before downloading or installing anything. You can find download and installation instructions for VS code here . Make sure to download the Windows version, not the Linux version. STOP Close and re-open your terminal. Verify your VS code installation: $ code --version 1 .xx.x","title":"Visual studio code"},{"location":"setup/wsl/#jupyter","text":"Jupyter allows you to quickly iterate on project designs. Install jupyter notebook with pip: $ pip install -U notebook Close and re-open your terminal. Verify your jupyter installation: $ jupyter --version jupyter core : x.x.x jupyter-notebook : x.x.x ...","title":"Jupyter"},{"location":"setup/wsl/#google-chrome","text":"Hemlock is developed and tested primarily on chrome. Download chrome here . Verify that you can open it as follows: $ python3 >>> import webbrowser >>> webbrowser.open ( 'https://dsbowen.github.io/hemlock' ) True >>> exit () You should see chrome open to the hemlock docs. Note. If this doesn't work, it's probably because the chrome executable isn't in your path. Run the following: $ hlk setup wsl --chrome Close and re-open your terminal. Verify your BROWSER variable: $ echo $BROWSER /mnt/c/program files ( x86 ) /google/chrome/application/chrome.exe Now try again to open the webbrowser. If you came here from the tutorial, you're now ready to return to it and get started with your first hemlock project. Click here to go back to the First Project section of the tutorial .","title":"Google chrome"},{"location":"setup/wsl/#chromedriver","text":"Hemlock's custom debugging tool and survey view functions use chromedriver . To use these features locally, you'll need to download chromedriver: $ hlk setup wsl --chromedriver Close and re-open your terminal. Verify your chromedriver installation: $ which chromedriver /mnt/c/users/<my-windows-username>/webdrivers/chromedriver","title":"Chromedriver"},{"location":"setup/wsl/#chrome-and-chromedriver-compatibility","text":"As of 07/14/2020, hlk setup wsl --chromedriver installs chromedriver for chrome 83. While chrome updates automatically, chromedriver does not. This means that you will encounter compatibility issues when chrome updates to version 84+. To fix this: Download the latest chromedriver here . Windows version, not Linux version. Put the chrome executable, chromedriver.exe in C:\\users\\<my-windows-username>\\webdrivers\\ . Rename the executable from chromedriver.exe to chromedriver . Chromedriver should still be in your path, which you can verify: $ which chromedriver /mnt/c/users/<my-windows-username>/webdrivers/chromedriver If you came here from the Debug section of the tutorial, you're now ready to return to it and run the debugger. Click here to go back to the Debug section of the tutorial .","title":"Chrome and chromedriver compatibility"},{"location":"setup/wsl/#heroku","text":"Heroku is an easy and inexpensive service for deploying web applications (i.e. putting them online), including hemlock applications. Sign up for heroku here . If using hemlock-CLI, you can install and configure the heroku command line interface with: $ hlk setup wsl --heroku-cli This will prompt you to create and log in to a heroku account. Verify your heroku-CLI installation: $ heroku --version heroku/x.xx.x linux-x64 node-vxx.xx.x Note. See this github issue if you experience a 'EACCES' error. Do not simply use sudo ; this only masks issues you'll encounter later. Click here to return to the Deploy section of the tutorial .","title":"Heroku"},{"location":"tutorial/comp_check/","text":"Comprehension check In the previous part of the tutorial, you reviewed page logic. By the end of this part of the tutorial, you'll be able to set up comprehension checks. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Why comprehension checks? We often give our participants instructions. To make sure they understand the instructions, we give them comprehension checks. Hemlock has a built-in tool for easy comprehension checks. The structure of a comprehension check is: One or more pages of instructions. One or more pages of 'checks'. If the participant fails a check, they return to the first instructions page. Participants do not have to repeat checks that they pass. We set a limit on the number of attempts participants have to pass each check. For example, suppose there are two checks, A and B. The participant passes check A but fails check B. He is brought back to the first page of the instructions. After rereading the instructions, he is brought directly to check B, skipping check A. (Think about what it would take to do this in Qualtrics, or program this from scratch). Basic syntax Although we usually start with jupyter, the logic of comprehension checks is best illustrated by running an app. Open app.py and replace import survey with import tmp_survey . Now make a new file, tmp_survey.py , and enter the following: from hemlock import Branch , Check , Compile as C , Page , Label , Submit as S , route from hemlock.tools import comprehension_check @route ( '/survey' ) def start (): return Branch ( * comprehension_check ( instructions = Page ( Label ( '<p>Here are some instructions.</p>' ) ), checks = Page ( Check ( '<p>Select the correct choice.</p>' , [ 'Correct' , 'Incorrect' , 'Also incorrect' ], compile = [ C . clear_response (), C . shuffle ()], submit = S . correct_choices ( 'Correct' ) ) ), attempts = 3 ), Page ( Label ( '<p>You passed the comprehension check!</p>' ), terminal = True ) ) Run the app and play with the comprehension check. Notice that when you don't click the correct choice, the survey brings you back to the instructions page. Code explanation First, we import our standard hemlock objects and the comprehension_check tool. As usual, we return a branch from our navigate function. We begin the branch with a comprehension check. The comprehension check takes a list of instructions pages (or a single instructions page), a list of check pages (or a single check page), and the number of allotted attempts. The comprehension_check tool returns a list of instructions + check pages. The branch constructor expects pages, not a list of pages, to be passed in as arguments. The asterisk in *comprehension_check(...) means 'unlist' the list of instructions + check pages as you pass them into the branch constructor . The check page contains a Check question. Note that 'check' has different meanings here. A 'check page' in a comprehension check means a page where you test the participant's understanding of the instructions . A 'check question' means a question where you can check one or more choices . By default, the check question will record the participant's response and display the choices in their original order. These are both problems for testing comprehension. We don't want participants to simply click choices in order until the hit the right one. To fix this, we add two compile functions; one to clear the response, and one to shuffle the choices. A participant passes a check page when all of its questions' data evaluate to True . So, we'll add a submit function to the check question which converts its data to 1 if the participant selected the correct choice and 0 otherwise ( 1 and 0 evaluate to True and False in most programming languages). Finally, we set attempts=3 to give the participant 3 attempts to pass the check. If a participant fails the check 3 times, they'll simply continue the survey. We can require participants to pass the check by not passing an attempts parameter. Ultimatum game comprehension check We're going to use a comprehension check to explain the ultimatum game to our participants and test their understanding of it. First, open app.py and change import tmp_survey back to import survey . Instructions Open your notebook and let's preview the instructions page: from hemlock import Page , Label # the number of rounds participants play N_ROUNDS = 5 # the amount of money split POT = 20 Page ( Label ( ''' <p>You are about to play an ultimatum game. The game involves two players: a <b>proposer</b> and a <b>responder</b>. The proposer has ${} to split between him/herself and the responder. The responder names an amount of money such that he/she accepts any proposed split which gives him/her at least this amount, and rejects any proposed split which gives him/her less than this amount.</p> <p><b>If the split is accepted, the proposer and responder split the money according to the proposal. If the split is rejected, both players receive $0.</b></p> <p>You will play {} rounds of this game. Each round, you will be paired with another randomly selected participant. <b>You will rarely, if ever, play two rounds with the same player.</b> <p>We will test your understanding of these instructions on the next page.</p> ''' . format ( POT , N_ROUNDS ) ) ) . preview () Checks For the check pages, we're going to give participants a hypothetical proposal and response and ask them how much money the proposer and responder receive. We'll do this twice; once where the proposal is accepted, the other where it is rejected. Additionally, we want to avoid biasing participants' responses by giving them all the same hypothetical proposal-response pairs. So, we'll write a function to randomly generate proposals. Enter the following in your notebook: from hemlock import Compile as C , Input def gen_check_page ( accept ): return Page ( Label (), Input ( '<p>How much money does the proposer receive?</p>' , prepend = '$' , append = '.00' ), Input ( '<p>How much money does the responder receive?</p>' , prepend = '$' , append = '.00' ), compile = [ C . clear_response (), C . random_proposal ( accept )] ) @C . register def random_proposal ( check_page , accept ): # WE'LL WRITE THIS FUNCTION IN A MOMENT pass gen_check_page ( accept = True ) . preview () The gen_check_page function generates a check page. The Label with which the page starts is going to be populated by a randomly generated proposal-response pair which we'll create with the compile function random_proposal . Both gen_check_page and random_proposal take an accept argument which indicates whether the proposal will be accepted or rejected. Now, fill in the random_proposal function in the same notebook cell: from hemlock import Compile as C , Input , Submit as S from random import randint ... @C . register def random_proposal ( check_page , accept ): # randomly generate a proposed split and response n = randint ( 1 , POT - 1 ) proposal = POT - n , n # proposer receives POT-n, responder receives n response = randint ( 0 , n ) if accept else randint ( n + 1 , POT ) # compute the payoff payoff = proposal if response <= proposal [ 1 ] else ( 0 , 0 ) # describe the proposal and response in the label check_page . questions [ 0 ] . label = ''' <p>Imagine the proposer proposes the following split:</p> <ul> <li>Proposer: $ {} </li> <li>Responder: $ {} </li> </ul> <p>The responder says, \"I will accept any proposal which gives me at least $ {} .\"</p> ''' . format ( * proposal , response ) # add submit functions to verify that the response was correct check_page . questions [ 1 ] . submit = S . match ( str ( payoff [ 0 ])) check_page . questions [ 2 ] . submit = S . match ( str ( payoff [ 1 ])) gen_check_page ( accept = True ) . _compile () . preview () random_proposal begins by generating a random proposal. We then generate a random response which will accept the proposal if accept is True and reject the proposal if accept is False . The payoff is the proposal if the proposal is accepted and (0,0) if the proposal is rejected. We then fill in the check page's label with the proposal and response. Finally, we add submit functions to the check page's input questions to verify that the participant's responses match the payoffs. Adding a comprehension check to our app Let's put this all together in survey.py : ... from hemlock.tools import comprehension_check , join from datetime import datetime from random import randint # the number of rounds participants play N_ROUNDS = 5 # the amount of money split POT = 20 ... @N . register def ultimatum_game ( start_branch ): return Branch ( * comprehension_check ( instructions = Page ( # CONTENT OF INSTRUCTIONS PAGE HERE ), checks = [ gen_check_page ( accept = True ), gen_check_page ( accept = False )] ), Page ( Label ( '<p>You passed the check!</p>' ), terminal = True ) ) def gen_check_page ( accept ): # GEN CHECK PAGE FUNCTION HERE @C . register def random_proposal ( check_page , accept ): # RANDOM PROPOSAL FUNCTION HERE Run your app and see your comprehension check at work! Summary In this part of the tutorial, you learned how to add comprehension checks to your studies. In the next part of the tutorial, you'll learn how to assign participants to conditions.","title":"Comprehension check"},{"location":"tutorial/comp_check/#comprehension-check","text":"In the previous part of the tutorial, you reviewed page logic. By the end of this part of the tutorial, you'll be able to set up comprehension checks. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial.","title":"Comprehension check"},{"location":"tutorial/comp_check/#why-comprehension-checks","text":"We often give our participants instructions. To make sure they understand the instructions, we give them comprehension checks. Hemlock has a built-in tool for easy comprehension checks. The structure of a comprehension check is: One or more pages of instructions. One or more pages of 'checks'. If the participant fails a check, they return to the first instructions page. Participants do not have to repeat checks that they pass. We set a limit on the number of attempts participants have to pass each check. For example, suppose there are two checks, A and B. The participant passes check A but fails check B. He is brought back to the first page of the instructions. After rereading the instructions, he is brought directly to check B, skipping check A. (Think about what it would take to do this in Qualtrics, or program this from scratch).","title":"Why comprehension checks?"},{"location":"tutorial/comp_check/#basic-syntax","text":"Although we usually start with jupyter, the logic of comprehension checks is best illustrated by running an app. Open app.py and replace import survey with import tmp_survey . Now make a new file, tmp_survey.py , and enter the following: from hemlock import Branch , Check , Compile as C , Page , Label , Submit as S , route from hemlock.tools import comprehension_check @route ( '/survey' ) def start (): return Branch ( * comprehension_check ( instructions = Page ( Label ( '<p>Here are some instructions.</p>' ) ), checks = Page ( Check ( '<p>Select the correct choice.</p>' , [ 'Correct' , 'Incorrect' , 'Also incorrect' ], compile = [ C . clear_response (), C . shuffle ()], submit = S . correct_choices ( 'Correct' ) ) ), attempts = 3 ), Page ( Label ( '<p>You passed the comprehension check!</p>' ), terminal = True ) ) Run the app and play with the comprehension check. Notice that when you don't click the correct choice, the survey brings you back to the instructions page.","title":"Basic syntax"},{"location":"tutorial/comp_check/#code-explanation","text":"First, we import our standard hemlock objects and the comprehension_check tool. As usual, we return a branch from our navigate function. We begin the branch with a comprehension check. The comprehension check takes a list of instructions pages (or a single instructions page), a list of check pages (or a single check page), and the number of allotted attempts. The comprehension_check tool returns a list of instructions + check pages. The branch constructor expects pages, not a list of pages, to be passed in as arguments. The asterisk in *comprehension_check(...) means 'unlist' the list of instructions + check pages as you pass them into the branch constructor . The check page contains a Check question. Note that 'check' has different meanings here. A 'check page' in a comprehension check means a page where you test the participant's understanding of the instructions . A 'check question' means a question where you can check one or more choices . By default, the check question will record the participant's response and display the choices in their original order. These are both problems for testing comprehension. We don't want participants to simply click choices in order until the hit the right one. To fix this, we add two compile functions; one to clear the response, and one to shuffle the choices. A participant passes a check page when all of its questions' data evaluate to True . So, we'll add a submit function to the check question which converts its data to 1 if the participant selected the correct choice and 0 otherwise ( 1 and 0 evaluate to True and False in most programming languages). Finally, we set attempts=3 to give the participant 3 attempts to pass the check. If a participant fails the check 3 times, they'll simply continue the survey. We can require participants to pass the check by not passing an attempts parameter.","title":"Code explanation"},{"location":"tutorial/comp_check/#ultimatum-game-comprehension-check","text":"We're going to use a comprehension check to explain the ultimatum game to our participants and test their understanding of it. First, open app.py and change import tmp_survey back to import survey .","title":"Ultimatum game comprehension check"},{"location":"tutorial/comp_check/#instructions","text":"Open your notebook and let's preview the instructions page: from hemlock import Page , Label # the number of rounds participants play N_ROUNDS = 5 # the amount of money split POT = 20 Page ( Label ( ''' <p>You are about to play an ultimatum game. The game involves two players: a <b>proposer</b> and a <b>responder</b>. The proposer has ${} to split between him/herself and the responder. The responder names an amount of money such that he/she accepts any proposed split which gives him/her at least this amount, and rejects any proposed split which gives him/her less than this amount.</p> <p><b>If the split is accepted, the proposer and responder split the money according to the proposal. If the split is rejected, both players receive $0.</b></p> <p>You will play {} rounds of this game. Each round, you will be paired with another randomly selected participant. <b>You will rarely, if ever, play two rounds with the same player.</b> <p>We will test your understanding of these instructions on the next page.</p> ''' . format ( POT , N_ROUNDS ) ) ) . preview ()","title":"Instructions"},{"location":"tutorial/comp_check/#checks","text":"For the check pages, we're going to give participants a hypothetical proposal and response and ask them how much money the proposer and responder receive. We'll do this twice; once where the proposal is accepted, the other where it is rejected. Additionally, we want to avoid biasing participants' responses by giving them all the same hypothetical proposal-response pairs. So, we'll write a function to randomly generate proposals. Enter the following in your notebook: from hemlock import Compile as C , Input def gen_check_page ( accept ): return Page ( Label (), Input ( '<p>How much money does the proposer receive?</p>' , prepend = '$' , append = '.00' ), Input ( '<p>How much money does the responder receive?</p>' , prepend = '$' , append = '.00' ), compile = [ C . clear_response (), C . random_proposal ( accept )] ) @C . register def random_proposal ( check_page , accept ): # WE'LL WRITE THIS FUNCTION IN A MOMENT pass gen_check_page ( accept = True ) . preview () The gen_check_page function generates a check page. The Label with which the page starts is going to be populated by a randomly generated proposal-response pair which we'll create with the compile function random_proposal . Both gen_check_page and random_proposal take an accept argument which indicates whether the proposal will be accepted or rejected. Now, fill in the random_proposal function in the same notebook cell: from hemlock import Compile as C , Input , Submit as S from random import randint ... @C . register def random_proposal ( check_page , accept ): # randomly generate a proposed split and response n = randint ( 1 , POT - 1 ) proposal = POT - n , n # proposer receives POT-n, responder receives n response = randint ( 0 , n ) if accept else randint ( n + 1 , POT ) # compute the payoff payoff = proposal if response <= proposal [ 1 ] else ( 0 , 0 ) # describe the proposal and response in the label check_page . questions [ 0 ] . label = ''' <p>Imagine the proposer proposes the following split:</p> <ul> <li>Proposer: $ {} </li> <li>Responder: $ {} </li> </ul> <p>The responder says, \"I will accept any proposal which gives me at least $ {} .\"</p> ''' . format ( * proposal , response ) # add submit functions to verify that the response was correct check_page . questions [ 1 ] . submit = S . match ( str ( payoff [ 0 ])) check_page . questions [ 2 ] . submit = S . match ( str ( payoff [ 1 ])) gen_check_page ( accept = True ) . _compile () . preview () random_proposal begins by generating a random proposal. We then generate a random response which will accept the proposal if accept is True and reject the proposal if accept is False . The payoff is the proposal if the proposal is accepted and (0,0) if the proposal is rejected. We then fill in the check page's label with the proposal and response. Finally, we add submit functions to the check page's input questions to verify that the participant's responses match the payoffs.","title":"Checks"},{"location":"tutorial/comp_check/#adding-a-comprehension-check-to-our-app","text":"Let's put this all together in survey.py : ... from hemlock.tools import comprehension_check , join from datetime import datetime from random import randint # the number of rounds participants play N_ROUNDS = 5 # the amount of money split POT = 20 ... @N . register def ultimatum_game ( start_branch ): return Branch ( * comprehension_check ( instructions = Page ( # CONTENT OF INSTRUCTIONS PAGE HERE ), checks = [ gen_check_page ( accept = True ), gen_check_page ( accept = False )] ), Page ( Label ( '<p>You passed the check!</p>' ), terminal = True ) ) def gen_check_page ( accept ): # GEN CHECK PAGE FUNCTION HERE @C . register def random_proposal ( check_page , accept ): # RANDOM PROPOSAL FUNCTION HERE Run your app and see your comprehension check at work!","title":"Adding a comprehension check to our app"},{"location":"tutorial/comp_check/#summary","text":"In this part of the tutorial, you learned how to add comprehension checks to your studies. In the next part of the tutorial, you'll learn how to assign participants to conditions.","title":"Summary"},{"location":"tutorial/compile/","text":"Compile In the previous part of the tutorial, you learned how to run functions to handle form submission. In this part of the tutorial, you'll implement a confirmation page using compile functions. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Why compile functions? Compile functions run just before a page's html is compiled. This allows us to make our survey responsive to participants. In our case, we're going to make a confirmation page for the participant's demographic information. Basic syntax Open your jupyter notebook and run the following: from hemlock import Check , Compile as C check = Check ( '<p>Select the correct answer.</p>' , [ 'Correct' , 'Incorrect' , 'Also incorrect' ], compile = C . shuffle () ) check . compile Out: [<Compile 1>] You can add compile functions to a page or question by setting its compile attribute or passing a compile argument to its constructor. Compile functions run just before a page's html is compiled. The shuffle compile function shuffles a question's choices. (Or, if attached to a page, shuffles its page's questions). Let's watch our compile function at work: check._compile() [choice.label for choice in check.choices] Out: ['Incorrect', 'Also incorrect', 'Correct'] Run this a few times and notice how the order of the choices changes. This behavior is useful for comprehension checks, as we'll see later. Notes. You don't need to run _compile yourself in the survey; hemlock takes care of this automatically for you. shuffle is just one of many prebuilt compile functions . Custom compilation We're going to take the participant's responses to the demographics page and display them on a new page. We'll ask the participant to correct any errors by going back to the demographics page. Let's see how to do this in our notebook: from hemlock import Input , Label , Page , Range , Select from hemlock.tools import join @C . register def confirm ( confirm_label , demographics_page ): # get the participant's data from the demographics page demographics = [ q . data for q in demographics_page . questions ] # re-format the race demographic data race = demographics_page . questions [ 2 ] race = join ( 'and' , * ( key for key in race . data if race . data [ key ])) demographics [ 2 ] = race # set the label based on the participant's demographics data confirm_label . label = ''' <p>Confirm the following information:</p> <ul> <li>Date of birth: {} </li> <li>Gender: {} </li> <li>Race/Ethnicity: {} </li> <li>Marital status: {} </li> <li>Subjective socio-economic status: {} </li> </ul> <p>To correct this information, click '<<'.</p> ''' . format ( * demographics ) demographics_page = Page ( Input ( data = '10/26/1992' ), Check ( data = 'Male' ), Check ( data = { 'White' : 1 , 'Black' : 1 }), Select ( data = 'Never married' ), Range ( data = '5' ) ) confirm_page = Page ( Label ( compile = C . confirm ( demographics_page )), back = True ) confirm_page . _compile () . preview () Code explanation First, we register a new compile function with the @C.register decorator. The compile function takes the confirmation label as its first argument. In general, compile functions take their parent as their first argument. We also pass in the demographics page as the compile function's second argument. Next, we add a back button to the page with back=True . Then, we compile and preview the page. confirm begins by gathering the demographics data from the demographics page. The data are well formatted to insert into our confirmation page except for race. For Check and Select questions, if the participant can select multiple choices, the data are stored as a dictionary mapping choice values ( 'White' , 'Black' , etc.) to a 0-1 indicator that the participant selected that choice. We fix this with the following: from hemlock.tools import join race_data = demographics_page . questions [ 2 ] . data race = join ( 'and' , * ( key for key in race_data if race_data [ key ])) demographics [ 2 ] = race Note that race_data[key] evaluates to True if the key ( 'White' , 'Black' , etc.) was selected. So the expression (key for key in race_data if race_data[key]) means 'get all the keys (races) the participant selected'. The expression join ( 'and' , * ( key for key in race_data if race_data [ key ])) means 'join all of the selected keys with \"and\", e.g. \"White and Black\"'. Finally, confirm adds the demographics to the confirmation label. Compilation in our app Now that we've seen how to add compile functions in our notebook, let's add it to our app. In survey.py : from hemlock import Branch , Check , Compile as C , Embedded , Input , Label , Page , Range , Select , Submit as S , Validate as V , route from hemlock.tools import join from datetime import datetime @route ( '/survey' ) def start (): demographics_page = Page ( Input ( '<p>Enter your date of birth.</p>' , placeholder = 'mm/dd/yyyy' , var = 'DoB' , data_rows =- 1 , validate = [ V . require (), V . date_format ()], submit = S . record_age () ), # REST OF THE DEMOGRAPHICS PAGE HERE ) return Branch ( demographics_page , Page ( Label ( compile = C . confirm ( demographics_page )), back = True , terminal = True ) ) ... @C . register def confirm ( confirm_label , demographics_page ): # PUT YOUR COMPILE FUNCTION HERE Run the app again to see your confirmation page. Summary In this part of the tutorial, you implemented a confirmation page using compile functions. In the next part of the tutorial, you'll learn how to set up navigation between branches.","title":"Compile"},{"location":"tutorial/compile/#compile","text":"In the previous part of the tutorial, you learned how to run functions to handle form submission. In this part of the tutorial, you'll implement a confirmation page using compile functions. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial.","title":"Compile"},{"location":"tutorial/compile/#why-compile-functions","text":"Compile functions run just before a page's html is compiled. This allows us to make our survey responsive to participants. In our case, we're going to make a confirmation page for the participant's demographic information.","title":"Why compile functions?"},{"location":"tutorial/compile/#basic-syntax","text":"Open your jupyter notebook and run the following: from hemlock import Check , Compile as C check = Check ( '<p>Select the correct answer.</p>' , [ 'Correct' , 'Incorrect' , 'Also incorrect' ], compile = C . shuffle () ) check . compile Out: [<Compile 1>] You can add compile functions to a page or question by setting its compile attribute or passing a compile argument to its constructor. Compile functions run just before a page's html is compiled. The shuffle compile function shuffles a question's choices. (Or, if attached to a page, shuffles its page's questions). Let's watch our compile function at work: check._compile() [choice.label for choice in check.choices] Out: ['Incorrect', 'Also incorrect', 'Correct'] Run this a few times and notice how the order of the choices changes. This behavior is useful for comprehension checks, as we'll see later. Notes. You don't need to run _compile yourself in the survey; hemlock takes care of this automatically for you. shuffle is just one of many prebuilt compile functions .","title":"Basic syntax"},{"location":"tutorial/compile/#custom-compilation","text":"We're going to take the participant's responses to the demographics page and display them on a new page. We'll ask the participant to correct any errors by going back to the demographics page. Let's see how to do this in our notebook: from hemlock import Input , Label , Page , Range , Select from hemlock.tools import join @C . register def confirm ( confirm_label , demographics_page ): # get the participant's data from the demographics page demographics = [ q . data for q in demographics_page . questions ] # re-format the race demographic data race = demographics_page . questions [ 2 ] race = join ( 'and' , * ( key for key in race . data if race . data [ key ])) demographics [ 2 ] = race # set the label based on the participant's demographics data confirm_label . label = ''' <p>Confirm the following information:</p> <ul> <li>Date of birth: {} </li> <li>Gender: {} </li> <li>Race/Ethnicity: {} </li> <li>Marital status: {} </li> <li>Subjective socio-economic status: {} </li> </ul> <p>To correct this information, click '<<'.</p> ''' . format ( * demographics ) demographics_page = Page ( Input ( data = '10/26/1992' ), Check ( data = 'Male' ), Check ( data = { 'White' : 1 , 'Black' : 1 }), Select ( data = 'Never married' ), Range ( data = '5' ) ) confirm_page = Page ( Label ( compile = C . confirm ( demographics_page )), back = True ) confirm_page . _compile () . preview ()","title":"Custom compilation"},{"location":"tutorial/compile/#code-explanation","text":"First, we register a new compile function with the @C.register decorator. The compile function takes the confirmation label as its first argument. In general, compile functions take their parent as their first argument. We also pass in the demographics page as the compile function's second argument. Next, we add a back button to the page with back=True . Then, we compile and preview the page. confirm begins by gathering the demographics data from the demographics page. The data are well formatted to insert into our confirmation page except for race. For Check and Select questions, if the participant can select multiple choices, the data are stored as a dictionary mapping choice values ( 'White' , 'Black' , etc.) to a 0-1 indicator that the participant selected that choice. We fix this with the following: from hemlock.tools import join race_data = demographics_page . questions [ 2 ] . data race = join ( 'and' , * ( key for key in race_data if race_data [ key ])) demographics [ 2 ] = race Note that race_data[key] evaluates to True if the key ( 'White' , 'Black' , etc.) was selected. So the expression (key for key in race_data if race_data[key]) means 'get all the keys (races) the participant selected'. The expression join ( 'and' , * ( key for key in race_data if race_data [ key ])) means 'join all of the selected keys with \"and\", e.g. \"White and Black\"'. Finally, confirm adds the demographics to the confirmation label.","title":"Code explanation"},{"location":"tutorial/compile/#compilation-in-our-app","text":"Now that we've seen how to add compile functions in our notebook, let's add it to our app. In survey.py : from hemlock import Branch , Check , Compile as C , Embedded , Input , Label , Page , Range , Select , Submit as S , Validate as V , route from hemlock.tools import join from datetime import datetime @route ( '/survey' ) def start (): demographics_page = Page ( Input ( '<p>Enter your date of birth.</p>' , placeholder = 'mm/dd/yyyy' , var = 'DoB' , data_rows =- 1 , validate = [ V . require (), V . date_format ()], submit = S . record_age () ), # REST OF THE DEMOGRAPHICS PAGE HERE ) return Branch ( demographics_page , Page ( Label ( compile = C . confirm ( demographics_page )), back = True , terminal = True ) ) ... @C . register def confirm ( confirm_label , demographics_page ): # PUT YOUR COMPILE FUNCTION HERE Run the app again to see your confirmation page.","title":"Compilation in our app"},{"location":"tutorial/compile/#summary","text":"In this part of the tutorial, you implemented a confirmation page using compile functions. In the next part of the tutorial, you'll learn how to set up navigation between branches.","title":"Summary"},{"location":"tutorial/data/","text":"Data In the previous part of the tutorial, you learned how to create a demographics questionnaire using several question polymorphs. By the end of this part of the tutorial, you'll be able to store and download data. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Previewing data from a single participant Each hemlock project has a downloadable data frame containing the data for all participants. We'll start by looking at the data belonging to a 'test participant'. Run the following in your jupyter notebook: from hemlock import Participant part = Participant . gen_test_participant () dict ( part . get_data ()) Out: {'ID': [1], 'EndTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'StartTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'Status': ['InProgress']} This shows the data our test participant contributes to the data frame. The keys are variable names, and values are list of entries for that variable. An easy way to add data is with 'embedded data': from hemlock import Embedded part . embedded = [ Embedded ( var = 'MyVariable' , data = 'MyData' )] dict ( part . get_data ()) Out: {'ID': [1], 'EndTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'StartTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'Status': ['InProgress'], 'MyVariable': ['MyData'], 'MyVariableOrder': [0], 'MyVariableIndex': [0]} This adds an Embedded data object to our participant. Embedded data are a type of data element, like questions, but unlike questions, are not displayed to participants. We can add embedded data to a participant, branch, or page. When we examine the data, we see that the participant has a new variable named 'MyVariable' with data ['MyData'] . We also see two additional variables named 'MyVariableOrder' and 'MyVariableIndex' . Hemlock automatically adds order and index data for every data element. Order is the order in which this data element appeared in the survey, relative to other data elements belonging to the same variable. Index is the order in which this data element appeared in its parent's list of children; for example, the order in which a question appeared on its page. Ordering The order in which data elements appear in the data frame is the order in which they were created; not necessarily the order in which they appear to the participant. For example: embedded1 = Embedded ( 'MyVariable' , 1 ) embedded0 = Embedded ( 'MyVariable' , 0 ) part . embedded = [ embedded0 , embedded1 ] dict ( part . get_data ()) Out: {'ID': [1, 1], 'EndTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'StartTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'Status': ['InProgress', 'InProgress'], 'MyVariable': [1, 0], 'MyVariableOrder': [1, 0], 'MyVariableIndex': [1, 0]} Note that the data for 'MyVariable' are [1, 0] because we created embedded1 before embedded0 . Data rows By default, data elements (embedded data and questions) contribute 1 row to the data frame. But we often want the same data to be repeated on multiple rows. We do this by setting the data_rows attribute: part . embedded = [ Embedded ( 'MyVariable' , 'MyData' , data_rows = 3 )] dict ( part . get_data ()) Out: {'ID': [1, 1, 1], 'EndTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'StartTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'Status': ['InProgress', 'InProgress', 'InProgress'], 'MyVariable': ['MyData', 'MyData', 'MyData'], 'MyVariableOrder': [0, 0, 0], 'MyVariableIndex': [0, 0, 0]} Additionally, we often want to 'fill in' rows of a variable to match the length of a data frame. For example, we may not know in advance how many rows a participant will contribute to the data frame, but we know that we want the participant's demographic information to appear on all rows. To do this, we set data_rows to a negative number. For example, data_rows=-2 means 'fill in two rows with this data entry and, when you download the data, fill in any blank rows after this with the same data': part . embedded = [ # these data will fill in empty rows at the bottom of the data frame Embedded ( 'MyFilledVariable' , 'MyFilledData' , data_rows =- 1 ), # these data will appear on three rows of the data frame Embedded ( 'MyVariable' , 'MyData' , data_rows = 3 ) ] dict ( part . get_data ())[ 'MyFilledVariable' ] Out: ['MyFilledData', 'MyFilledData', 'MyFilledData'] Adding data to our survey We can add data to our existing survey in much the same way: by setting a question's var and (when necessary) data_rows attribute. We generally want demographics information to appear in all rows of the data frame, so we'll set data_rows=-1 . In survey.py : ... @route ( '/survey' ) def start (): return Branch ( Page ( Input ( '<p>Enter your date of birth.</p>' , placeholder = 'mm/dd/yyyy' , var = 'DoB' , data_rows =- 1 ), Check ( '<p>Indicate your gender.</p>' , [ 'Male' , 'Female' , 'Other' ], var = 'Gender' , data_rows =- 1 ), # SET THE `var` AND `data_rows` ATTRIBUTES FOR THE REST OF THE QUESTIONS ... Note. When a participant submits a page, the questions' data are recorded in a data attribute. A question's data will be added to the data frame if and only if you set its var attribute. However, data will be stored in a question's data attribute whether or not the var attribute is set. Downloading data Run your survey locally, fill in the demographics page, and continue to the end of the survey. Your data will be recorded in the database. To download your data, navigate to http://localhost:5000/download in your browser. Select 'Data frame', then click the download button. This will download a zip file containing your data in .csv format. Take a look at the data. In addition to what we've already covered, there are a few things to notice: Variables like GenderMaleIndex and GenderFemaleIndex record the order in which a question displayed its choices. The data of questions for which you can select multiple choices are automatically one-hot encoded. For example, if RaceWhite and RaceAsian are both 1, and the rest of the race variables are 0, this means means the participant is part White and part Asian. Summary In this part of the tutorial, you learned how to store and download data. In the next part of the tutorial, you'll implement validation for participant responses.","title":"Data"},{"location":"tutorial/data/#data","text":"In the previous part of the tutorial, you learned how to create a demographics questionnaire using several question polymorphs. By the end of this part of the tutorial, you'll be able to store and download data. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial.","title":"Data"},{"location":"tutorial/data/#previewing-data-from-a-single-participant","text":"Each hemlock project has a downloadable data frame containing the data for all participants. We'll start by looking at the data belonging to a 'test participant'. Run the following in your jupyter notebook: from hemlock import Participant part = Participant . gen_test_participant () dict ( part . get_data ()) Out: {'ID': [1], 'EndTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'StartTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'Status': ['InProgress']} This shows the data our test participant contributes to the data frame. The keys are variable names, and values are list of entries for that variable. An easy way to add data is with 'embedded data': from hemlock import Embedded part . embedded = [ Embedded ( var = 'MyVariable' , data = 'MyData' )] dict ( part . get_data ()) Out: {'ID': [1], 'EndTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'StartTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'Status': ['InProgress'], 'MyVariable': ['MyData'], 'MyVariableOrder': [0], 'MyVariableIndex': [0]} This adds an Embedded data object to our participant. Embedded data are a type of data element, like questions, but unlike questions, are not displayed to participants. We can add embedded data to a participant, branch, or page. When we examine the data, we see that the participant has a new variable named 'MyVariable' with data ['MyData'] . We also see two additional variables named 'MyVariableOrder' and 'MyVariableIndex' . Hemlock automatically adds order and index data for every data element. Order is the order in which this data element appeared in the survey, relative to other data elements belonging to the same variable. Index is the order in which this data element appeared in its parent's list of children; for example, the order in which a question appeared on its page.","title":"Previewing data from a single participant"},{"location":"tutorial/data/#ordering","text":"The order in which data elements appear in the data frame is the order in which they were created; not necessarily the order in which they appear to the participant. For example: embedded1 = Embedded ( 'MyVariable' , 1 ) embedded0 = Embedded ( 'MyVariable' , 0 ) part . embedded = [ embedded0 , embedded1 ] dict ( part . get_data ()) Out: {'ID': [1, 1], 'EndTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'StartTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'Status': ['InProgress', 'InProgress'], 'MyVariable': [1, 0], 'MyVariableOrder': [1, 0], 'MyVariableIndex': [1, 0]} Note that the data for 'MyVariable' are [1, 0] because we created embedded1 before embedded0 .","title":"Ordering"},{"location":"tutorial/data/#data-rows","text":"By default, data elements (embedded data and questions) contribute 1 row to the data frame. But we often want the same data to be repeated on multiple rows. We do this by setting the data_rows attribute: part . embedded = [ Embedded ( 'MyVariable' , 'MyData' , data_rows = 3 )] dict ( part . get_data ()) Out: {'ID': [1, 1, 1], 'EndTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'StartTime': [datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552), datetime.datetime(2020, 7, 8, 11, 46, 54, 462552)], 'Status': ['InProgress', 'InProgress', 'InProgress'], 'MyVariable': ['MyData', 'MyData', 'MyData'], 'MyVariableOrder': [0, 0, 0], 'MyVariableIndex': [0, 0, 0]} Additionally, we often want to 'fill in' rows of a variable to match the length of a data frame. For example, we may not know in advance how many rows a participant will contribute to the data frame, but we know that we want the participant's demographic information to appear on all rows. To do this, we set data_rows to a negative number. For example, data_rows=-2 means 'fill in two rows with this data entry and, when you download the data, fill in any blank rows after this with the same data': part . embedded = [ # these data will fill in empty rows at the bottom of the data frame Embedded ( 'MyFilledVariable' , 'MyFilledData' , data_rows =- 1 ), # these data will appear on three rows of the data frame Embedded ( 'MyVariable' , 'MyData' , data_rows = 3 ) ] dict ( part . get_data ())[ 'MyFilledVariable' ] Out: ['MyFilledData', 'MyFilledData', 'MyFilledData']","title":"Data rows"},{"location":"tutorial/data/#adding-data-to-our-survey","text":"We can add data to our existing survey in much the same way: by setting a question's var and (when necessary) data_rows attribute. We generally want demographics information to appear in all rows of the data frame, so we'll set data_rows=-1 . In survey.py : ... @route ( '/survey' ) def start (): return Branch ( Page ( Input ( '<p>Enter your date of birth.</p>' , placeholder = 'mm/dd/yyyy' , var = 'DoB' , data_rows =- 1 ), Check ( '<p>Indicate your gender.</p>' , [ 'Male' , 'Female' , 'Other' ], var = 'Gender' , data_rows =- 1 ), # SET THE `var` AND `data_rows` ATTRIBUTES FOR THE REST OF THE QUESTIONS ... Note. When a participant submits a page, the questions' data are recorded in a data attribute. A question's data will be added to the data frame if and only if you set its var attribute. However, data will be stored in a question's data attribute whether or not the var attribute is set.","title":"Adding data to our survey"},{"location":"tutorial/data/#downloading-data","text":"Run your survey locally, fill in the demographics page, and continue to the end of the survey. Your data will be recorded in the database. To download your data, navigate to http://localhost:5000/download in your browser. Select 'Data frame', then click the download button. This will download a zip file containing your data in .csv format. Take a look at the data. In addition to what we've already covered, there are a few things to notice: Variables like GenderMaleIndex and GenderFemaleIndex record the order in which a question displayed its choices. The data of questions for which you can select multiple choices are automatically one-hot encoded. For example, if RaceWhite and RaceAsian are both 1, and the rest of the race variables are 0, this means means the participant is part White and part Asian.","title":"Downloading data"},{"location":"tutorial/data/#summary","text":"In this part of the tutorial, you learned how to store and download data. In the next part of the tutorial, you'll implement validation for participant responses.","title":"Summary"},{"location":"tutorial/debug/","text":"Debugging In the previous part of the tutorial, you implemented the responder branch. By the end of this part of the tutorial, you'll be able to use hemlock's debugging tool to make sure your app is running smoothly. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Why a custom debugging tool? In the early days of hemlock, I coded a study in which I asked participants to estimate the ages of people in photographs. I used a submit function to change their data from strings to integers. Everything was running smoothly until one mischievous participant entered 'twenty-seven', breaking my survey and sending me home in a fit of rage. Since then, I've rewritten my submit functions to be more fault tolerant. If you run from hemlock import Input , Submit as S Input ( data = 'twenty-seven' , submit = S . data_type ( int )) . _submit () . data it doesn't break; it simply converts the data to None . But that wasn't good enough. We often underestimate just how strangely participants will respond to our studies in ways that we can't foresee. To mitigate this problem, I wrote a custom debugging tool for hemlock. The tool sends an AI participant through your survey to check things out. 'AI participant' is a bit of a misnomer; if anything, it's an artificially stupid participant. It clicks random buttons, enters random things into inputs and text boxes, drags range sliders to random values; basically stress testing your code. Setup To run hemlock's custom debugging tool locally, you'll need Google Chrome and Chromedriver . Check out the setup page for your OS for specific instructions: Windows Windows Subsystem for Linux Mac Linux Basic syntax Open your jupyter notebook and run the following: from hemlock import Debug as D , Input inpt = Input ( debug = D . send_keys ( 'hello world' )) inpt . debug Out: [<Debug 1>] You can add debug functions to a page or quesiton by settings its debug attribute or passing a debug argument to its constructor. Debug functions run when we run the debugger (in just a moment). As its name suggests, the send_keys debug function tells the AI participant to send keys to the input. Let's watch our debug function at work: from hemlock import Page from hemlock.tools import chromedriver driver = chromedriver () p = Page ( inpt ) p . debug . pop () p . preview ( driver ) . _debug ( driver ) First, we use chromedriver to open Chromedriver with selenium python . Next, we create a page with our input question. We then pop the last debug function from the page we created. Why? By default, pages have two debug functions. The first executes its questions' debug methods in random order; as if the participant were randomly jumping between questions on a page. The second debug function randomly clicks a forward or back button (if it exists), or refreshes the page. Popping the last debug function prevents the debugger from navigating, which allows us to see more clearly what the debugger is doing in preview mode. Finally, we run the debug function. You'll notice it enters 'hello world' in the input. After you're done, close the driver: driver . close () Notes. You don't need to run _debug yourself in the survey; hemlock takes care of this automatically for you. send_keys is just one of many prebuilt debug functions . Default debug functions We can attach debug functions to pages or questions. Most questions have a default debug function. For example, input questions have a default debug function which sends random ASCII characters to the input. You can see the default debug function at work by running: p = Page ( Input ()) p . debug . pop () p . preview ( driver ) . _debug ( driver ) However, sometimes we need to attach additional debug functions. For example, our study begins by asking participants to enter their date of birth in mm/dd/yyyy format. If you wait for the default debug function to randomly enter a string which matches that pattern, you might not end up running your study before Trump releases his tax returns. Instead, we'll use something like: Input ( '<p>Enter your date of birth.</p>' , debug = D . send_keys ( '10/26/1992' ) ) Unfortunately, this will not work effectively as a debugger. Sometimes we want the debugger to enter nonsense, and sometimes we want it to enter something sensible. To specify this behavior, we can modify the above: Input ( '<p>Enter your date of birth.</p>' , debug = [ D . send_keys (), D . send_keys ( '10/26/1992' , p_exec =. 8 )] ) The first debug function, send_keys() , sends random keys to the input. The second debug function send_keys('10/26/1992') , sends '10/26/1992' to the input. We also pass p_exec=.8 to the second debug function, which specifies its probability of executing. In English, we're telling the debugger, enter something random, then, with 80% probability, enter something sensible . Custom debug functions We won't need custom debug functions for our survey, but you may need them elsewhere. Creating custom debug function is similar to creating custom compile, validate, etc. functions, with one important difference: while the functions you've seen take their parent as their first argument, debug functions take a selenium webdriver as their first argument and their parent as their second argument: @D . register def f ( driver , parent ): # debug something If you're serious about writing custom debug functions, I recommend checking out the source code for inspiration. Debugging our app First, import Debug at the top of survey.py : from hemlock import Branch , Check , Compile as C , Debug as D , Embedded , Input , Label , Navigate as N , Page , Range , Select , Submit as S , Validate as V , route ... Our app can be debugged largely with default debug functions. The exceptions are, 1) the date of birth input, 2) the comprehension check, 3) proposals and responses. Date of birth Modify survey.py as follows: ... @route ( '/survey' ) def start (): demographics_page = Page ( Input ( '<p>Enter your date of birth.</p>' , ... debug = [ D . send_keys (), D . send_keys ( '10/26/1992' , p_exec =. 8 )] ), ... Comprehension checks Because there is no attempt limit for our comprehension check, unless we tell the debugger to enter the correct answers, it's going to keep looping back to the instructions page. ... @Compile . register def random_proposal ( check_page , accept ): ... check_page . questions [ 1 ] . debug = [ D . send_keys (), D . send_keys ( str ( payoff [ 0 ]), p_exec =. 8 ) ] check_page . questions [ 2 ] . debug = [ D . send_keys (), D . send_keys ( str ( payoff [ 1 ]), p_exec =. 8 ) ] ... Proposals and responses It's unlikely the debugger will enter an integer between 0 and the size of the pot, so we'll give our debugger some help: ... def gen_proposal_input ( round_ ): return Input ( ... debug = [ D . send_keys (), D . send_keys ( str ( randint ( 0 , POT )), p_exec =. 8 )] ) ... ... def gen_response_input ( round_ ): return Input ( ... debug = [ D . send_keys (), D . send_keys ( str ( randint ( 0 , POT )), p_exec =. 8 )] ) ... Run the debugger Now that our debugger won't get stuck in any infinite loops, it's time to run it. Open another terminal window. As always, change to your project directory: $ cd $ cd my-first-project You should have 3 terminals open: one for jupyter, one for editing survey.py and running hlk serve , and now a third for running the debugger. In one of the terminal windows, run the hemlock app as usual ( hlk serve ). In the third terminal, run the debugger: $ hlk debug To run several AI participants through the survey, e.g. 3, use: $ hlk debug -n 3 Summary In this part of the tutorial, you learned how to debug your app with hemlock's custom debugging tool. In the next part of the tutorial, you'll learn how to deploy your application (i.e. put it on the web).","title":"Debugging"},{"location":"tutorial/debug/#debugging","text":"In the previous part of the tutorial, you implemented the responder branch. By the end of this part of the tutorial, you'll be able to use hemlock's debugging tool to make sure your app is running smoothly. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial.","title":"Debugging"},{"location":"tutorial/debug/#why-a-custom-debugging-tool","text":"In the early days of hemlock, I coded a study in which I asked participants to estimate the ages of people in photographs. I used a submit function to change their data from strings to integers. Everything was running smoothly until one mischievous participant entered 'twenty-seven', breaking my survey and sending me home in a fit of rage. Since then, I've rewritten my submit functions to be more fault tolerant. If you run from hemlock import Input , Submit as S Input ( data = 'twenty-seven' , submit = S . data_type ( int )) . _submit () . data it doesn't break; it simply converts the data to None . But that wasn't good enough. We often underestimate just how strangely participants will respond to our studies in ways that we can't foresee. To mitigate this problem, I wrote a custom debugging tool for hemlock. The tool sends an AI participant through your survey to check things out. 'AI participant' is a bit of a misnomer; if anything, it's an artificially stupid participant. It clicks random buttons, enters random things into inputs and text boxes, drags range sliders to random values; basically stress testing your code.","title":"Why a custom debugging tool?"},{"location":"tutorial/debug/#setup","text":"To run hemlock's custom debugging tool locally, you'll need Google Chrome and Chromedriver . Check out the setup page for your OS for specific instructions: Windows Windows Subsystem for Linux Mac Linux","title":"Setup"},{"location":"tutorial/debug/#basic-syntax","text":"Open your jupyter notebook and run the following: from hemlock import Debug as D , Input inpt = Input ( debug = D . send_keys ( 'hello world' )) inpt . debug Out: [<Debug 1>] You can add debug functions to a page or quesiton by settings its debug attribute or passing a debug argument to its constructor. Debug functions run when we run the debugger (in just a moment). As its name suggests, the send_keys debug function tells the AI participant to send keys to the input. Let's watch our debug function at work: from hemlock import Page from hemlock.tools import chromedriver driver = chromedriver () p = Page ( inpt ) p . debug . pop () p . preview ( driver ) . _debug ( driver ) First, we use chromedriver to open Chromedriver with selenium python . Next, we create a page with our input question. We then pop the last debug function from the page we created. Why? By default, pages have two debug functions. The first executes its questions' debug methods in random order; as if the participant were randomly jumping between questions on a page. The second debug function randomly clicks a forward or back button (if it exists), or refreshes the page. Popping the last debug function prevents the debugger from navigating, which allows us to see more clearly what the debugger is doing in preview mode. Finally, we run the debug function. You'll notice it enters 'hello world' in the input. After you're done, close the driver: driver . close () Notes. You don't need to run _debug yourself in the survey; hemlock takes care of this automatically for you. send_keys is just one of many prebuilt debug functions .","title":"Basic syntax"},{"location":"tutorial/debug/#default-debug-functions","text":"We can attach debug functions to pages or questions. Most questions have a default debug function. For example, input questions have a default debug function which sends random ASCII characters to the input. You can see the default debug function at work by running: p = Page ( Input ()) p . debug . pop () p . preview ( driver ) . _debug ( driver ) However, sometimes we need to attach additional debug functions. For example, our study begins by asking participants to enter their date of birth in mm/dd/yyyy format. If you wait for the default debug function to randomly enter a string which matches that pattern, you might not end up running your study before Trump releases his tax returns. Instead, we'll use something like: Input ( '<p>Enter your date of birth.</p>' , debug = D . send_keys ( '10/26/1992' ) ) Unfortunately, this will not work effectively as a debugger. Sometimes we want the debugger to enter nonsense, and sometimes we want it to enter something sensible. To specify this behavior, we can modify the above: Input ( '<p>Enter your date of birth.</p>' , debug = [ D . send_keys (), D . send_keys ( '10/26/1992' , p_exec =. 8 )] ) The first debug function, send_keys() , sends random keys to the input. The second debug function send_keys('10/26/1992') , sends '10/26/1992' to the input. We also pass p_exec=.8 to the second debug function, which specifies its probability of executing. In English, we're telling the debugger, enter something random, then, with 80% probability, enter something sensible .","title":"Default debug functions"},{"location":"tutorial/debug/#custom-debug-functions","text":"We won't need custom debug functions for our survey, but you may need them elsewhere. Creating custom debug function is similar to creating custom compile, validate, etc. functions, with one important difference: while the functions you've seen take their parent as their first argument, debug functions take a selenium webdriver as their first argument and their parent as their second argument: @D . register def f ( driver , parent ): # debug something If you're serious about writing custom debug functions, I recommend checking out the source code for inspiration.","title":"Custom debug functions"},{"location":"tutorial/debug/#debugging-our-app","text":"First, import Debug at the top of survey.py : from hemlock import Branch , Check , Compile as C , Debug as D , Embedded , Input , Label , Navigate as N , Page , Range , Select , Submit as S , Validate as V , route ... Our app can be debugged largely with default debug functions. The exceptions are, 1) the date of birth input, 2) the comprehension check, 3) proposals and responses.","title":"Debugging our app"},{"location":"tutorial/debug/#date-of-birth","text":"Modify survey.py as follows: ... @route ( '/survey' ) def start (): demographics_page = Page ( Input ( '<p>Enter your date of birth.</p>' , ... debug = [ D . send_keys (), D . send_keys ( '10/26/1992' , p_exec =. 8 )] ), ...","title":"Date of birth"},{"location":"tutorial/debug/#comprehension-checks","text":"Because there is no attempt limit for our comprehension check, unless we tell the debugger to enter the correct answers, it's going to keep looping back to the instructions page. ... @Compile . register def random_proposal ( check_page , accept ): ... check_page . questions [ 1 ] . debug = [ D . send_keys (), D . send_keys ( str ( payoff [ 0 ]), p_exec =. 8 ) ] check_page . questions [ 2 ] . debug = [ D . send_keys (), D . send_keys ( str ( payoff [ 1 ]), p_exec =. 8 ) ] ...","title":"Comprehension checks"},{"location":"tutorial/debug/#proposals-and-responses","text":"It's unlikely the debugger will enter an integer between 0 and the size of the pot, so we'll give our debugger some help: ... def gen_proposal_input ( round_ ): return Input ( ... debug = [ D . send_keys (), D . send_keys ( str ( randint ( 0 , POT )), p_exec =. 8 )] ) ... ... def gen_response_input ( round_ ): return Input ( ... debug = [ D . send_keys (), D . send_keys ( str ( randint ( 0 , POT )), p_exec =. 8 )] ) ...","title":"Proposals and responses"},{"location":"tutorial/debug/#run-the-debugger","text":"Now that our debugger won't get stuck in any infinite loops, it's time to run it. Open another terminal window. As always, change to your project directory: $ cd $ cd my-first-project You should have 3 terminals open: one for jupyter, one for editing survey.py and running hlk serve , and now a third for running the debugger. In one of the terminal windows, run the hemlock app as usual ( hlk serve ). In the third terminal, run the debugger: $ hlk debug To run several AI participants through the survey, e.g. 3, use: $ hlk debug -n 3","title":"Run the debugger"},{"location":"tutorial/debug/#summary","text":"In this part of the tutorial, you learned how to debug your app with hemlock's custom debugging tool. In the next part of the tutorial, you'll learn how to deploy your application (i.e. put it on the web).","title":"Summary"},{"location":"tutorial/deploy/","text":"Deployment In the previous part of the tutorial, you learned how to debug your app with hemlock's custom debugging tool. In this part of the tutorial, you'll learn how to deploy your application (a.k.a. put it into production or put it on the web). Setup The easiest way to deploy web apps is with heroku . Hemlock-CLI builds on the heroku-CLI for deployment. Find the setup page for your OS for specific instructions: Windows Windows Subsystem for Linux Mac Linux Debugging in a staging environment Before we deploy our project 'for real', we're going to deploy to a staging environment using free heroku resources and run our debugger one more time. Why? Because the production environment is subtly different from your local environment, which can cause problems in very rare cases. The staging environment is virtually identical to the production environment, so if things go well in staging, our app should run smoothly in production. Deploying your app in staging Deploying your application is as easy as: $ hlk deploy You'll be redirected to a page on the heroku website. If this is your first time deploying an app, heroku will prompt you to connect to your github account. Once you're on the heroku page, make the following modifications to your application configuration: Enter a name for your application. Set your PASSWORD . You will need to enter this password to log in to the researcher dashboard to access your data. Set your URL_ROOT . For example, if your project is named my-first-project235 , your URL_ROOT would be https://my-first-project235.herokuapp.com . This tells the debugger where to look for your app. Click 'Deploy app' and watch the magic happen. In 2-3 minutes, your survey will be online. Running the debugger In the last part of the tutorial, we ran our debugger in the local environment. Now, we're going to run it in staging. First, let's hook up our project to our online application: $ heroku git:remote -a <my-app-name> Replacing <my-app-name> with your application name. For example, if your application is named my-first-project235 , you'd enter: $ heroku git:remote -a my-first-project235 Now, run the debugger: $ hlk debug --staging This is almost exactly what we did in the previous part of the tutorial. The difference is that we added the --staging flag, indicating that we're running the debugger in the staging environment. Where's the webdriver? In production, Chromedriver needs to run in 'headless' mode, meaning you won't be able to see the debugger going through the survey in your browser. You will, however, see it going through pages in the terminal window. Hopefully the debugger runs smoothly. If it doesn't, fix your code, update your application, and run the debugger again. Update your application with: $ hlk update Once you're satisfied that your app is as error-free as possible, we'll destroy the staging version to 'make room' for the production version: $ heroku apps:destroy Deploying your application We're finally ready to deploy our application for real . This is basically the same process as deploying to the staging environment, with a few small changes. First, open app.json : $ code app.json We're going to modify this to give us more powerful compute resources. At the top of the file, we'll change our addons and formation from: { \"addons\" : [ \"heroku-postgresql:hobby-dev\" ], \"formation\" : { \"web\" : { \"quantity\" : 1 , \"size\" : \"free\" } }, ... to: { \"addons\" : [ \"heroku-postgresql:standard-0\" ], \"formation\" : { \"web\" : { \"quantity\" : 10 , \"size\" : \"standard-1x\" } }, ... Save app.json . Let's deploy our app and set our configuration variables like we did before: $ hlk deploy Enter a name for your application. Set your PASSWORD . Set your URL_ROOT . New step. Set DEBUG_FUNCTIONS to False . This stops your application from creating debug functions. We're not going to run the debugger again at this point, so debug functions will just slow things down. Like before, click 'Deploy app' at the bottom of the page. Your app is now online, ready to send to the world! Don't forget to download your data, and destroy your application when you're finished: $ heroku apps:destroy -a <my-app-name> Cost How much will it cost me to play around with my app in production? Answer: $0.10. Calculation: This formation gives us a standard-0 database ($50/mo) and 10 standard-1x 'dynos' (like servers, $25/mo/dyno * 10 dynos = $250/mo). That's $300/mo total. Heroku prorates by the second, meaning that if you mess around with the app for 15 minutes, you'll be charged $300/mo * 1 mo/30 days * 1 day/24 hours * 1 hour/60 min * 15 min = $0.10. How much will it cost me to run a study with these resources? Answer: $5. Do the same math, but assume your study is online for half a day. Side note. The exact amount of compute power you need depends on the application. My recommendation for a standard-0 database and 10 standard-1x web dynos is a rough recommendation that will work well for most academic studies. Read more about heroku resources here . Alternative deployment options Hemlock uses a Flask backend, which means you can deploy it just as you would any other Flask app. The Flask Mega-Tutorial is, imho, the best resource for learning Flask, including deployment. Summary Congratulations! You've made it through the hemlock tutorial. You can now initialize, modify, and deploy hemlock projects. On the next page, I talk about some extra bells and whistles you'll likely find helpful.","title":"Deployment"},{"location":"tutorial/deploy/#deployment","text":"In the previous part of the tutorial, you learned how to debug your app with hemlock's custom debugging tool. In this part of the tutorial, you'll learn how to deploy your application (a.k.a. put it into production or put it on the web).","title":"Deployment"},{"location":"tutorial/deploy/#setup","text":"The easiest way to deploy web apps is with heroku . Hemlock-CLI builds on the heroku-CLI for deployment. Find the setup page for your OS for specific instructions: Windows Windows Subsystem for Linux Mac Linux","title":"Setup"},{"location":"tutorial/deploy/#debugging-in-a-staging-environment","text":"Before we deploy our project 'for real', we're going to deploy to a staging environment using free heroku resources and run our debugger one more time. Why? Because the production environment is subtly different from your local environment, which can cause problems in very rare cases. The staging environment is virtually identical to the production environment, so if things go well in staging, our app should run smoothly in production.","title":"Debugging in a staging environment"},{"location":"tutorial/deploy/#deploying-your-app-in-staging","text":"Deploying your application is as easy as: $ hlk deploy You'll be redirected to a page on the heroku website. If this is your first time deploying an app, heroku will prompt you to connect to your github account. Once you're on the heroku page, make the following modifications to your application configuration: Enter a name for your application. Set your PASSWORD . You will need to enter this password to log in to the researcher dashboard to access your data. Set your URL_ROOT . For example, if your project is named my-first-project235 , your URL_ROOT would be https://my-first-project235.herokuapp.com . This tells the debugger where to look for your app. Click 'Deploy app' and watch the magic happen. In 2-3 minutes, your survey will be online.","title":"Deploying your app in staging"},{"location":"tutorial/deploy/#running-the-debugger","text":"In the last part of the tutorial, we ran our debugger in the local environment. Now, we're going to run it in staging. First, let's hook up our project to our online application: $ heroku git:remote -a <my-app-name> Replacing <my-app-name> with your application name. For example, if your application is named my-first-project235 , you'd enter: $ heroku git:remote -a my-first-project235 Now, run the debugger: $ hlk debug --staging This is almost exactly what we did in the previous part of the tutorial. The difference is that we added the --staging flag, indicating that we're running the debugger in the staging environment. Where's the webdriver? In production, Chromedriver needs to run in 'headless' mode, meaning you won't be able to see the debugger going through the survey in your browser. You will, however, see it going through pages in the terminal window. Hopefully the debugger runs smoothly. If it doesn't, fix your code, update your application, and run the debugger again. Update your application with: $ hlk update Once you're satisfied that your app is as error-free as possible, we'll destroy the staging version to 'make room' for the production version: $ heroku apps:destroy","title":"Running the debugger"},{"location":"tutorial/deploy/#deploying-your-application","text":"We're finally ready to deploy our application for real . This is basically the same process as deploying to the staging environment, with a few small changes. First, open app.json : $ code app.json We're going to modify this to give us more powerful compute resources. At the top of the file, we'll change our addons and formation from: { \"addons\" : [ \"heroku-postgresql:hobby-dev\" ], \"formation\" : { \"web\" : { \"quantity\" : 1 , \"size\" : \"free\" } }, ... to: { \"addons\" : [ \"heroku-postgresql:standard-0\" ], \"formation\" : { \"web\" : { \"quantity\" : 10 , \"size\" : \"standard-1x\" } }, ... Save app.json . Let's deploy our app and set our configuration variables like we did before: $ hlk deploy Enter a name for your application. Set your PASSWORD . Set your URL_ROOT . New step. Set DEBUG_FUNCTIONS to False . This stops your application from creating debug functions. We're not going to run the debugger again at this point, so debug functions will just slow things down. Like before, click 'Deploy app' at the bottom of the page. Your app is now online, ready to send to the world! Don't forget to download your data, and destroy your application when you're finished: $ heroku apps:destroy -a <my-app-name>","title":"Deploying your application"},{"location":"tutorial/deploy/#cost","text":"How much will it cost me to play around with my app in production? Answer: $0.10. Calculation: This formation gives us a standard-0 database ($50/mo) and 10 standard-1x 'dynos' (like servers, $25/mo/dyno * 10 dynos = $250/mo). That's $300/mo total. Heroku prorates by the second, meaning that if you mess around with the app for 15 minutes, you'll be charged $300/mo * 1 mo/30 days * 1 day/24 hours * 1 hour/60 min * 15 min = $0.10. How much will it cost me to run a study with these resources? Answer: $5. Do the same math, but assume your study is online for half a day. Side note. The exact amount of compute power you need depends on the application. My recommendation for a standard-0 database and 10 standard-1x web dynos is a rough recommendation that will work well for most academic studies. Read more about heroku resources here .","title":"Cost"},{"location":"tutorial/deploy/#alternative-deployment-options","text":"Hemlock uses a Flask backend, which means you can deploy it just as you would any other Flask app. The Flask Mega-Tutorial is, imho, the best resource for learning Flask, including deployment.","title":"Alternative deployment options"},{"location":"tutorial/deploy/#summary","text":"Congratulations! You've made it through the hemlock tutorial. You can now initialize, modify, and deploy hemlock projects. On the next page, I talk about some extra bells and whistles you'll likely find helpful.","title":"Summary"},{"location":"tutorial/extra/","text":"Bells and whistles You already know most of the important stuff. Here are some tips and tricks to make your life easier. Redis One of hemlock's most impressive features is seamless integration with Redis for running complex background processes during surveys. Read more here . Settings We can use settings to change the default values of most attributes of most hemlock objects (see the API documentation for precise details). For example, let's add a back button to every page by default: from hemlock import Page , settings settings [ 'Page' ] . update ({ 'back' : True }) path = Page () . preview () Duplicates We often want to block the same participant from going through our survey multiple times. We do this with the duplicate_keys setting. This blocks visitors who match participants who've already completed the study on certain keys. For example: from hemlock import settings settings . update ({ 'duplicate_keys' : [ 'IPv4' , 'workerId' ]}) This blocks participants who match existing participants on IP address (IPv4) or their MTurk workerId. Screenouts We may also want to screen out participants, e.g. if they've participated in similar studies we've run in the past. We do this by 1) uploading a file called screenouts.csv to the root directory of our hemlock project. The top row of the csv are keys on which we want to screen (much like the duplicate keys we saw above). Then modify the screenout_keys setting: from hemlock import settings settings . update ({ 'screenout_keys' : [ 'IPv4' , 'workerId' ]}) Validation off During development and testing, we often want to be able to click through a survey quickly, ignoring validation. We can turn all validation off as follows: from hemlock import settings settings . update ({ 'validate' : False })","title":"Bells and whistles"},{"location":"tutorial/extra/#bells-and-whistles","text":"You already know most of the important stuff. Here are some tips and tricks to make your life easier.","title":"Bells and whistles"},{"location":"tutorial/extra/#redis","text":"One of hemlock's most impressive features is seamless integration with Redis for running complex background processes during surveys. Read more here .","title":"Redis"},{"location":"tutorial/extra/#settings","text":"We can use settings to change the default values of most attributes of most hemlock objects (see the API documentation for precise details). For example, let's add a back button to every page by default: from hemlock import Page , settings settings [ 'Page' ] . update ({ 'back' : True }) path = Page () . preview ()","title":"Settings"},{"location":"tutorial/extra/#duplicates","text":"We often want to block the same participant from going through our survey multiple times. We do this with the duplicate_keys setting. This blocks visitors who match participants who've already completed the study on certain keys. For example: from hemlock import settings settings . update ({ 'duplicate_keys' : [ 'IPv4' , 'workerId' ]}) This blocks participants who match existing participants on IP address (IPv4) or their MTurk workerId.","title":"Duplicates"},{"location":"tutorial/extra/#screenouts","text":"We may also want to screen out participants, e.g. if they've participated in similar studies we've run in the past. We do this by 1) uploading a file called screenouts.csv to the root directory of our hemlock project. The top row of the csv are keys on which we want to screen (much like the duplicate keys we saw above). Then modify the screenout_keys setting: from hemlock import settings settings . update ({ 'screenout_keys' : [ 'IPv4' , 'workerId' ]})","title":"Screenouts"},{"location":"tutorial/extra/#validation-off","text":"During development and testing, we often want to be able to click through a survey quickly, ignoring validation. We can turn all validation off as follows: from hemlock import settings settings . update ({ 'validate' : False }) <!-- ## Google cloud buckets Hook up a Google cloud bucket to your app with: <div class=\"highlight\"> $ hlk gcloud-bucket <my-billing-account> Make sure you have a Google cloud computing account and Google Cloud SDK installed. If using WSL, you can install these with hemlock-CLI: $ hlk setup win --cloud-sdk Additionally, install the google cloud storage python API with: $ pip3 install google-cloud-storage # or hlk install google-cloud-storage (see below) ``` --> ## Installing 3rd party packages We ordinarily install 3rd party packages with: ``` bash $ pip install <requested-package> # or pip3 install <requested-package> If you're using heroku, you need to include these in a `requirements.txt` file. If you're sharing your hemlock project with collaborators, I recommend additionally adding these to a `local-requirements.txt` file. Hemlock-CLI has a shortcut for 1) installing 3rd party packages, 2) adding them to `requirements.txt`, and 3) adding them to `local-requirements.txt`: $ hlk install <requested-package>","title":"Validation off"},{"location":"tutorial/first_project/","text":"Your first project By the end of this part of the tutorial, you'll be able to initialize a new hemlock project and create and preview hemlock survey pages. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Getting started I've written setup pages for different operating systems (OS) below. You don't need everything in the setup page right now. First, read this list of things you need. Then, check out the setup page for your OS for download and installation instructions. What you need to get started: Git and github (and a github authentication token) Python3 and pip3 Hemlock-CLI Visual studio code Jupyter Google chrome Check out the setup page for your OS: Windows Windows Subsystem for Linux Mac Linux Initialize a new hemlock project Run the following, replacing <my-github-username> with your github username and <my-github-token> with your github authentication token: $ hlk init my-first-project <my-github-username> <my-github-token> For example, I would enter: $ hlk init my-first-project dsbowen bts4rxpmw2x6tsy2qel1y7p5hwmhd7wxopmk5vsp (This isn't my real authentication token!) This will 'clone' the template into a folder my-first-project , initialize an eponymous github repository for your project, and set up a virtual environment. Change into the project directory and check out the folder structure: $ cd my-first-project $ ls Note You will only have to run hlk init once per project. Error You may see an error message starting with Cannot uninstall PyYAML . To fix this, run: $ pip install --ignore-installed pyyaml If using Windows git bash After changing into your project directory, set up your virtual environment: $ hlk setup-venv my-first-project If using WSL You'll need to specify your distribution as an environment variable. Open the file which sets your local environment variables: $ code env.yaml And add the following line: WSL_DISTRIBUTION : Ubuntu-20.04 # or other WSL distribution If you're not sure which distribution you have, run: $ explorer.exe . This will open a file explorer. At the top of the file explorer, you'll see: <my-wsl-distribution>\\home\\<my-wsl-username>\\my-first-project We're looking for <my-wsl-distribution> . Preview a page in jupyter notebook Jupyter notebook is a great tool for iterating quickly on project designs. I recommend using it for most of your work. Open the jupyter dashboard with: $ jupyter notebook Jupyter will attempt to open the dashboard automatically in your browser. If this fails, the terminal window will show you links to the dashboard that you can manually copy and paste into your browser. Open the file named blackboard.ipynb . Change the kernel to my-first-project (in general, your project name). At the top of the notebook click Kernel >> Change kernel >> my-first-project. Run the first cell (Shift + Enter) to set up the environment and application context. It's not important right now to understand exactly what it does. Now, create your first hemlock page. In a new code cell below the first one, enter the following: from hemlock import Page , Label p = Page ( Label ( '<p>Hello, World!</p>' )) p . preview () This opens a preview of your page in your browser. Previewing works by creating temporary preview files. When you're done previewing your files, it's good practice to delete them: [ os . remove ( f ) for f in app . tmpfiles if os . path . exists ( f )] Code explanation The first line simply imports Page and Label objects. The next line, p = Page(Label('<p>Hello, World!</p>')) , creates a Page instance. A Page contains a list of 'questions' which it displays to participants. We can set a page's questions by passing them as arguments to the Page constructor. Alternatively, we can set a page's questions by setting the page's questions attribute, meaning that the following are equivalent: p = Page ( Label ( '<p>Label 0</p>' ), Label ( '<p>Label 1</p>' )) p = Page () p . questions = [ Label ( '<p>Label 0</p>' ), Label ( '<p>Label 1</p>' )] The Page 's question is a Label , although this is in some sense a misnomer because label objects only contains text. The first argument to Label is a string, written in html, which the label object displays on its page. Note. If you don't like writing html, you can easily find Word to html converters online. Summary In this part of the tutorial, you learned how to initialize a new hemlock project and create and preview a page. In the next part of the tutorial, you'll learn how to run a hemlock application locally.","title":"Your first project"},{"location":"tutorial/first_project/#your-first-project","text":"By the end of this part of the tutorial, you'll be able to initialize a new hemlock project and create and preview hemlock survey pages. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial.","title":"Your first project"},{"location":"tutorial/first_project/#getting-started","text":"I've written setup pages for different operating systems (OS) below. You don't need everything in the setup page right now. First, read this list of things you need. Then, check out the setup page for your OS for download and installation instructions. What you need to get started: Git and github (and a github authentication token) Python3 and pip3 Hemlock-CLI Visual studio code Jupyter Google chrome Check out the setup page for your OS: Windows Windows Subsystem for Linux Mac Linux","title":"Getting started"},{"location":"tutorial/first_project/#initialize-a-new-hemlock-project","text":"Run the following, replacing <my-github-username> with your github username and <my-github-token> with your github authentication token: $ hlk init my-first-project <my-github-username> <my-github-token> For example, I would enter: $ hlk init my-first-project dsbowen bts4rxpmw2x6tsy2qel1y7p5hwmhd7wxopmk5vsp (This isn't my real authentication token!) This will 'clone' the template into a folder my-first-project , initialize an eponymous github repository for your project, and set up a virtual environment. Change into the project directory and check out the folder structure: $ cd my-first-project $ ls Note You will only have to run hlk init once per project. Error You may see an error message starting with Cannot uninstall PyYAML . To fix this, run: $ pip install --ignore-installed pyyaml If using Windows git bash After changing into your project directory, set up your virtual environment: $ hlk setup-venv my-first-project If using WSL You'll need to specify your distribution as an environment variable. Open the file which sets your local environment variables: $ code env.yaml And add the following line: WSL_DISTRIBUTION : Ubuntu-20.04 # or other WSL distribution If you're not sure which distribution you have, run: $ explorer.exe . This will open a file explorer. At the top of the file explorer, you'll see: <my-wsl-distribution>\\home\\<my-wsl-username>\\my-first-project We're looking for <my-wsl-distribution> .","title":"Initialize a new hemlock project"},{"location":"tutorial/first_project/#preview-a-page-in-jupyter-notebook","text":"Jupyter notebook is a great tool for iterating quickly on project designs. I recommend using it for most of your work. Open the jupyter dashboard with: $ jupyter notebook Jupyter will attempt to open the dashboard automatically in your browser. If this fails, the terminal window will show you links to the dashboard that you can manually copy and paste into your browser. Open the file named blackboard.ipynb . Change the kernel to my-first-project (in general, your project name). At the top of the notebook click Kernel >> Change kernel >> my-first-project. Run the first cell (Shift + Enter) to set up the environment and application context. It's not important right now to understand exactly what it does. Now, create your first hemlock page. In a new code cell below the first one, enter the following: from hemlock import Page , Label p = Page ( Label ( '<p>Hello, World!</p>' )) p . preview () This opens a preview of your page in your browser. Previewing works by creating temporary preview files. When you're done previewing your files, it's good practice to delete them: [ os . remove ( f ) for f in app . tmpfiles if os . path . exists ( f )]","title":"Preview a page in jupyter notebook"},{"location":"tutorial/first_project/#code-explanation","text":"The first line simply imports Page and Label objects. The next line, p = Page(Label('<p>Hello, World!</p>')) , creates a Page instance. A Page contains a list of 'questions' which it displays to participants. We can set a page's questions by passing them as arguments to the Page constructor. Alternatively, we can set a page's questions by setting the page's questions attribute, meaning that the following are equivalent: p = Page ( Label ( '<p>Label 0</p>' ), Label ( '<p>Label 1</p>' )) p = Page () p . questions = [ Label ( '<p>Label 0</p>' ), Label ( '<p>Label 1</p>' )] The Page 's question is a Label , although this is in some sense a misnomer because label objects only contains text. The first argument to Label is a string, written in html, which the label object displays on its page. Note. If you don't like writing html, you can easily find Word to html converters online.","title":"Code explanation"},{"location":"tutorial/first_project/#summary","text":"In this part of the tutorial, you learned how to initialize a new hemlock project and create and preview a page. In the next part of the tutorial, you'll learn how to run a hemlock application locally.","title":"Summary"},{"location":"tutorial/intro/","text":"Introduction This tutorial will guide you through the essentials of hemlock. By the end of it, you'll be able to initialize hemlock projects, create powerful experiments and surveys, and deploy them on the web. Start with the end product in mind When learning to program - or anything else - start with the end product in mind. This is my spin-off of Covey's start with the end in mind , where the end is something you've produced rather than knowledge you've acquired. I personally find that aiming at a product makes me more knowledgable about a topic than aiming at knowledge itself. In this spirit, our goal is to create a behavioral study in which participants play an ultimatum game with each other in real time. You can see the end product here: https://hemlock-tutorial.herokuapp.com/ . The complete survey code is on github . The ultimatum game is famous; studied in hundreds of academic papers in disciplines such as game theory, behavioral economics, experimental economics, marketing, psychology, sociology, and neuroscience. It involves two players; a proposer and a responder . We begin by endowing the proposer with a 'pot' of (usually) money, e.g. $20. The proposer then proposes a 'split' of the pot between him/herself and the responder (e.g. I get $15, you get $5 ). The responder can accept or reject the proposed split. If the responder accepts, the pot is split according to the proposal (e.g. proposer gets $15, responder gets $5). If the responder rejects the proposal, both players get nothing. With nearly 2000 citations, this 1991 American Economic Review paper studies how play evolves over successive rounds. It finds that proposers usually make 'fair' offers (about a 50-50 split), and responders usually reject unfair offers, in early rounds. As the game continues, proposers make more unfair offers, and responders are more accepting of them. The study we'll make in the hemlock tutorial is designed to replicate this finding. Prerequisites This tutorial assumes a very basic knowledge of two programming languages: bash and python. Tutorials There are a thousand excellent 'bash/python for beginners' tutorials online. The following should teach you enough bash and python to get started with hemlock in about 1-2 hours. Read up to 'Viewing Files' in this bash tutorial . Complete up to Lesson 15 in code the blocks . Learn how dictionaries work in thinkcspy . What to do if something doesn't make sense If and when you run into something which doesn't make sense to you, try the following: Keep going. As best you can, press on with the tutorial. You don't have to 100% understand what's going on to get things working. You'll also find that things which don't make sense now often 'fall into place' just a short while later. Look it up. I've done my best to write a clear, thorough tutorial. But no tutorial is comprehensive. If you run into something so puzzling that you can't just keep going, look it up! The internet is inundated with great programming resources.","title":"Introduction"},{"location":"tutorial/intro/#introduction","text":"This tutorial will guide you through the essentials of hemlock. By the end of it, you'll be able to initialize hemlock projects, create powerful experiments and surveys, and deploy them on the web.","title":"Introduction"},{"location":"tutorial/intro/#start-with-the-end-product-in-mind","text":"When learning to program - or anything else - start with the end product in mind. This is my spin-off of Covey's start with the end in mind , where the end is something you've produced rather than knowledge you've acquired. I personally find that aiming at a product makes me more knowledgable about a topic than aiming at knowledge itself. In this spirit, our goal is to create a behavioral study in which participants play an ultimatum game with each other in real time. You can see the end product here: https://hemlock-tutorial.herokuapp.com/ . The complete survey code is on github . The ultimatum game is famous; studied in hundreds of academic papers in disciplines such as game theory, behavioral economics, experimental economics, marketing, psychology, sociology, and neuroscience. It involves two players; a proposer and a responder . We begin by endowing the proposer with a 'pot' of (usually) money, e.g. $20. The proposer then proposes a 'split' of the pot between him/herself and the responder (e.g. I get $15, you get $5 ). The responder can accept or reject the proposed split. If the responder accepts, the pot is split according to the proposal (e.g. proposer gets $15, responder gets $5). If the responder rejects the proposal, both players get nothing. With nearly 2000 citations, this 1991 American Economic Review paper studies how play evolves over successive rounds. It finds that proposers usually make 'fair' offers (about a 50-50 split), and responders usually reject unfair offers, in early rounds. As the game continues, proposers make more unfair offers, and responders are more accepting of them. The study we'll make in the hemlock tutorial is designed to replicate this finding.","title":"Start with the end product in mind"},{"location":"tutorial/intro/#prerequisites","text":"This tutorial assumes a very basic knowledge of two programming languages: bash and python.","title":"Prerequisites"},{"location":"tutorial/intro/#tutorials","text":"There are a thousand excellent 'bash/python for beginners' tutorials online. The following should teach you enough bash and python to get started with hemlock in about 1-2 hours. Read up to 'Viewing Files' in this bash tutorial . Complete up to Lesson 15 in code the blocks . Learn how dictionaries work in thinkcspy .","title":"Tutorials"},{"location":"tutorial/intro/#what-to-do-if-something-doesnt-make-sense","text":"If and when you run into something which doesn't make sense to you, try the following: Keep going. As best you can, press on with the tutorial. You don't have to 100% understand what's going on to get things working. You'll also find that things which don't make sense now often 'fall into place' just a short while later. Look it up. I've done my best to write a clear, thorough tutorial. But no tutorial is comprehensive. If you run into something so puzzling that you can't just keep going, look it up! The internet is inundated with great programming resources.","title":"What to do if something doesn't make sense"},{"location":"tutorial/navigate/","text":"Navigate In the previous part of the tutorial, you implemented a confirmation page using compile functions. By the end of this part of the tutorial, you'll be able to set up navigation between branches. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Why navigate functions? Navigate functions move participants through different branches of the survey. For example, participants in the control group might follow one branch, while participants in the treatment group follow another. In our case, we'll use a navigate function to bring participants from the demographics branch of our survey to an 'utlimatum game' branch. In this branch, participants will play an ultimatum game with each other. Basic syntax Open your jupter notebook and run the following: from hemlock import Branch , Navigate as N , Page , Participant def start (): return Branch ( Page (), Page (), navigate = N . end () ) @N . register def end ( start_branch ): return Branch ( Page ( terminal = True )) part = Participant . gen_test_participant ( start ) part . view_nav () Out: <Branch 1> <Page 1> C <Page 2> C = current page T = terminal page You can add navigate functions to a branch or page by setting its navigate attribute or passing a navigate argument to its constructor. Navigate functions bring participants to a new branch when they have completed the branch or page to which the navigate function belongs. Code explanation Unlike validate, submit, and compile functions, there are no prebuilt navigate functions. We register a custom navigate function with the @N.register decorator. The navigate function takes the start branch (the branch returned by start ) as its first argument. In general, navigate functions take an 'origin' branch or page as their first argument. Navigate functions return a Branch object. part.view_nav() prints the participant's 'branch stack'. Right now the participant is on the branch created by start . Let's make our test participant navigate forward and view the navigation again: part . forward () . view_nav () Out: <Branch 1> <Page 1> <Page 2> C C = current page T = terminal page And again: part . forward () . view_nav () Out: <Branch 1> <Page 1> <Page 2> <Branch 2> <Page 3> C T What happened? Our participant reached the end of the start branch (branch 1) and navigated to the end branch (branch 2). It's currently on page 3, which is the last (terminal) page of the survey. Note. You won't call view_nav or forward in the survey; hemlock takes care of the navigation automtically for you. These are just useful for debugging in jupyter. Branching off pages Branching off of branches allows us to navigate to a new branch at the end of our current branch. But occasionally, we'll want to navigate to a new branch from the middle of our current branch. To do this, we'll branch off of a page. This time, instead of attaching the navigate function to the branch, we'll attach it to the first page of the branch: def start (): return Branch ( Page ( navigate = N . middle ()), Page ( terminal = True )) @N . register def middle ( start_branch ): return Branch ( Page ()) part = Participant . gen_test_participant ( start ) As before, run part.view_nav() and part.forward() a few times. This is what you'll see: <Branch 1> <Page 1> C <Page 2> T <Branch 1> <Page 1> <Branch 2> <Page 3> C <Page 2> T <Branch 1> <Page 1> <Branch 2> <Page 3> <Page 2> C T What happened? We started on the first page of the start branch (branch 1, page 1). Then, we branched off of page 1 to the middle branch (branch 2, page 3). At the end of the middle branch, we picked up where we left off on the start branch (branch 1, page 2). Navigating back You'll often want to allow participants to navigate to a previous page. To do this, simply set a page's back attribute to True , or pass back=True to a page's constructor. You can also navigate backward in the notebook. Run this line a few times: part . back () . view_nav () Out: <Branch 1> <Page 1> <Branch 2> <Page 3> C <Page 2> T C = current page T = terminal page <Branch 1> <Page 1> C <Page 2> T C = current page T = terminal page Navigation in our app Now that we've seen how to add navigate functions in our notebook, let's add it to our app. In survey.py : from hemlock import Branch , Check , Compile as C , Embedded , Input , Label , Navigate as N , Page , Range , Select , Submit as S , Validate as V , route ... @route ( '/survey' ) def start (): ... return Branch ( demographics_page , Page ( Label ( compile = C . confirm ( demographics_page )), back = True # DELETE terminal=True ), navigate = N . ultimatum_game () ) ... @N . register def ultimatum_game ( start_branch ): return Branch ( Page ( Label ( '<p>You are about to play an ultimatum game...</p>' ), terminal = True ) ) Run the app again and navigate past the demographics page. You'll find yourself on our new ultimatum game branch. Summary In this part of the tutorial, you learned how to navigate between branches. In the next part of the tutorial, we'll tie together some of the things you've learned about page logic.","title":"Navigate"},{"location":"tutorial/navigate/#navigate","text":"In the previous part of the tutorial, you implemented a confirmation page using compile functions. By the end of this part of the tutorial, you'll be able to set up navigation between branches. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial.","title":"Navigate"},{"location":"tutorial/navigate/#why-navigate-functions","text":"Navigate functions move participants through different branches of the survey. For example, participants in the control group might follow one branch, while participants in the treatment group follow another. In our case, we'll use a navigate function to bring participants from the demographics branch of our survey to an 'utlimatum game' branch. In this branch, participants will play an ultimatum game with each other.","title":"Why navigate functions?"},{"location":"tutorial/navigate/#basic-syntax","text":"Open your jupter notebook and run the following: from hemlock import Branch , Navigate as N , Page , Participant def start (): return Branch ( Page (), Page (), navigate = N . end () ) @N . register def end ( start_branch ): return Branch ( Page ( terminal = True )) part = Participant . gen_test_participant ( start ) part . view_nav () Out: <Branch 1> <Page 1> C <Page 2> C = current page T = terminal page You can add navigate functions to a branch or page by setting its navigate attribute or passing a navigate argument to its constructor. Navigate functions bring participants to a new branch when they have completed the branch or page to which the navigate function belongs.","title":"Basic syntax"},{"location":"tutorial/navigate/#code-explanation","text":"Unlike validate, submit, and compile functions, there are no prebuilt navigate functions. We register a custom navigate function with the @N.register decorator. The navigate function takes the start branch (the branch returned by start ) as its first argument. In general, navigate functions take an 'origin' branch or page as their first argument. Navigate functions return a Branch object. part.view_nav() prints the participant's 'branch stack'. Right now the participant is on the branch created by start . Let's make our test participant navigate forward and view the navigation again: part . forward () . view_nav () Out: <Branch 1> <Page 1> <Page 2> C C = current page T = terminal page And again: part . forward () . view_nav () Out: <Branch 1> <Page 1> <Page 2> <Branch 2> <Page 3> C T What happened? Our participant reached the end of the start branch (branch 1) and navigated to the end branch (branch 2). It's currently on page 3, which is the last (terminal) page of the survey. Note. You won't call view_nav or forward in the survey; hemlock takes care of the navigation automtically for you. These are just useful for debugging in jupyter.","title":"Code explanation"},{"location":"tutorial/navigate/#branching-off-pages","text":"Branching off of branches allows us to navigate to a new branch at the end of our current branch. But occasionally, we'll want to navigate to a new branch from the middle of our current branch. To do this, we'll branch off of a page. This time, instead of attaching the navigate function to the branch, we'll attach it to the first page of the branch: def start (): return Branch ( Page ( navigate = N . middle ()), Page ( terminal = True )) @N . register def middle ( start_branch ): return Branch ( Page ()) part = Participant . gen_test_participant ( start ) As before, run part.view_nav() and part.forward() a few times. This is what you'll see: <Branch 1> <Page 1> C <Page 2> T <Branch 1> <Page 1> <Branch 2> <Page 3> C <Page 2> T <Branch 1> <Page 1> <Branch 2> <Page 3> <Page 2> C T What happened? We started on the first page of the start branch (branch 1, page 1). Then, we branched off of page 1 to the middle branch (branch 2, page 3). At the end of the middle branch, we picked up where we left off on the start branch (branch 1, page 2).","title":"Branching off pages"},{"location":"tutorial/navigate/#navigating-back","text":"You'll often want to allow participants to navigate to a previous page. To do this, simply set a page's back attribute to True , or pass back=True to a page's constructor. You can also navigate backward in the notebook. Run this line a few times: part . back () . view_nav () Out: <Branch 1> <Page 1> <Branch 2> <Page 3> C <Page 2> T C = current page T = terminal page <Branch 1> <Page 1> C <Page 2> T C = current page T = terminal page","title":"Navigating back"},{"location":"tutorial/navigate/#navigation-in-our-app","text":"Now that we've seen how to add navigate functions in our notebook, let's add it to our app. In survey.py : from hemlock import Branch , Check , Compile as C , Embedded , Input , Label , Navigate as N , Page , Range , Select , Submit as S , Validate as V , route ... @route ( '/survey' ) def start (): ... return Branch ( demographics_page , Page ( Label ( compile = C . confirm ( demographics_page )), back = True # DELETE terminal=True ), navigate = N . ultimatum_game () ) ... @N . register def ultimatum_game ( start_branch ): return Branch ( Page ( Label ( '<p>You are about to play an ultimatum game...</p>' ), terminal = True ) ) Run the app again and navigate past the demographics page. You'll find yourself on our new ultimatum game branch.","title":"Navigation in our app"},{"location":"tutorial/navigate/#summary","text":"In this part of the tutorial, you learned how to navigate between branches. In the next part of the tutorial, we'll tie together some of the things you've learned about page logic.","title":"Summary"},{"location":"tutorial/page_logic/","text":"Page logic Now that you've seen compile, validate, submit, and navigate functions, it's time to discuss the logic of hemlock pages. It's not important to fully understand this now, as long as you have a rough sense of the order in which things happen. Compile. The page executes its compile functions. By default, a page's first compile function runs its questions' compile functions. Render. The page html is rendered and displayed to the participant. Record responses. When the participant submits a page, we record their responses to every question on the page. This sets the questions' response attribute. Validate. After recording all responses, the page executes its validate functions. By default, a page's first validate function runs its questions' validate functions. When a page or question executes its validate functions, it does so one by one, and if any of them uncover an error (i.e. return a string instead of None ), validation for that object stops. For example, suppose we attach two validate functions with Input(validate=[V.require(), V.response_type(float)]) . When the input question runs its validate functions, the first validate function checks that the participant entered a response. Only if they entered a response does the second validate function check that the participant's response can by converted to float . Record data. The page records the data associated with the participant's responses to every question on the page. This sets the questions' data attribute. Submit. The page executes its submit functions. By default, a page's first submit function runs its questions' submit functions. Navigate. If the page has a navigate function, execute the function and bring the participant to the start of the new branch the function returns. If the page has no navigate function, and the participant has reached the end a a branch, the branch executes its navigate function and brings the participant to the start of the new branch returned by the function. You can visualize compile functions (validate and submit functions are similar) as follows: Page 1 compile function 1 Question 1 compile function 1 Question 1 compile function 2 ... Question 2 compile function 1 Question 2 compile function 2 ... Page 1 compile function 2 ... In the next part of the tutorial, we'll give our participants instructions on how to play the ultimatum game and verify their understanding with a comprehension check.","title":"Page logic"},{"location":"tutorial/page_logic/#page-logic","text":"Now that you've seen compile, validate, submit, and navigate functions, it's time to discuss the logic of hemlock pages. It's not important to fully understand this now, as long as you have a rough sense of the order in which things happen. Compile. The page executes its compile functions. By default, a page's first compile function runs its questions' compile functions. Render. The page html is rendered and displayed to the participant. Record responses. When the participant submits a page, we record their responses to every question on the page. This sets the questions' response attribute. Validate. After recording all responses, the page executes its validate functions. By default, a page's first validate function runs its questions' validate functions. When a page or question executes its validate functions, it does so one by one, and if any of them uncover an error (i.e. return a string instead of None ), validation for that object stops. For example, suppose we attach two validate functions with Input(validate=[V.require(), V.response_type(float)]) . When the input question runs its validate functions, the first validate function checks that the participant entered a response. Only if they entered a response does the second validate function check that the participant's response can by converted to float . Record data. The page records the data associated with the participant's responses to every question on the page. This sets the questions' data attribute. Submit. The page executes its submit functions. By default, a page's first submit function runs its questions' submit functions. Navigate. If the page has a navigate function, execute the function and bring the participant to the start of the new branch the function returns. If the page has no navigate function, and the participant has reached the end a a branch, the branch executes its navigate function and brings the participant to the start of the new branch returned by the function. You can visualize compile functions (validate and submit functions are similar) as follows: Page 1 compile function 1 Question 1 compile function 1 Question 1 compile function 2 ... Question 2 compile function 1 Question 2 compile function 2 ... Page 1 compile function 2 ... In the next part of the tutorial, we'll give our participants instructions on how to play the ultimatum game and verify their understanding with a comprehension check.","title":"Page logic"},{"location":"tutorial/proposer_branch/","text":"Proposer branch In the previous part of the tutorial, you learned how to randomly assign participants to conditions. In this part of the tutorial, you'll implement the proposer branch of the ultimatum game. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. The proposal input First, we'll write a function to generate an input question where the proposer will input the proposed split. Enter the following in your jupyter notebook: from hemlock import Input , Label , Page , Submit as S , Validate as V N_ROUNDS = 5 POT = 20 def gen_proposal_input ( round_ ): return Input ( ''' <p><b>Round {} of {}</b></p> <p>You have ${} to split between you and the responder. How much money would you like to offer to the responder?</p> ''' . format ( round_ , N_ROUNDS , POT ), prepend = '$' , append = '.00' , var = 'Proposal' , validate = V . range_val ( 0 , POT ), submit = S . data_type ( int ) ) Page ( gen_proposal_input ( 1 )) . preview () This function generates an input which asks the proposer how much money they would like to offer to the responder. We record the data in a variable named 'Proposal' . We add range validation so that the proposer inputs an integer between 0 and the size of the pot. We also add a submit function which converts the data type to an integer. Note. For input questions, the data are recorded as strings. We want to reference this question's data as an integer, so we use S.data_type(int) to convert it when the page is submitted. Finding a responder We can use the SQLAlchemy Query API to pair the proposer with a random responder this round. First, we create an input with variable name 'Response' and data 5 : import random response_input = Input ( var = 'Response' , data = 5 ) response_input Out: <Input 3> Next, we get all Input objects in the database with the variable name 'Response' whose data is not None : response_inputs = Input . query . filter ( Input . var == 'Response' , Input . data != None ) . all () response_inputs Out: [<Input 3>] Finally, we choose one of these inputs randomly and get its data: random . choice ( response_inputs ) . data Out: 5 Displaying the proposer outcome Now we want to display the outcome of the round to the proposer. This calls for a compile function: from hemlock import Compile as C , Embedded from random import randint @C . register def proposer_outcome ( outcome_label , proposal_input ): # get the proposal proposal = POT - proposal_input . data , proposal_input . data # get all responses response_inputs = Input . query . filter ( Input . var == 'Response' , Input . data != None ) . all () if response_inputs : # randomly choose a response response = random . choice ( response_inputs ) . data else : # no responses are available # e.g. if this is the first participant response = randint ( 0 , POT ) # compute the payoff accept = response <= proposal [ 1 ] payoff = proposal if accept else ( 0 , 0 ) # record results as embedded data outcome_label . page . embedded = [ Embedded ( 'Response' , response ), Embedded ( 'Accept' , int ( accept )), Embedded ( 'ProposerPayoff' , payoff [ 0 ]), Embedded ( 'ResponderPayoff' , payoff [ 1 ]) ] # describe the outcome of the round outcome_label . label = ''' <p>You proposed the following split:</p> <ul> <li>You: $ {} </li> <li>Responder: $ {} </li> </ul> <p>The responder said they will accept any proposal which gives them at least $ {} .</p> <p><b>Your proposal was {} , giving you a payoff of $ {} .</b></p> ''' . format ( * proposal , response , 'accepted' if accept else 'rejected' , payoff [ 0 ] ) proposal_outcome_page = Page ( Label ( compile = C . proposer_outcome ( Input ( data = 10 )) ) ) proposal_outcome_page . _compile () . preview () Let's go through this step by step. First, we get the proposal from the proposal input question. Remember that we converted the data for this input to an integer using a submit function. The data for this input is the amount of money the proposer offered to the responder, meaning that the proposed split is (POT-proposal_input.data, proposal_input.data) . Second, we use the Query API to randomly select a response input question. We modify our above code to account for the fact that, if the first participant is a proposer, there won't be any responses to choose from. So, if our query can't find any response input questions, we return a random response. Third, we compute the payoff and record the results of the round using embedded data. Finally, we set the outcome label's label attribute to display the outcome of the round. Notice that the outcome of the round is recorded in the proposer's outcome page's embedded data: [( e . var , e . data ) for e in proposal_outcome_page . embedded ] Out: [('Response', 5), ('Accept', 1), ('ProposerPayoff', 10), ('ResponderPayoff', 10)] Adding the proposer branch to our survey Navigating to the proposer branch We'll begin by modifying the ultimatum game branch to navigate to the proposer branch if the participant was assigned to be a proposer. In survey.py : ... @N . register def ultimatum_game ( start_branch = None ): proposer = assigner . next ()[ 'Proposer' ] return Branch ( # COMPREHENSION CHECK HERE Page ( Label ( ''' <p>You are about to play an ultimatum game as a <b>{}</b>.</p> ''' . format ( 'proposer' if proposer else 'responder' ) ) # DELETE terminal=True ), navigate = N . proposer_branch () ) ... The proposer branch navigate function Next we'll add our proposer navigate function to the bottom of survey.py : ... import random # ADD THIS IMPORT AT THE TOP OF THE FILE from datetime import datetime from random import randint ... @N . register def proposer_branch ( ultimatum_game_branch ): branch = Branch () for round_ in range ( N_ROUNDS ): proposal_input = gen_proposal_input ( round_ + 1 ) branch . pages . append ( Page ( proposal_input )) branch . pages . append ( Page ( Label ( compile = C . proposer_outcome ( proposal_input )), cache_compile = True )) branch . pages . append ( Page ( Label ( '<p>Thank you for completing the hemlock tutorial!</p>' ), terminal = True )) return branch This navigate function simply adds two pages to the proposer branch for each of N_ROUNDS . The first page asks the proposer to propose a split. The second page displays the outcome of the round. Notice that passed cache_compile=True to the second page. This caches the result of the compile functions; removing them so that they won't run again if the participant refreshed the page. Why do we want to do this? Suppose we set up our study so that participants are playing for real money. We don't want participants refreshing their screen over and over again to see if they can get a better outcome. Generating the proposal input and outcome label Finally, we'll add the gen_proposal_input and proposer_outcome functions we wrote in our notebook: ... def gen_proposal_input ( round_ ): # AS IN THE NOTEBOOK @C . register def proposer_outcome ( outcome_label , proposal_input ): # AS IN THE NOTEBOOK Run the app and see what the survey looks like in the proposer condition. Summary In this part of the tutorial, you implemented the proposer branch. In the next part of the tutorial, you'll implement the responder branch.","title":"Proposer branch"},{"location":"tutorial/proposer_branch/#proposer-branch","text":"In the previous part of the tutorial, you learned how to randomly assign participants to conditions. In this part of the tutorial, you'll implement the proposer branch of the ultimatum game. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial.","title":"Proposer branch"},{"location":"tutorial/proposer_branch/#the-proposal-input","text":"First, we'll write a function to generate an input question where the proposer will input the proposed split. Enter the following in your jupyter notebook: from hemlock import Input , Label , Page , Submit as S , Validate as V N_ROUNDS = 5 POT = 20 def gen_proposal_input ( round_ ): return Input ( ''' <p><b>Round {} of {}</b></p> <p>You have ${} to split between you and the responder. How much money would you like to offer to the responder?</p> ''' . format ( round_ , N_ROUNDS , POT ), prepend = '$' , append = '.00' , var = 'Proposal' , validate = V . range_val ( 0 , POT ), submit = S . data_type ( int ) ) Page ( gen_proposal_input ( 1 )) . preview () This function generates an input which asks the proposer how much money they would like to offer to the responder. We record the data in a variable named 'Proposal' . We add range validation so that the proposer inputs an integer between 0 and the size of the pot. We also add a submit function which converts the data type to an integer. Note. For input questions, the data are recorded as strings. We want to reference this question's data as an integer, so we use S.data_type(int) to convert it when the page is submitted.","title":"The proposal input"},{"location":"tutorial/proposer_branch/#finding-a-responder","text":"We can use the SQLAlchemy Query API to pair the proposer with a random responder this round. First, we create an input with variable name 'Response' and data 5 : import random response_input = Input ( var = 'Response' , data = 5 ) response_input Out: <Input 3> Next, we get all Input objects in the database with the variable name 'Response' whose data is not None : response_inputs = Input . query . filter ( Input . var == 'Response' , Input . data != None ) . all () response_inputs Out: [<Input 3>] Finally, we choose one of these inputs randomly and get its data: random . choice ( response_inputs ) . data Out: 5","title":"Finding a responder"},{"location":"tutorial/proposer_branch/#displaying-the-proposer-outcome","text":"Now we want to display the outcome of the round to the proposer. This calls for a compile function: from hemlock import Compile as C , Embedded from random import randint @C . register def proposer_outcome ( outcome_label , proposal_input ): # get the proposal proposal = POT - proposal_input . data , proposal_input . data # get all responses response_inputs = Input . query . filter ( Input . var == 'Response' , Input . data != None ) . all () if response_inputs : # randomly choose a response response = random . choice ( response_inputs ) . data else : # no responses are available # e.g. if this is the first participant response = randint ( 0 , POT ) # compute the payoff accept = response <= proposal [ 1 ] payoff = proposal if accept else ( 0 , 0 ) # record results as embedded data outcome_label . page . embedded = [ Embedded ( 'Response' , response ), Embedded ( 'Accept' , int ( accept )), Embedded ( 'ProposerPayoff' , payoff [ 0 ]), Embedded ( 'ResponderPayoff' , payoff [ 1 ]) ] # describe the outcome of the round outcome_label . label = ''' <p>You proposed the following split:</p> <ul> <li>You: $ {} </li> <li>Responder: $ {} </li> </ul> <p>The responder said they will accept any proposal which gives them at least $ {} .</p> <p><b>Your proposal was {} , giving you a payoff of $ {} .</b></p> ''' . format ( * proposal , response , 'accepted' if accept else 'rejected' , payoff [ 0 ] ) proposal_outcome_page = Page ( Label ( compile = C . proposer_outcome ( Input ( data = 10 )) ) ) proposal_outcome_page . _compile () . preview () Let's go through this step by step. First, we get the proposal from the proposal input question. Remember that we converted the data for this input to an integer using a submit function. The data for this input is the amount of money the proposer offered to the responder, meaning that the proposed split is (POT-proposal_input.data, proposal_input.data) . Second, we use the Query API to randomly select a response input question. We modify our above code to account for the fact that, if the first participant is a proposer, there won't be any responses to choose from. So, if our query can't find any response input questions, we return a random response. Third, we compute the payoff and record the results of the round using embedded data. Finally, we set the outcome label's label attribute to display the outcome of the round. Notice that the outcome of the round is recorded in the proposer's outcome page's embedded data: [( e . var , e . data ) for e in proposal_outcome_page . embedded ] Out: [('Response', 5), ('Accept', 1), ('ProposerPayoff', 10), ('ResponderPayoff', 10)]","title":"Displaying the proposer outcome"},{"location":"tutorial/proposer_branch/#adding-the-proposer-branch-to-our-survey","text":"","title":"Adding the proposer branch to our survey"},{"location":"tutorial/proposer_branch/#navigating-to-the-proposer-branch","text":"We'll begin by modifying the ultimatum game branch to navigate to the proposer branch if the participant was assigned to be a proposer. In survey.py : ... @N . register def ultimatum_game ( start_branch = None ): proposer = assigner . next ()[ 'Proposer' ] return Branch ( # COMPREHENSION CHECK HERE Page ( Label ( ''' <p>You are about to play an ultimatum game as a <b>{}</b>.</p> ''' . format ( 'proposer' if proposer else 'responder' ) ) # DELETE terminal=True ), navigate = N . proposer_branch () ) ...","title":"Navigating to the proposer branch"},{"location":"tutorial/proposer_branch/#the-proposer-branch-navigate-function","text":"Next we'll add our proposer navigate function to the bottom of survey.py : ... import random # ADD THIS IMPORT AT THE TOP OF THE FILE from datetime import datetime from random import randint ... @N . register def proposer_branch ( ultimatum_game_branch ): branch = Branch () for round_ in range ( N_ROUNDS ): proposal_input = gen_proposal_input ( round_ + 1 ) branch . pages . append ( Page ( proposal_input )) branch . pages . append ( Page ( Label ( compile = C . proposer_outcome ( proposal_input )), cache_compile = True )) branch . pages . append ( Page ( Label ( '<p>Thank you for completing the hemlock tutorial!</p>' ), terminal = True )) return branch This navigate function simply adds two pages to the proposer branch for each of N_ROUNDS . The first page asks the proposer to propose a split. The second page displays the outcome of the round. Notice that passed cache_compile=True to the second page. This caches the result of the compile functions; removing them so that they won't run again if the participant refreshed the page. Why do we want to do this? Suppose we set up our study so that participants are playing for real money. We don't want participants refreshing their screen over and over again to see if they can get a better outcome.","title":"The proposer branch navigate function"},{"location":"tutorial/proposer_branch/#generating-the-proposal-input-and-outcome-label","text":"Finally, we'll add the gen_proposal_input and proposer_outcome functions we wrote in our notebook: ... def gen_proposal_input ( round_ ): # AS IN THE NOTEBOOK @C . register def proposer_outcome ( outcome_label , proposal_input ): # AS IN THE NOTEBOOK Run the app and see what the survey looks like in the proposer condition.","title":"Generating the proposal input and outcome label"},{"location":"tutorial/proposer_branch/#summary","text":"In this part of the tutorial, you implemented the proposer branch. In the next part of the tutorial, you'll implement the responder branch.","title":"Summary"},{"location":"tutorial/qpolymorphs/","text":"Question polymorphs In the previous part of the tutorial, you learned how to initialize a hemlock application and run it locally. By the end of this part of the tutorial, you'll be able to add a variety of question polymorphs to your survey pages. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Creating a demographics page We'll use jupyter notebook as a blackboard to iterate on our demographics page design. After pushing the application context, we'll create the following page: from hemlock import Check , Input , Page , Label , Range , Select p = Page ( Input ( '<p>Enter your date of birth.</p>' , placeholder = 'mm/dd/yyyy' ), Check ( '<p>Indicate your gender.</p>' , [ 'Male' , 'Female' , 'Other' ] ), Check ( '<p>Indicate your race or ethnicity. Check as many as apply.</p>' , [ 'White' , 'Black or African-American' , 'Asian' , 'Native Hawaiian or other Pacific Islander' , 'Other' , ], multiple = True ), Select ( '<p>Select your current marital status.</p>' , [ 'Married' , 'Widowed' , 'Divorced' , 'Separated' , 'Never married' , ] ), Range ( ''' <p>At the right end of the scale are the people who are the best off; those who have the most money, the most education, and the best jobs. On the left are the people who are the worst off; those who have the least money, the least education, and the worst jobs (or are unemployed). Please indicate where you think you stand on this scale.</p> ''' , min = 0 , max = 10 ), ) As usual, use p.preview() to preview the page and [os.remove(f) for f in app.tmpfiles if os.path.exists(f)] when you're done. Code explanation Here we add several 'question polymorphs' (i.e. types of questions) to our page. The first is an input. We add placeholder='mm/dd/yyyy' , telling participants the expected format of their date of birth. The next two are check questions, which allow participants to check one or more choices. Notice that the first check question allows participants to check only one choice; we allow participants to check multiple choices in the second check question by passing multiple=True . The fourth question is a select (dropdown) question. If we wanted, we also could have passed multiple=True to its contructor to allow participants to select multiple options. Our final question is a range slider. By default, it goes from 0 to 100, but we set its range from 0 to 10 here. Adding the page to the survey Once we're satisfied with the preview, we incorporate the page into our survey. Our survey.py file should be: from hemlock import Branch , Check , Input , Page , Label , Range , Select , route @route ( '/survey' ) def start (): return Branch ( Page ( Input ( '<p>Enter your date of birth.</p>' , placeholder = 'mm/dd/yyyy' ), # INSERT THE REST OF THE DEMOGRAPHICS PAGE HERE ), Page ( Label ( '<p>Thank you for completing this survey.</p>' ), terminal = True ) ) Summary In this part of the tutorial, you learned how to create a demographics questionnaire using several question polymorphs. In the next part of the tutorial, you'll learn how to store and download survey data.","title":"Question polymorphs"},{"location":"tutorial/qpolymorphs/#question-polymorphs","text":"In the previous part of the tutorial, you learned how to initialize a hemlock application and run it locally. By the end of this part of the tutorial, you'll be able to add a variety of question polymorphs to your survey pages. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial.","title":"Question polymorphs"},{"location":"tutorial/qpolymorphs/#creating-a-demographics-page","text":"We'll use jupyter notebook as a blackboard to iterate on our demographics page design. After pushing the application context, we'll create the following page: from hemlock import Check , Input , Page , Label , Range , Select p = Page ( Input ( '<p>Enter your date of birth.</p>' , placeholder = 'mm/dd/yyyy' ), Check ( '<p>Indicate your gender.</p>' , [ 'Male' , 'Female' , 'Other' ] ), Check ( '<p>Indicate your race or ethnicity. Check as many as apply.</p>' , [ 'White' , 'Black or African-American' , 'Asian' , 'Native Hawaiian or other Pacific Islander' , 'Other' , ], multiple = True ), Select ( '<p>Select your current marital status.</p>' , [ 'Married' , 'Widowed' , 'Divorced' , 'Separated' , 'Never married' , ] ), Range ( ''' <p>At the right end of the scale are the people who are the best off; those who have the most money, the most education, and the best jobs. On the left are the people who are the worst off; those who have the least money, the least education, and the worst jobs (or are unemployed). Please indicate where you think you stand on this scale.</p> ''' , min = 0 , max = 10 ), ) As usual, use p.preview() to preview the page and [os.remove(f) for f in app.tmpfiles if os.path.exists(f)] when you're done.","title":"Creating a demographics page"},{"location":"tutorial/qpolymorphs/#code-explanation","text":"Here we add several 'question polymorphs' (i.e. types of questions) to our page. The first is an input. We add placeholder='mm/dd/yyyy' , telling participants the expected format of their date of birth. The next two are check questions, which allow participants to check one or more choices. Notice that the first check question allows participants to check only one choice; we allow participants to check multiple choices in the second check question by passing multiple=True . The fourth question is a select (dropdown) question. If we wanted, we also could have passed multiple=True to its contructor to allow participants to select multiple options. Our final question is a range slider. By default, it goes from 0 to 100, but we set its range from 0 to 10 here.","title":"Code explanation"},{"location":"tutorial/qpolymorphs/#adding-the-page-to-the-survey","text":"Once we're satisfied with the preview, we incorporate the page into our survey. Our survey.py file should be: from hemlock import Branch , Check , Input , Page , Label , Range , Select , route @route ( '/survey' ) def start (): return Branch ( Page ( Input ( '<p>Enter your date of birth.</p>' , placeholder = 'mm/dd/yyyy' ), # INSERT THE REST OF THE DEMOGRAPHICS PAGE HERE ), Page ( Label ( '<p>Thank you for completing this survey.</p>' ), terminal = True ) )","title":"Adding the page to the survey"},{"location":"tutorial/qpolymorphs/#summary","text":"In this part of the tutorial, you learned how to create a demographics questionnaire using several question polymorphs. In the next part of the tutorial, you'll learn how to store and download survey data.","title":"Summary"},{"location":"tutorial/random_ass/","text":"Random assignment In the previous part of the tutorial, you leanred how to add comprehension checks to your studies. By the end of this part of the tutorial, you'll be able to randomly assign your participants to conditions, for example treatment and control. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Basic syntax Open your jupyter notebook and run the following: from hemlock import Participant from hemlock.tools import Assigner part = Participant . gen_test_participant () conditions = { 'Treatment' : ( 0 , 1 ), 'Level' : ( 'low' , 'med' , 'high' )} assigner = Assigner ( conditions ) assigner . next () Out: {'Treatment': 0, 'Level': 'low'} The Assigner randomly and evenly assigns participants to conditions, and easily handles factorial designs. It automatically records the assignment in the participant's embedded data: [( e . var , e . data ) for e in part . embedded ] Out: [('Treatment', 0), ('Level', 'low')] Random assignment in our app In survey.py : ... from hemlock.tools import Assigner , comprehension_check , join from datetime import datetime from random import randint # the number of rounds participants play N_ROUNDS = 5 # the amount of money split POT = 20 assigner = Assigner ({ 'Proposer' : ( 0 , 1 )}) ... @N . register def ultimatum_game ( start_branch = None ): proposer = assigner . next ()[ 'Proposer' ] return Branch ( * comprehension_check ( # COMPREHENSION CHECK ARGUMENTS HERE ), Page ( Label ( ''' <p>You are about to play an ultimatum game as a <b>{}</b>.</p> ''' . format ( 'proposer' if proposer else 'responder' ) ), terminal = True ) ) Run your app and pass the comprehenion check to see which condition you've been assigned to. Summary In this part of the tutorial, you learned how to assign participants to conditions. In the next part of the tutorial, you'll implement the proposer branch of the ultimatum game.","title":"Random assignment"},{"location":"tutorial/random_ass/#random-assignment","text":"In the previous part of the tutorial, you leanred how to add comprehension checks to your studies. By the end of this part of the tutorial, you'll be able to randomly assign your participants to conditions, for example treatment and control. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial.","title":"Random assignment"},{"location":"tutorial/random_ass/#basic-syntax","text":"Open your jupyter notebook and run the following: from hemlock import Participant from hemlock.tools import Assigner part = Participant . gen_test_participant () conditions = { 'Treatment' : ( 0 , 1 ), 'Level' : ( 'low' , 'med' , 'high' )} assigner = Assigner ( conditions ) assigner . next () Out: {'Treatment': 0, 'Level': 'low'} The Assigner randomly and evenly assigns participants to conditions, and easily handles factorial designs. It automatically records the assignment in the participant's embedded data: [( e . var , e . data ) for e in part . embedded ] Out: [('Treatment', 0), ('Level', 'low')]","title":"Basic syntax"},{"location":"tutorial/random_ass/#random-assignment-in-our-app","text":"In survey.py : ... from hemlock.tools import Assigner , comprehension_check , join from datetime import datetime from random import randint # the number of rounds participants play N_ROUNDS = 5 # the amount of money split POT = 20 assigner = Assigner ({ 'Proposer' : ( 0 , 1 )}) ... @N . register def ultimatum_game ( start_branch = None ): proposer = assigner . next ()[ 'Proposer' ] return Branch ( * comprehension_check ( # COMPREHENSION CHECK ARGUMENTS HERE ), Page ( Label ( ''' <p>You are about to play an ultimatum game as a <b>{}</b>.</p> ''' . format ( 'proposer' if proposer else 'responder' ) ), terminal = True ) ) Run your app and pass the comprehenion check to see which condition you've been assigned to.","title":"Random assignment in our app"},{"location":"tutorial/random_ass/#summary","text":"In this part of the tutorial, you learned how to assign participants to conditions. In the next part of the tutorial, you'll implement the proposer branch of the ultimatum game.","title":"Summary"},{"location":"tutorial/responder_branch/","text":"Responder branch In the previous part of the tutorial, you implemented the proposer branch. In this part of the tutorial, you'll implement the responder branch. The responder branch is similar to the proposer branch. For a great exercise, see if you can create it yourself without looking at my code. Click here to see what your survey.py file should look like at the end of this part of the tutorial. Adding the responder branch to our survey Because the responder branch is similar to the proposer branch, we'll skip the notebook and work straight in survey.py . I'll point out the differences as we go along. First, let's add a navigate function to the end of our ultimatum game branch to bring us to the responder branch: ... @N . register def ultimatum_game ( start_branch = None ): proposer = assigner . next ()[ 'Proposer' ] return Branch ( # PAGES HERE navigate = N . proposer_branch () if proposer else N . responder_branch () ) ... @N . register def responder_branch ( ultimatum_game_branch = None ): branch = Branch () for round_ in range ( N_ROUNDS ): response_input = gen_response_input ( round_ + 1 ) branch . pages . append ( Page ( response_input )) branch . pages . append ( Page ( Label ( compile = C . responder_outcome ( response_input )), cache_compile = True )) branch . pages . append ( Page ( Label ( '<p>Thank you for completing the hemlock tutorial!</p>' ), terminal = True )) return branch Like in the proposer branch, we add two pages to the responder branch for each of N_ROUNDS . Just as the first of these two pages asked the proposer for the proposal in the proposer branch, the first of these two pages asks the responder for their response in the responder branch. Like in the proposer branch, the second of these pages displays the outcome of the round. The responder input Just as the proposer's input was created with gen_proposal_input , the responder's input is created with gen_response_input : ... def gen_response_input ( round_ ): return Input ( ''' <p><b>Round {} of {}</b></p> <p>The proposer has ${} to split between him/herself and you. Complete this sentence:</p> <p>I will accept any proposal which gives me at least</p> ''' . format ( round_ , N_ROUNDS , POT ), prepend = '$' , append = '.00' , var = 'Response' , validate = V . range_val ( 0 , POT ), submit = S . data_type ( int ) ) As before, we add valiation so that the input must be between 0 and the size of the pot, and a submit function which converts the data to an integer. Displaying the responder outcome We register a compile function to display the responder outcome. ... @C . register def responder_outcome ( outcome_label , responder_input ): # get the response response = responder_input . data # randomly select a proposal proposal_inputs = Input . query . filter ( Input . var == 'Proposal' , Input . data != None ) . all () if proposal_inputs : # randomly choose a proposal n = random . choice ( proposal_inputs ) . data else : # no proposals are available # e.g. if this is the first participant n = randint ( 0 , POT ) proposal = POT - n , n # compute the payoff accept = response <= proposal [ 1 ] payoff = proposal if accept else ( 0 , 0 ) # record results as embedded data outcome_label . page . embedded = [ Embedded ( 'Proposal' , proposal [ 1 ]), Embedded ( 'Accept' , int ( accept )), Embedded ( 'ProposerPayoff' , payoff [ 0 ]), Embedded ( 'ResponderPayoff' , payoff [ 1 ]) ] # describe the outcome of the round outcome_label . label = ''' <p>The proposer proposed the following split:</p> <ul> <li>Proposer: $ {} </li> <li>You: $ {} </li> </ul> <p>You said you will accept any proposal which gives you at least $ {} .</p> <p><b>You {} the proposal, giving you a payoff of $ {} .</b></p> ''' . format ( * proposal , response , 'accepted' if accept else 'rejected' , payoff [ 1 ] ) This is similar to the proposer_outcome compile function. First, it gets the responder's response. Second, it matches the responder with a random proposer. If no proposer is avaiable (e.g. if the responder is the first participant in the survey), it generates a random proposal. Third, we compute the payoff for the round and record it using embedded data. Finally, we update the label to display the outcome of the round to the proposer. Run the app to see what the survey looks like in the responder condition. Summary In this part of the tutorial, you implemented the responder branch. In the next part of the tutorial, you'll learn how to use hemlock's cutom debugger to make sure everything is running smoothly.","title":"Responder branch"},{"location":"tutorial/responder_branch/#responder-branch","text":"In the previous part of the tutorial, you implemented the proposer branch. In this part of the tutorial, you'll implement the responder branch. The responder branch is similar to the proposer branch. For a great exercise, see if you can create it yourself without looking at my code. Click here to see what your survey.py file should look like at the end of this part of the tutorial.","title":"Responder branch"},{"location":"tutorial/responder_branch/#adding-the-responder-branch-to-our-survey","text":"Because the responder branch is similar to the proposer branch, we'll skip the notebook and work straight in survey.py . I'll point out the differences as we go along. First, let's add a navigate function to the end of our ultimatum game branch to bring us to the responder branch: ... @N . register def ultimatum_game ( start_branch = None ): proposer = assigner . next ()[ 'Proposer' ] return Branch ( # PAGES HERE navigate = N . proposer_branch () if proposer else N . responder_branch () ) ... @N . register def responder_branch ( ultimatum_game_branch = None ): branch = Branch () for round_ in range ( N_ROUNDS ): response_input = gen_response_input ( round_ + 1 ) branch . pages . append ( Page ( response_input )) branch . pages . append ( Page ( Label ( compile = C . responder_outcome ( response_input )), cache_compile = True )) branch . pages . append ( Page ( Label ( '<p>Thank you for completing the hemlock tutorial!</p>' ), terminal = True )) return branch Like in the proposer branch, we add two pages to the responder branch for each of N_ROUNDS . Just as the first of these two pages asked the proposer for the proposal in the proposer branch, the first of these two pages asks the responder for their response in the responder branch. Like in the proposer branch, the second of these pages displays the outcome of the round.","title":"Adding the responder branch to our survey"},{"location":"tutorial/responder_branch/#the-responder-input","text":"Just as the proposer's input was created with gen_proposal_input , the responder's input is created with gen_response_input : ... def gen_response_input ( round_ ): return Input ( ''' <p><b>Round {} of {}</b></p> <p>The proposer has ${} to split between him/herself and you. Complete this sentence:</p> <p>I will accept any proposal which gives me at least</p> ''' . format ( round_ , N_ROUNDS , POT ), prepend = '$' , append = '.00' , var = 'Response' , validate = V . range_val ( 0 , POT ), submit = S . data_type ( int ) ) As before, we add valiation so that the input must be between 0 and the size of the pot, and a submit function which converts the data to an integer.","title":"The responder input"},{"location":"tutorial/responder_branch/#displaying-the-responder-outcome","text":"We register a compile function to display the responder outcome. ... @C . register def responder_outcome ( outcome_label , responder_input ): # get the response response = responder_input . data # randomly select a proposal proposal_inputs = Input . query . filter ( Input . var == 'Proposal' , Input . data != None ) . all () if proposal_inputs : # randomly choose a proposal n = random . choice ( proposal_inputs ) . data else : # no proposals are available # e.g. if this is the first participant n = randint ( 0 , POT ) proposal = POT - n , n # compute the payoff accept = response <= proposal [ 1 ] payoff = proposal if accept else ( 0 , 0 ) # record results as embedded data outcome_label . page . embedded = [ Embedded ( 'Proposal' , proposal [ 1 ]), Embedded ( 'Accept' , int ( accept )), Embedded ( 'ProposerPayoff' , payoff [ 0 ]), Embedded ( 'ResponderPayoff' , payoff [ 1 ]) ] # describe the outcome of the round outcome_label . label = ''' <p>The proposer proposed the following split:</p> <ul> <li>Proposer: $ {} </li> <li>You: $ {} </li> </ul> <p>You said you will accept any proposal which gives you at least $ {} .</p> <p><b>You {} the proposal, giving you a payoff of $ {} .</b></p> ''' . format ( * proposal , response , 'accepted' if accept else 'rejected' , payoff [ 1 ] ) This is similar to the proposer_outcome compile function. First, it gets the responder's response. Second, it matches the responder with a random proposer. If no proposer is avaiable (e.g. if the responder is the first participant in the survey), it generates a random proposal. Third, we compute the payoff for the round and record it using embedded data. Finally, we update the label to display the outcome of the round to the proposer. Run the app to see what the survey looks like in the responder condition.","title":"Displaying the responder outcome"},{"location":"tutorial/responder_branch/#summary","text":"In this part of the tutorial, you implemented the responder branch. In the next part of the tutorial, you'll learn how to use hemlock's cutom debugger to make sure everything is running smoothly.","title":"Summary"},{"location":"tutorial/run_local/","text":"Running hemlock locally In the previous part of the tutorial, you learned how to initialize a hemlock project and create and preview a hemlock page. By the end of this part of the tutorial, you'll be able to initialize a hemlock application and run it locally. Note. Running an app 'locally' means that you can play with it on your own computer, but it won't be available on the internet. We'll cover deployment later. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Why run locally? In the previous part of the tutorial, we created and previewed a page in a jupyter notebook. Hemlock + jupyter notebook is great for trying out ideas and iterating quickly, like working on a blackboard. However, it won't create a fully responsive application. The application itself derives from survey.py . To preview our survey as a fully responsive web application, we need to run our app locally. Open a second terminal window You should have jupyter running in a terminal window from the previous part of the tutorial. Open a second terminal window. In general, I recommend having one terminal open for jupyter, and a second for editing python files and running your app. In the second terminal window, change to your project folder: $ cd $ cd my-first-project Run your application Create a python file called survey.py in the root directory of your project. If you're working with Visual Studio Code, enter the following in your terminal: $ code survey.py Enter the following code in survey.py : from hemlock import Branch , Page , Label , route @route ( '/survey' ) def start (): return Branch ( Page ( Label ( '<p>Hello, World!</p>' ), terminal = True ) ) To preview your survey, go to your (second) terminal window and enter: $ hlk serve Prepare to get served. * Restarting with stat * Debugger is active! * Debugger PIN: 183 -643-336 ( 2841 ) wsgi starting up on http://127.0.0.1:5000 Then navigate to http://localhost:5000/ in your browser. Code explanation After our imports, we use the @route('/survey') decorator to register our first 'navigate' function. This essentially tells our application, 'start here'. Navigate functions direct the 'survey flow'. All navigate functions return Branch objects. A branch contains a list of pages which it displays to participants. We set a branch's pages by passing them as arguments to the constructor, or by setting a branch's pages attribute, meaning that the following are equivalent: b = Branch ( Page ( Label ( '<p>Label 0</p>' )), Page ( Label ( '<p>Label 1</p>' ))) b = Branch () b . pages = [ Page ( Label ( '<p>Label 0</p>' )), Page ( Label ( '<p>Label 1</p>' ))] We also passed a keyword (named) argument to the page constructor, terminal=True . This tells the application 'end here'. Workflow In the previous part of the tutorial, we designed a page in jupyter notebook. In this part of the tutorial, we used that design in our survey file. The entire hemlock tutorial follows this general workflow: Iterate quickly on the next part of your survey in jupyter. When you're happy with the design, update your survey files (e.g. survey.py ). Run the app locally with hlk serve (or python3 app.py ). When you're happy with how the app runs, close the app (click on your terminal and hit Ctrl + C). Repeat. As the name blackboard.ipynb suggests, I treat jupyter like a blackboard. Once I'm happy with a design and it's running in my app, I like to start the next design on a fresh blackboard: Delete every cell in the notebook (except the first, where we push the application context, and the last, where we remove temporary files). Restart the kernel (Kernel >> Restart). Run the first cell to re-push the application context. Troubleshooting During development, you may encounter a database error from which your app can't recover. Even after you've fixed your code, your database will still be broken. If this happens in your jupyter notebook, simply restart your kernel (Kernel >> Restart) and run your code cells again. If this happens while running your app locally: Exit with Ctrl + C. Remove the database with rm data.db . Run your app again with hlk serve .","title":"Running hemlock locally"},{"location":"tutorial/run_local/#running-hemlock-locally","text":"In the previous part of the tutorial, you learned how to initialize a hemlock project and create and preview a hemlock page. By the end of this part of the tutorial, you'll be able to initialize a hemlock application and run it locally. Note. Running an app 'locally' means that you can play with it on your own computer, but it won't be available on the internet. We'll cover deployment later. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial.","title":"Running hemlock locally"},{"location":"tutorial/run_local/#why-run-locally","text":"In the previous part of the tutorial, we created and previewed a page in a jupyter notebook. Hemlock + jupyter notebook is great for trying out ideas and iterating quickly, like working on a blackboard. However, it won't create a fully responsive application. The application itself derives from survey.py . To preview our survey as a fully responsive web application, we need to run our app locally.","title":"Why run locally?"},{"location":"tutorial/run_local/#open-a-second-terminal-window","text":"You should have jupyter running in a terminal window from the previous part of the tutorial. Open a second terminal window. In general, I recommend having one terminal open for jupyter, and a second for editing python files and running your app. In the second terminal window, change to your project folder: $ cd $ cd my-first-project","title":"Open a second terminal window"},{"location":"tutorial/run_local/#run-your-application","text":"Create a python file called survey.py in the root directory of your project. If you're working with Visual Studio Code, enter the following in your terminal: $ code survey.py Enter the following code in survey.py : from hemlock import Branch , Page , Label , route @route ( '/survey' ) def start (): return Branch ( Page ( Label ( '<p>Hello, World!</p>' ), terminal = True ) ) To preview your survey, go to your (second) terminal window and enter: $ hlk serve Prepare to get served. * Restarting with stat * Debugger is active! * Debugger PIN: 183 -643-336 ( 2841 ) wsgi starting up on http://127.0.0.1:5000 Then navigate to http://localhost:5000/ in your browser.","title":"Run your application"},{"location":"tutorial/run_local/#code-explanation","text":"After our imports, we use the @route('/survey') decorator to register our first 'navigate' function. This essentially tells our application, 'start here'. Navigate functions direct the 'survey flow'. All navigate functions return Branch objects. A branch contains a list of pages which it displays to participants. We set a branch's pages by passing them as arguments to the constructor, or by setting a branch's pages attribute, meaning that the following are equivalent: b = Branch ( Page ( Label ( '<p>Label 0</p>' )), Page ( Label ( '<p>Label 1</p>' ))) b = Branch () b . pages = [ Page ( Label ( '<p>Label 0</p>' )), Page ( Label ( '<p>Label 1</p>' ))] We also passed a keyword (named) argument to the page constructor, terminal=True . This tells the application 'end here'.","title":"Code explanation"},{"location":"tutorial/run_local/#workflow","text":"In the previous part of the tutorial, we designed a page in jupyter notebook. In this part of the tutorial, we used that design in our survey file. The entire hemlock tutorial follows this general workflow: Iterate quickly on the next part of your survey in jupyter. When you're happy with the design, update your survey files (e.g. survey.py ). Run the app locally with hlk serve (or python3 app.py ). When you're happy with how the app runs, close the app (click on your terminal and hit Ctrl + C). Repeat. As the name blackboard.ipynb suggests, I treat jupyter like a blackboard. Once I'm happy with a design and it's running in my app, I like to start the next design on a fresh blackboard: Delete every cell in the notebook (except the first, where we push the application context, and the last, where we remove temporary files). Restart the kernel (Kernel >> Restart). Run the first cell to re-push the application context.","title":"Workflow"},{"location":"tutorial/run_local/#troubleshooting","text":"During development, you may encounter a database error from which your app can't recover. Even after you've fixed your code, your database will still be broken. If this happens in your jupyter notebook, simply restart your kernel (Kernel >> Restart) and run your code cells again. If this happens while running your app locally: Exit with Ctrl + C. Remove the database with rm data.db . Run your app again with hlk serve .","title":"Troubleshooting"},{"location":"tutorial/submit/","text":"Submit In the previous part of the tutorial, you learned how to validate participant responses. By the end of this part of the tutorial, you'll be able to run functions to handle form submission. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Why submit functions? Our demographics page asks participants to enter their date of birth. In addition to date of birth, we also want to record the participant's age. Submit functions run after a participant submits a page and their responses are validated. We're going to attach a submit function to our date of birth input question to record our participants' age as embedded data. Basic syntax Open your jupyter notebook and run the following: from hemlock import Input , Submit as S inpt = Input ( '<p>Enter \"hello world\"</p>' , submit = S . match ( 'hello world' )) inpt . submit Out: [<Submit 1>] You can add submit functions to a page or question by settings its submit attribute or passing a submit argument to its constructor. Submit functions run when a participant successfully submits a page. The match submit function changes a question's data to 1 if the data matches a regex pattern, in this case 'hello world' , and 0 if it does not. Let's set the input question's data and watch our submit function work: inpt . data = 'hello world' inpt . _submit () . data Out: 1 inpt . data = 'something other than hello world' inpt . _submit () . data Out: 0 Notes. You don't need to run _submit yourself in the survey; hemlock takes care of this automatically for you. match is just one of many prebuilt submit functions . Custom submission We're going to use a custom submit function to record our participants' age. Let's see how to do this in our notebook. from hemlock import Embedded , Page from datetime import datetime @S . register def record_age ( inpt ): # calculate age in years date_of_birth = datetime . strptime ( inpt . data , '%m/ %d /%Y' ) age = ( datetime . utcnow () - date_of_birth ) . days / 365.25 # record age as embedded data inpt . page . embedded = [ Embedded ( 'Age' , age , data_rows =- 1 )] page = Page ( Input ( '<p>Enter your date of birth.</p>' , submit = S . record_age ()) ) inpt = page . questions [ 0 ] inpt . data = '10/26/1992' inpt . _submit () page . embedded [ 0 ] . data Out: 27.742642026009584 Code explanation We register a new submit function with the @S.register decorator. The submit function takes the input question as its argument. In general, submit functions take their parent as their first argument. record_age converts the input's data to a datetime object, computes the participant's age, and records it as embedded data. Submission in our app Now that we've seen how to add submit functions in our notebook, let's add it to our app. In survey.py : from hemlock import Branch , Check , Embedded , Input , Label , Page , Range , Select , Submit as S , Validate as V , route from datetime import datetime @route ( '/survey' ) def start (): return Branch ( Page ( Input ( '<p>Enter your date of birth.</p>' , placeholder = 'mm/dd/yyyy' , var = 'DoB' , data_rows =- 1 , validate = [ V . require (), V . date_format ()], submit = S . record_age () ), # REST OF THE DEMOGRAPHICS PAGE HERE ), Page ( Label ( '<p>Thank you for completing the survey!</p>' ), terminal = True ) ) ... @S . register def record_age ( inpt ): # calculate age in years date_of_birth = datetime . strptime ( inpt . data , '%m/ %d /%Y' ) age = ( datetime . utcnow () - date_of_birth ) . days / 365.25 # record age as embedded data inpt . page . embedded = [ Embedded ( 'Age' , age , data_rows =- 1 )] Run the app again, fill in the demographics page, and download the data. You'll now see a variable 'Age' in the data frame. Summary In this part of the tutorial, you learned how create and run submit functions. In the next part of the tutorial, you'll implement a confirmation page using compile functions.","title":"Submit"},{"location":"tutorial/submit/#submit","text":"In the previous part of the tutorial, you learned how to validate participant responses. By the end of this part of the tutorial, you'll be able to run functions to handle form submission. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial.","title":"Submit"},{"location":"tutorial/submit/#why-submit-functions","text":"Our demographics page asks participants to enter their date of birth. In addition to date of birth, we also want to record the participant's age. Submit functions run after a participant submits a page and their responses are validated. We're going to attach a submit function to our date of birth input question to record our participants' age as embedded data.","title":"Why submit functions?"},{"location":"tutorial/submit/#basic-syntax","text":"Open your jupyter notebook and run the following: from hemlock import Input , Submit as S inpt = Input ( '<p>Enter \"hello world\"</p>' , submit = S . match ( 'hello world' )) inpt . submit Out: [<Submit 1>] You can add submit functions to a page or question by settings its submit attribute or passing a submit argument to its constructor. Submit functions run when a participant successfully submits a page. The match submit function changes a question's data to 1 if the data matches a regex pattern, in this case 'hello world' , and 0 if it does not. Let's set the input question's data and watch our submit function work: inpt . data = 'hello world' inpt . _submit () . data Out: 1 inpt . data = 'something other than hello world' inpt . _submit () . data Out: 0 Notes. You don't need to run _submit yourself in the survey; hemlock takes care of this automatically for you. match is just one of many prebuilt submit functions .","title":"Basic syntax"},{"location":"tutorial/submit/#custom-submission","text":"We're going to use a custom submit function to record our participants' age. Let's see how to do this in our notebook. from hemlock import Embedded , Page from datetime import datetime @S . register def record_age ( inpt ): # calculate age in years date_of_birth = datetime . strptime ( inpt . data , '%m/ %d /%Y' ) age = ( datetime . utcnow () - date_of_birth ) . days / 365.25 # record age as embedded data inpt . page . embedded = [ Embedded ( 'Age' , age , data_rows =- 1 )] page = Page ( Input ( '<p>Enter your date of birth.</p>' , submit = S . record_age ()) ) inpt = page . questions [ 0 ] inpt . data = '10/26/1992' inpt . _submit () page . embedded [ 0 ] . data Out: 27.742642026009584","title":"Custom submission"},{"location":"tutorial/submit/#code-explanation","text":"We register a new submit function with the @S.register decorator. The submit function takes the input question as its argument. In general, submit functions take their parent as their first argument. record_age converts the input's data to a datetime object, computes the participant's age, and records it as embedded data.","title":"Code explanation"},{"location":"tutorial/submit/#submission-in-our-app","text":"Now that we've seen how to add submit functions in our notebook, let's add it to our app. In survey.py : from hemlock import Branch , Check , Embedded , Input , Label , Page , Range , Select , Submit as S , Validate as V , route from datetime import datetime @route ( '/survey' ) def start (): return Branch ( Page ( Input ( '<p>Enter your date of birth.</p>' , placeholder = 'mm/dd/yyyy' , var = 'DoB' , data_rows =- 1 , validate = [ V . require (), V . date_format ()], submit = S . record_age () ), # REST OF THE DEMOGRAPHICS PAGE HERE ), Page ( Label ( '<p>Thank you for completing the survey!</p>' ), terminal = True ) ) ... @S . register def record_age ( inpt ): # calculate age in years date_of_birth = datetime . strptime ( inpt . data , '%m/ %d /%Y' ) age = ( datetime . utcnow () - date_of_birth ) . days / 365.25 # record age as embedded data inpt . page . embedded = [ Embedded ( 'Age' , age , data_rows =- 1 )] Run the app again, fill in the demographics page, and download the data. You'll now see a variable 'Age' in the data frame.","title":"Submission in our app"},{"location":"tutorial/submit/#summary","text":"In this part of the tutorial, you learned how create and run submit functions. In the next part of the tutorial, you'll implement a confirmation page using compile functions.","title":"Summary"},{"location":"tutorial/validate/","text":"Validation In the previous part of the tutorial, you learned how to store and download data. By the end of this part of the tutorial, you'll be able to validate participant responses. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial. Why validation? I often run studies where I elicit numerical estimates. Early on, I noticed that a small but annoying faction of participants, rather than entering actual numbers (e.g. 50), answered the question in full sentences: I believe the answer is fifty. We often need to make sure participants are entering the right kind of answer, whether it's typing the same password twice, answering a comprehension check by clicking on the correct choice, or entering a number instead of a word. Basic syntax Open your jupyter notebook and run the following: from hemlock import Input , Validate as V inpt = Input ( validate = V . require ()) inpt . validate Out: [<Validate 1>] You can add validate functions to a page or question by setting its validate attribute or passing a validate argument to its constructor. Validate functions run when a participant attempts to submit a page. If the participant's response is valid, the function returns None , allowing the participant to continue the survey. If the participant's response is invalid, the function returns an error message. As its name indicates, the validate function requires the participant to respond to the input question. By default, the input question has no response. It also has no error message. We can see this as follows: ( 'The input has no response or error message' , not inpt . response and not inpt . error ) Out: ('The input has no response or error message', True) Now, let's run the validate function. Because the input question has no response, the validate function will return an error message. This error message is stored in the input question's error attribute: inpt . _validate () inpt . error Out: 'Please respond to this question.' Notes: You don't need to run _validate yourself in the survey; hemlock takes care of this automatically for you. require is just one of many prebuilt validate functions . Custom validation This is a good start, but what happens when someone enters a nonsense response for date of birth? For this, we're going to need a custom validate function. Let's see how to do this in our notebook: from datetime import datetime @V . register def date_format ( inpt ): try : # try to convert to a datetime object datetime . strptime ( inpt . response , '%m/ %d /%Y' ) except : # if this fails, the participant entered an invalid response return '<p>Format your date of birth as mm/dd/yyyy.</p>' inpt = Input ( validate = V . date_format ()) inpt . response = ''' I, George Thaddeus Thatch the Third, was born in the first fortnight of August 1792. ''' inpt . _validate () inpt . error Out: Format your date of birth as mm/dd/yyyy. Code explanation First, we import datetime , a native python package for handling dates and times. Next, we register a new validate function with the @V.register decorator. The validate function tries to convert the input question's response to a datetime object and returns an error message if this fails. It's worth re-emphasizing that V.my_function does not return the result of my_function . V.my_function returns <Validate x> , which will call my_function later, when the participant attempts to submit the page. Note that date_format takes an input question as its argument. In general, validate functions take their 'parent' (the branch, page, or question to which they belong) as their first argument. The arguments passed to V.my_function will be passed to my_function after the parent. For example: @V . register def my_function ( parent , my_argument ): print ( 'My parent is:' , parent ) print ( 'My argument is:' , my_argument ) inpt = Input ( validate = V . my_function ( 'hello world' )) inpt Out: <Input 1> In: inpt . _validate () Out: My parent is: <Input 1> My argument is: hello world The same pattern holds for the other function models (submit, compile, and navigate functions) we will see in the coming sections. Validation in our app Now that we've seen how to add validation in our notebook, let's add it to our app. In survey.py : from hemlock import Branch , Check , Input , Label , Page , Range , Select , Validate as V , route from datetime import datetime @route ( '/survey' ) def start (): return Branch ( Page ( Input ( '<p>Enter your date of birth.</p>' , placeholder = 'mm/dd/yyyy' , var = 'DoB' , data_rows =- 1 , validate = V . date_format () ), Check ( '<p>Indicate your gender.</p>' , [ 'Male' , 'Female' , 'Other' ], var = 'Gender' , data_rows =- 1 , validate = V . require () ), # REST OF THE DEMOGRAPHICS PAGE HERE ), Page ( Label ( '<p>Thank you for completing the survey!</p>' ), terminal = True ) ) @V . register def date_format ( inpt ): try : # try to convert to a datetime object datetime . strptime ( inpt . response , '%m/ %d /%Y' ) except : # if this fails, the participant entered an invalid response return '<p>Format your date of birth as mm/dd/yyyy.</p>' Run the app again and try to continue past the demographics page; enter an invalid date of birth, leave some questions blank, and see your validation at work. Multiple validate functions You can attach multiple validation functions by setting validate to a list of functions. Validate functions run in the order in which you add them, stopping with the first validate function which returns an error. Try adding require to the date of birth question by changing validate=V.date_format() to validate=[V.require(), V.date_format()] . Run your app and leave the date of birth empty. The error message will be, 'Please respond to this question.' . Enter an invalid date of birth. The error message will be 'Format your date of birth as mm/dd/yyyy.' . Summary In this part of the tutorial, you learned how to validate participant responses. In the next part of the tutorial, you'll learn how to run submit functions to modify participant data after they submit a page.","title":"Validate"},{"location":"tutorial/validate/#validation","text":"In the previous part of the tutorial, you learned how to store and download data. By the end of this part of the tutorial, you'll be able to validate participant responses. Click here to see what your blackboard.ipynb and survey.py files should look like at the end of this part of the tutorial.","title":"Validation"},{"location":"tutorial/validate/#why-validation","text":"I often run studies where I elicit numerical estimates. Early on, I noticed that a small but annoying faction of participants, rather than entering actual numbers (e.g. 50), answered the question in full sentences: I believe the answer is fifty. We often need to make sure participants are entering the right kind of answer, whether it's typing the same password twice, answering a comprehension check by clicking on the correct choice, or entering a number instead of a word.","title":"Why validation?"},{"location":"tutorial/validate/#basic-syntax","text":"Open your jupyter notebook and run the following: from hemlock import Input , Validate as V inpt = Input ( validate = V . require ()) inpt . validate Out: [<Validate 1>] You can add validate functions to a page or question by setting its validate attribute or passing a validate argument to its constructor. Validate functions run when a participant attempts to submit a page. If the participant's response is valid, the function returns None , allowing the participant to continue the survey. If the participant's response is invalid, the function returns an error message. As its name indicates, the validate function requires the participant to respond to the input question. By default, the input question has no response. It also has no error message. We can see this as follows: ( 'The input has no response or error message' , not inpt . response and not inpt . error ) Out: ('The input has no response or error message', True) Now, let's run the validate function. Because the input question has no response, the validate function will return an error message. This error message is stored in the input question's error attribute: inpt . _validate () inpt . error Out: 'Please respond to this question.' Notes: You don't need to run _validate yourself in the survey; hemlock takes care of this automatically for you. require is just one of many prebuilt validate functions .","title":"Basic syntax"},{"location":"tutorial/validate/#custom-validation","text":"This is a good start, but what happens when someone enters a nonsense response for date of birth? For this, we're going to need a custom validate function. Let's see how to do this in our notebook: from datetime import datetime @V . register def date_format ( inpt ): try : # try to convert to a datetime object datetime . strptime ( inpt . response , '%m/ %d /%Y' ) except : # if this fails, the participant entered an invalid response return '<p>Format your date of birth as mm/dd/yyyy.</p>' inpt = Input ( validate = V . date_format ()) inpt . response = ''' I, George Thaddeus Thatch the Third, was born in the first fortnight of August 1792. ''' inpt . _validate () inpt . error Out: Format your date of birth as mm/dd/yyyy.","title":"Custom validation"},{"location":"tutorial/validate/#code-explanation","text":"First, we import datetime , a native python package for handling dates and times. Next, we register a new validate function with the @V.register decorator. The validate function tries to convert the input question's response to a datetime object and returns an error message if this fails. It's worth re-emphasizing that V.my_function does not return the result of my_function . V.my_function returns <Validate x> , which will call my_function later, when the participant attempts to submit the page. Note that date_format takes an input question as its argument. In general, validate functions take their 'parent' (the branch, page, or question to which they belong) as their first argument. The arguments passed to V.my_function will be passed to my_function after the parent. For example: @V . register def my_function ( parent , my_argument ): print ( 'My parent is:' , parent ) print ( 'My argument is:' , my_argument ) inpt = Input ( validate = V . my_function ( 'hello world' )) inpt Out: <Input 1> In: inpt . _validate () Out: My parent is: <Input 1> My argument is: hello world The same pattern holds for the other function models (submit, compile, and navigate functions) we will see in the coming sections.","title":"Code explanation"},{"location":"tutorial/validate/#validation-in-our-app","text":"Now that we've seen how to add validation in our notebook, let's add it to our app. In survey.py : from hemlock import Branch , Check , Input , Label , Page , Range , Select , Validate as V , route from datetime import datetime @route ( '/survey' ) def start (): return Branch ( Page ( Input ( '<p>Enter your date of birth.</p>' , placeholder = 'mm/dd/yyyy' , var = 'DoB' , data_rows =- 1 , validate = V . date_format () ), Check ( '<p>Indicate your gender.</p>' , [ 'Male' , 'Female' , 'Other' ], var = 'Gender' , data_rows =- 1 , validate = V . require () ), # REST OF THE DEMOGRAPHICS PAGE HERE ), Page ( Label ( '<p>Thank you for completing the survey!</p>' ), terminal = True ) ) @V . register def date_format ( inpt ): try : # try to convert to a datetime object datetime . strptime ( inpt . response , '%m/ %d /%Y' ) except : # if this fails, the participant entered an invalid response return '<p>Format your date of birth as mm/dd/yyyy.</p>' Run the app again and try to continue past the demographics page; enter an invalid date of birth, leave some questions blank, and see your validation at work.","title":"Validation in our app"},{"location":"tutorial/validate/#multiple-validate-functions","text":"You can attach multiple validation functions by setting validate to a list of functions. Validate functions run in the order in which you add them, stopping with the first validate function which returns an error. Try adding require to the date of birth question by changing validate=V.date_format() to validate=[V.require(), V.date_format()] . Run your app and leave the date of birth empty. The error message will be, 'Please respond to this question.' . Enter an invalid date of birth. The error message will be 'Format your date of birth as mm/dd/yyyy.' .","title":"Multiple validate functions"},{"location":"tutorial/validate/#summary","text":"In this part of the tutorial, you learned how to validate participant responses. In the next part of the tutorial, you'll learn how to run submit functions to modify participant data after they submit a page.","title":"Summary"}]}